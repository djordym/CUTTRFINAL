
// File: app.json
{
"expo": {
"name": "MyCuttrApp",
"slug": "MyCuttrApp",
"version": "1.0.0",
"orientation": "portrait",
"icon": "./assets/images/icon.png",
"scheme": "myapp",
"userInterfaceStyle": "automatic",
"newArchEnabled": true,
"ios": {
"supportsTablet": true
},
"android": {
"adaptiveIcon": {
"foregroundImage": "./assets/images/adaptive-icon.png",
"backgroundColor": "#ffffff"
}
},
"web": {
"bundler": "metro",
"output": "static",
"favicon": "./assets/images/favicon.png"
},
"plugins": [
"expo-router",
[
"expo-splash-screen",
{
"image": "./assets/images/splash-icon.png",
"imageWidth": 200,
"resizeMode": "contain",
"backgroundColor": "#ffffff"
}
],
"expo-localization"
],
"experiments": {
"typedRoutes": true
}
}
}
// File: babel.config.js
module.exports = function(api) {
api.cache(true);
return {
presets: ['babel-preset-expo'],
plugins: ['react-native-reanimated/plugin'],
};
};
// File: expo-env.d.ts

// File: package.json
{
"name": "mycuttrapp",
"main": "expo-router/entry",
"version": "1.0.0",
"scripts": {
"start": "expo start",
"reset-project": "node ./scripts/reset-project.js",
"android": "expo start --android",
"ios": "expo start --ios",
"web": "expo start --web",
"test": "jest --watchAll",
"lint": "expo lint"
},
"jest": {
"preset": "jest-expo"
},
"dependencies": {
"@expo/vector-icons": "^14.0.2",
"@react-navigation/bottom-tabs": "^7.2.0",
"@react-navigation/native": "^7.0.14",
"@react-navigation/native-stack": "^7.2.0",
"@react-navigation/stack": "^7.1.1",
"@reduxjs/toolkit": "^2.5.0",
"axios": "^1.7.9",
"expo": "^52.0.23",
"expo-blur": "~14.0.1",
"expo-constants": "~17.0.3",
"expo-font": "~13.0.2",
"expo-haptics": "~14.0.0",
"expo-image-picker": "^16.0.3",
"expo-linear-gradient": "~14.0.1",
"expo-linking": "~7.0.3",
"expo-localization": "~16.0.0",
"expo-router": "~4.0.15",
"expo-secure-store": "^14.0.0",
"expo-splash-screen": "~0.29.18",
"expo-status-bar": "^2.0.0",
"expo-symbols": "~0.2.0",
"expo-system-ui": "~4.0.6",
"expo-web-browser": "~14.0.1",
"i18next": "^24.2.0",
"react": "18.3.1",
"react-dom": "18.3.1",
"react-i18next": "^15.2.0",
"react-native": "^0.76.5",
"react-native-gesture-handler": "~2.20.2",
"react-native-logs": "^5.3.0",
"react-native-maps": "1.18.0",
"react-native-reanimated": "^3.16.6",
"react-native-safe-area-context": "4.12.0",
"react-native-screens": "^4.4.0",
"react-native-vector-icons": "^10.2.0",
"react-native-web": "~0.19.13",
"react-native-webview": "13.12.5",
"react-query": "^3.39.3",
"react-redux": "^9.2.0"
},
"devDependencies": {
"@babel/core": "^7.26.0",
"@types/jest": "^29.5.12",
"@types/react": "~18.3.12",
"@types/react-redux": "^7.1.34",
"@types/react-test-renderer": "^18.3.0",
"jest": "^29.2.1",
"jest-expo": "~52.0.2",
"react-test-renderer": "18.3.1",
"typescript": "^5.7.2"
},
"private": true
}
// File: tsconfig.json
{
"extends": "expo/tsconfig.base",
"compilerOptions": {
"strict": true
},
"include": [
"***.tsx",
".expo/types*.ts",
"expo-env.d.ts"
]
}
// File: app\ErrorBoundary.tsx
interface ErrorBoundaryProps {
children: React.ReactNode;
}
export class ErrorBoundary extends React.Component<ErrorBoundaryProps> {
state = { hasError: false };
static getDerivedStateFromError(error: Error) {
return { hasError: true };
}
componentDidCatch(error: Error, info: any) {
log.error("Uncaught error in component tree", { error, info });
}
render() {
if (this.state.hasError) {
return (
<View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
<Text>An unexpected error occurred.</Text>
</View>
);
}
return this.props.children;
}
}
// File: app\index.tsx
const queryClient = new QueryClient();
export default function App() {
log.debug('App.tsx rendering...');
const [i18nInstance, setI18nInstance] = useState<any>(null);
useEffect(() => {
const setupI18n = async () => {
const i18n = await initI18n();
setI18nInstance(i18n);
};
setupI18n();
}, []);
if (!i18nInstance) {
return (
<View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
<ActivityIndicator size="large" />
</View>
);
}
return (
<ErrorBoundary>
<Provider store={store}>
<QueryClientProvider client={queryClient}>
{}
<I18nextProvider i18n={i18nInstance}>
<GestureHandlerRootView style={{ flex: 1 }}>
<AppNavigator />
</GestureHandlerRootView>
</I18nextProvider>
</QueryClientProvider>
</Provider>
</ErrorBoundary>
);
}
// File: app\api\authService.ts
UserLoginRequest,
UserLoginResponse,
RefreshTokenRequest,
AuthTokenResponse,
UserRegistrationRequest
} from '../types/apiTypes';
export const authService = {
login: async (data: UserLoginRequest): Promise<UserLoginResponse> => {
const response = await api.post<UserLoginResponse>('/auth/login', data);
return response.data;
},
refreshToken: async (data: RefreshTokenRequest): Promise<AuthTokenResponse> => {
const response = await api.post<AuthTokenResponse>('/auth/refresh', data);
return response.data;
},
register: async (data: UserRegistrationRequest): Promise<UserLoginResponse> => {
const response = await api.post<UserLoginResponse>('/users/register', data);
log.debug('response', response);
return response.data;
},
logout: async (): Promise<void> => {
await api.post('/api/auth/logout');
},
};
// File: app\api\axiosConfig.ts
let isRefreshing = false;
let pendingRequests: Array<(token: string) => void> = [];
const api = axios.create({
baseURL: "http:
timeout: 10000,
});
api.interceptors.request.use(
async (config) => {
const state: RootState = store.getState();
const token = state.auth.accessToken;
log.debug("Token", token);
if (token && config.headers) {
log.debug("configuring headers for token");
config.headers.Authorization = `Bearer ${token}`;
}
log.debug("API Request", {
baseUrl : api.defaults.baseURL,
url: config.url,
method: config.method,
data: config.data,
headers: config.headers,
});
return config;
},
(error) => {
log.error("API Request Error", error);
return Promise.reject(error);
}
);
api.interceptors.response.use(
(response) => {
log.debug("API Response", {
url: response.config.url,
status: response.status,
data: response.data,
header: response.headers,
});
return response;
},
async (error) => {
log.error("API Response Error", {
url: error.config.url,
message: error.message,
status: error.response.status,
data: error.response.data,
headers: error.response.headers,
});
if (!error.response) {
store.dispatch(setGlobalError("Network Error: Unable to connect."));
return Promise.reject(error);
}
const { status } = error.response;
const originalRequest = error.config;
if (status === 401 && !originalRequest._retry) {
if (!isRefreshing) {
isRefreshing = true;
originalRequest._retry = true;
try {
const result = await store.dispatch(refreshTokenThunk());
let newTokens: AuthTokenResponse | undefined;
if (refreshTokenThunk.fulfilled.match(result)) {
newTokens = result.payload;
console.log("New tokens:", newTokens);
} else {
console.error(
"Token refresh failed:",
result.payload || result.error.message
);
}
isRefreshing = false;
pendingRequests.forEach((cb) => cb(newTokens?.accessToken || ""));
pendingRequests = [];
return api(originalRequest);
} catch (refreshError) {
isRefreshing = false;
pendingRequests = [];
store.dispatch(logout());
return Promise.reject(refreshError);
}
}
return new Promise((resolve) => {
pendingRequests.push((token: string) => {
originalRequest.headers.Authorization = `Bearer ${token}`;
resolve(api(originalRequest));
});
});
}
let errorMessage: string;
if (typeof error.response.data === "string") {
errorMessage = error.response.data;
} else if (error.response.data?.message) {
errorMessage = error.response.data.message;
} else {
errorMessage = "An error occurred. Please try again later.";
}
store.dispatch(setGlobalError(errorMessage));
return Promise.reject(error);
}
);
export default api;
// File: app\api\matchService.ts
export const matchService = {
getMyMatches: async (): Promise<MatchResponse[]> => {
const response = await api.get<MatchResponse[]>('/matches/me');
return response.data;
},
getMatchById: async (matchId: number): Promise<MatchResponse> => {
const response = await api.get<MatchResponse>(`/matches/${matchId}`);
return response.data;
}
};
// File: app\api\messageService.ts
export const messageService = {
sendMessage: async (data: MessageRequest): Promise<MessageResponse> => {
const response = await api.post<MessageResponse>('/messages/me', data);
return response.data;
},
getMessagesForMatch: async (matchId: number): Promise<MessageResponse[]> => {
const response = await api.get<MessageResponse[]>(`/matches/${matchId}/messages`);
return response.data;
}
};
// File: app\api\plantService.ts
export const plantService = {
addMyPlant: async (data: PlantCreateRequest): Promise<PlantResponse> => {
const formData = new FormData();
formData.append('Image', data.Image);
formData.append('SpeciesName', data.PlantDetails.SpeciesName);
formData.append('Description', data.PlantDetails.Description);
formData.append('PlantStage', data.PlantDetails.PlantStage);
formData.append('PlantCategory', data.PlantDetails.PlantCategory);
formData.append('WateringNeed', data.PlantDetails.WateringNeed);
formData.append('LightRequirement', data.PlantDetails.LightRequirement);
if (data.PlantDetails.Size) formData.append('Size', data.PlantDetails.Size);
if (data.PlantDetails.IndoorOutdoor) formData.append('IndoorOutdoor', data.PlantDetails.IndoorOutdoor);
if (data.PlantDetails.PropagationEase) formData.append('PropagationEase', data.PlantDetails.PropagationEase);
if (data.PlantDetails.PetFriendly) formData.append('PetFriendly', data.PlantDetails.PetFriendly);
if (data.PlantDetails.Extras) {
data.PlantDetails.Extras.forEach((extra) => formData.append('Extras', extra));
}
const response = await api.post<PlantResponse>('/plants/me', formData, {
headers: { 'Content-Type': 'multipart/form-data' }
});
return response.data;
},
getPlantById: async (plantId: number): Promise<PlantResponse> => {
const response = await api.get<PlantResponse>(`/plants/${plantId}`);
return response.data;
},
updateMyPlant: async (plantId: number, data: PlantRequest): Promise<PlantResponse> => {
const response = await api.put<PlantResponse>(`/plants/me/${plantId}`, data);
return response.data;
},
deleteMyPlant: async (plantId: number): Promise<void> => {
await api.delete(`/plants/me/${plantId}`);
},
getUserPlants: async (userId: number): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>(`/users/${userId}/plants`);
return response.data;
},
getMyPlants: async (): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>('/users/me/plants');
return response.data;
}
};
// File: app\api\reportService.ts
export const reportService = {
createReport: async (data: ReportRequest): Promise<ReportResponse> => {
const response = await api.post<ReportResponse>('/reports', data);
return response.data;
}
};
// File: app\api\swipeService.ts
export const swipeService = {
sendSwipes: async (swipes: SwipeRequest[]): Promise<SwipeResponse> => {
const response = await api.post<SwipeResponse>('/swipes/me', swipes);
return response.data;
},
getLikablePlants: async (): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>('/swipes/me/likable-plants');
return response.data;
}
};
// File: app\api\userPreferencesService.ts
export const userPreferencesService = {
getPreferences: async (): Promise<UserPreferencesResponse> => {
const response = await api.get<UserPreferencesResponse>('/userpreferences');
return response.data;
},
updatePreferences: async (data: UserPreferencesRequest): Promise<UserPreferencesResponse> => {
const response = await api.post<UserPreferencesResponse>('/userpreferences', data);
return response.data;
}
};
// File: app\api\userService.ts
export const userService = {
register: async (data: { Email: string; Password: string; Name: string }): Promise<UserResponse> => {
const response = await api.post<UserResponse>('/users/register', data);
return response.data;
},
getUser: async (userId: number): Promise<UserResponse> => {
const response = await api.get<UserResponse>(`/users/${userId}`);
return response.data;
},
updateMe: async (data: UserUpdateRequest): Promise<UserResponse> => {
const response = await api.put<UserResponse>('/users/me', data);
return response.data;
},
deleteMe: async (): Promise<void> => {
await api.delete('/users/me');
},
updateProfilePicture: async (data: UserProfileImageUpdateRequest): Promise<UserResponse> => {
const formData = new FormData();
formData.append('Image', data.image);
const response = await api.put<UserResponse>('/users/me/profile-picture', formData, {
headers: { 'Content-Type': 'multipart/form-data' }
});
return response.data;
},
updateLocation: async (data: UpdateLocationRequest): Promise<void> => {
await api.put('/users/me/location', data);
}
};
// File: app\components\index.ts

// File: app\components\common\BrandedButton.tsx
interface Props {
title: string;
onPress: () => void;
disabled?: boolean;
}
const BrandedButton: React.FC<Props> = ({ title, onPress, disabled }) => {
return (
<TouchableOpacity onPress={onPress} style={[styles.button, disabled && {opacity:0.5}]} disabled={disabled}>
<Text style={styles.buttonText}>{title}</Text>
</TouchableOpacity>
);
};
export default BrandedButton;
const styles = StyleSheet.create({
button: {
backgroundColor: '#1EAE98',
padding: 16,
borderRadius: 8,
alignItems:'center',
marginVertical:10
},
buttonText: {
color:'#fff',
fontSize:16,
fontWeight:'600'
}
});
// File: app\components\common\TextInputField.tsx
interface Props {
value: string;
onChangeText: (text: string) => void;
placeholder?: string;
secureTextEntry?: boolean;
}
const TextInputField: React.FC<Props> = ({ value, onChangeText, placeholder, secureTextEntry }) => {
return (
<View style={styles.container}>
<TextInput
style={styles.input}
value={value}
onChangeText={onChangeText}
placeholder={placeholder}
secureTextEntry={secureTextEntry}
placeholderTextColor="#999"
/>
</View>
);
};
export default TextInputField;
const styles = StyleSheet.create({
container: {
marginVertical: 10,
borderWidth:1,
borderColor:'#ccc',
borderRadius:8,
},
input: {
padding:12,
fontSize:16,
}
});
// File: app\components\feedback\ErrorMessage.tsx
interface Props {
message: string | null;
}
const ErrorMessage: React.FC<Props> = ({ message }) => {
if (!message) return null;
return (
<View style={styles.container}>
<Text style={styles.text}>{message}</Text>
</View>
);
};
export default ErrorMessage;
const styles = StyleSheet.create({
container: {
backgroundColor: '#FF6B6B',
padding: 10,
marginBottom:10,
borderRadius:8
},
text: {
color: '#fff',
fontWeight:'500',
textAlign:'center'
}
});
// File: app\components\feedback\ErrorState.tsx

// File: app\components\feedback\LoadingSpinner.tsx

// File: app\features\auth\index.ts

// File: app\features\auth\hooks\useAuth.ts

// File: app\features\auth\screens\LoginScreen.tsx
const LoginScreen = () => {
const { t } = useTranslation();
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const { status, error } = useAppSelector((state: RootState) => state.auth);
const dispatch = useAppDispatch();
const navigation = useNavigation();
const handleLogin = async () => {
let userLoginRequest: UserLoginRequest = {
email: email,
password: password
};
log.debug('Pressed login button, userLoginRequest:', userLoginRequest);
await dispatch(loginThunk(userLoginRequest));
};
return (
<KeyboardAvoidingView style={styles.container} behavior="padding">
<Image source={require('../../../../assets/images/logo.png')} style={styles.logo} />
<Text style={styles.title}>{t('welcome_back')}</Text>
<ErrorMessage message={error} />
<TextInputField
value={email}
onChangeText={setEmail}
placeholder={t('email')}
/>
<TextInputField
value={password}
onChangeText={setPassword}
placeholder={t('password')}
secureTextEntry
/>
<BrandedButton title={t('login')} onPress={handleLogin} disabled={status === 'loading'} />
<TouchableOpacity onPress={() => navigation.navigate('Register' as never)}>
<Text style={styles.link}>{t('no_account_register')}</Text>
</TouchableOpacity>
</KeyboardAvoidingView>
);
};
export default LoginScreen;
const styles = StyleSheet.create({
container: {
flex:1,
justifyContent:'center',
padding:20,
backgroundColor:'#fff'
},
logo: {
width:100,
height:100,
alignSelf:'center',
marginBottom:20
},
title: {
fontSize:24,
fontWeight:'700',
textAlign:'center',
marginBottom:20
},
link: {
color:'#1EAE98',
textAlign:'center',
marginTop:20
}
});
// File: app\features\auth\screens\RegisterScreen.tsx
const RegisterScreen = () => {
const { t } = useTranslation();
const [name, setName] = useState('');
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const { status, error } = useAppSelector((state: RootState) => state.auth);
const dispatch = useAppDispatch();
const navigation = useNavigation();
const handleRegister = async () => {
const userRegistrationRequest: UserRegistrationRequest = {
email: email,
password: password,
name: name,
};
log.debug('Pressed register button, userRegistrationRequest:', userRegistrationRequest);
await dispatch(registerThunk(userRegistrationRequest));
};
return (
<KeyboardAvoidingView style={styles.container} behavior="padding">
<Image source={require('../../../../assets/images/logo.png')} style={styles.logo} />
<Text style={styles.title}>{t('create_account')}</Text>
<ErrorMessage message={error} />
<TextInputField
value={name}
onChangeText={setName}
placeholder={t('name')}
/>
<TextInputField
value={email}
onChangeText={setEmail}
placeholder={t('email')}
/>
<TextInputField
value={password}
onChangeText={setPassword}
placeholder={t('password')}
secureTextEntry
/>
<BrandedButton title={t('register')} onPress={handleRegister} disabled={status === 'loading'} />
<TouchableOpacity onPress={() => navigation.navigate('Login' as never)}>
<Text style={styles.link}>{t('have_account_login')}</Text>
</TouchableOpacity>
</KeyboardAvoidingView>
);
};
export default RegisterScreen;
const styles = StyleSheet.create({
container: {
flex:1,
justifyContent:'center',
padding:20,
backgroundColor:'#fff'
},
logo: {
width:100,
height:100,
alignSelf:'center',
marginBottom:20
},
title: {
fontSize:24,
fontWeight:'700',
textAlign:'center',
marginBottom:20
},
link: {
color:'#1EAE98',
textAlign:'center',
marginTop:20
}
});
// File: app\features\auth\store\authSlice.ts
UserLoginRequest,
UserLoginResponse,
UserRegistrationRequest,
RefreshTokenRequest,
AuthTokenResponse
} from '../../../types/apiTypes';
interface AuthState {
accessToken: string | null;
refreshToken: string | null;
userId: number | null;
email: string | null;
status: 'idle' | 'loading' | 'error';
error: string | null;
}
const initialState: AuthState = {
accessToken: null,
refreshToken: null,
userId: null,
email: null,
status: 'idle',
error: null
};
export const loginThunk = createAsyncThunk<
UserLoginResponse,
UserLoginRequest,
{ rejectValue: string }
>(
'auth/login',
async (credentials, { rejectWithValue }) => {
try {
const data = await authService.login(credentials);
log.debug('loginThunk data:', data);
await storage.saveTokens(data.tokens.accessToken, data.tokens.refreshToken);
return data;
} catch (error: any) {
log.error("Login error details:", error);
return rejectWithValue(error.response?.data?.message || 'Login failed');
}
}
);
export const registerThunk = createAsyncThunk<
UserLoginResponse,
UserRegistrationRequest,
{ rejectValue: string }
>(
'auth/register',
async (payload, { rejectWithValue }) => {
try {
const data = await authService.register(payload);
await storage.saveTokens(data.tokens.accessToken, data.tokens.refreshToken);
return data;
} catch (error: any) {
log.error("Registration error details:", error);
if (error.response) {
log.error("Registration error response data:", error.response.data);
log.error("Registration error response status:", error.response.status);
log.error("Registration error response headers:", error.response.headers);
} else {
log.error("Registration error: no response object", error.message);
}
return rejectWithValue(error.response?.data || 'Registration failed');
}
}
);
export const refreshTokenThunk = createAsyncThunk<
AuthTokenResponse,
void,
{ state: RootState; rejectValue: string }
>(
'auth/refreshToken',
async (_, { getState, rejectWithValue }) => {
const state = getState();
const refreshToken = state.auth.refreshToken;
if (!refreshToken) {
return rejectWithValue('No refresh token available');
}
const payload: RefreshTokenRequest = { refreshToken: refreshToken };
try {
const data = await authService.refreshToken(payload);
await storage.saveTokens(data.accessToken, data.refreshToken);
return data;
} catch (error: any) {
return rejectWithValue('Token refresh failed');
}
}
);
export const authSlice = createSlice({
name: 'auth',
initialState,
reducers: {
setInitialTokens(
state,
action: PayloadAction<{ accessToken: string | null; refreshToken: string | null; userId: number | null; email: string | null }>
) {
state.accessToken = action.payload.accessToken;
state.refreshToken = action.payload.refreshToken;
state.userId = action.payload.userId;
state.email = action.payload.email;
},
logout(state) {
state.accessToken = null;
state.refreshToken = null;
state.userId = null;
state.email = null;
state.error = null;
state.status = 'idle';
storage.clearTokens();
}
},
extraReducers: (builder) => {
builder
.addCase(loginThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(loginThunk.fulfilled, (state, action) => {
state.status = 'idle';
state.accessToken = action.payload.tokens.accessToken;
state.refreshToken = action.payload.tokens.refreshToken;
state.userId = action.payload.userId;
state.email = action.payload.email;
})
.addCase(loginThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload || 'Unknown error';
})
.addCase(registerThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(registerThunk.fulfilled, (state, action) => {
state.status = 'idle';
state.accessToken = action.payload.tokens.accessToken;
state.refreshToken = action.payload.tokens.refreshToken;
state.userId = action.payload.userId;
state.email = action.payload.email;
})
.addCase(registerThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload || 'Unknown error';
})
.addCase(refreshTokenThunk.fulfilled, (state, action) => {
state.accessToken = action.payload.accessToken;
state.refreshToken = action.payload.refreshToken;
})
.addCase(refreshTokenThunk.rejected, (state) => {
state.accessToken = null;
state.refreshToken = null;
state.userId = null;
state.email = null;
});
}
});
export const { logout, setInitialTokens } = authSlice.actions;
// File: app\features\auth\types\authTypes.ts

// File: app\features\main\index.ts

// File: app\features\main\components\ChangeLocationModal.tsx
interface ChangeLocationModalProps {
visible: boolean;
initialLatitude?: number;
initialLongitude?: number;
onClose: () => void;
onUpdated: () => void;
}
export const ChangeLocationModal: React.FC<ChangeLocationModalProps> = ({ visible, initialLatitude, initialLongitude, onClose, onUpdated }) => {
return (
<Modal visible={visible} animationType="slide" transparent>
</Modal>
)
};
const styles = StyleSheet.create({
overlay:{
flex:1,
backgroundColor:'rgba(0,0,0,0.5)',
justifyContent:'center',
alignItems:'center'
},
modalContainer:{
width:'90%',
height:'80%',
backgroundColor:'#fff',
borderRadius:16,
padding:20
},
title:{
fontSize:18,
fontWeight:'700',
color:'#333',
marginBottom:10
},
subtitle:{
fontSize:14,
color:'#555',
marginBottom:10
},
errorText:{
color:'#FF6B6B',
marginBottom:10
},
mapContainer:{
flex:1,
borderRadius:8,
overflow:'hidden',
marginBottom:10
},
actions:{
flexDirection:'row',
justifyContent:'flex-end'
},
cancelButton:{
marginRight:10
},
cancelButtonText:{
fontSize:16,
color:'#333'
},
confirmButton:{
backgroundColor:'#1EAE98',
paddingHorizontal:15,
paddingVertical:10,
borderRadius:8
},
confirmButtonText:{
fontSize:16,
color:'#fff',
fontWeight:'600'
}
});
// File: app\features\main\components\EditProfileModal.tsx
interface EditProfileModalProps {
visible: boolean;
initialName: string;
initialBio: string;
onClose: () => void;
onUpdated: () => void;
}
export const EditProfileModal: React.FC<EditProfileModalProps> = ({ visible, initialName, initialBio, onClose, onUpdated }) => {
const { t } = useTranslation();
const [name, setName] = useState(initialName);
const [bio, setBio] = useState(initialBio);
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const handleConfirm = async () => {
setLoading(true);
setError(null);
const payload: UserUpdateRequest = { name: name, bio: bio };
try {
await userService.updateMe(payload);
onUpdated();
onClose();
} catch {
setError(t('edit_profile_error_message'));
} finally {
setLoading(false);
}
};
const handleCancel = () => {
onClose();
};
return (
<Modal visible={visible} animationType="slide" transparent>
<View style={styles.overlay}>
<View style={styles.modalContainer}>
<Text style={styles.title}>{t('edit_profile_title')}</Text>
{error && <Text style={styles.errorText}>{error}</Text>}
<Text style={styles.label}>{t('edit_profile_name_label')}:</Text>
<TextInput
style={styles.input}
value={name}
onChangeText={setName}
accessibilityLabel={t('edit_profile_name_label')}
/>
<Text style={styles.label}>{t('edit_profile_bio_label')}:</Text>
<TextInput
style={[styles.input, { height:80 }]}
value={bio}
onChangeText={setBio}
multiline
accessibilityLabel={t('edit_profile_bio_label')}
/>
{loading && <ActivityIndicator size="small" color="#1EAE98" style={{marginVertical:10}}/>}
<View style={styles.actions}>
<TouchableOpacity onPress={handleCancel} style={styles.cancelButton} accessibilityRole="button">
<Text style={styles.cancelButtonText}>{t('edit_profile_cancel_button')}</Text>
</TouchableOpacity>
<TouchableOpacity onPress={handleConfirm} style={styles.confirmButton} accessibilityRole="button">
<Text style={styles.confirmButtonText}>{t('edit_profile_confirm_button')}</Text>
</TouchableOpacity>
</View>
</View>
</View>
</Modal>
);
};
const styles = StyleSheet.create({
overlay:{
flex:1,
backgroundColor:'rgba(0,0,0,0.5)',
justifyContent:'center',
alignItems:'center'
},
modalContainer:{
width:'90%',
backgroundColor:'#fff',
borderRadius:16,
padding:20
},
title:{
fontSize:18,
fontWeight:'700',
color:'#333',
marginBottom:10
},
errorText:{
color:'#FF6B6B',
marginBottom:10
},
label:{
fontSize:14,
fontWeight:'600',
color:'#333',
marginBottom:4
},
input:{
borderWidth:1,
borderColor:'#ccc',
borderRadius:8,
padding:10,
marginBottom:10,
fontSize:14
},
actions:{
flexDirection:'row',
justifyContent:'flex-end',
marginTop:10
},
cancelButton:{
marginRight:10
},
cancelButtonText:{
fontSize:16,
color:'#333'
},
confirmButton:{
backgroundColor:'#1EAE98',
paddingHorizontal:15,
paddingVertical:10,
borderRadius:8
},
confirmButtonText:{
fontSize:16,
color:'#fff',
fontWeight:'600'
}
});
// File: app\features\main\components\SelectPlantsModal.tsx
interface SelectPlantsModalProps {
visible: boolean;
onClose: () => void;
onConfirm: (selectedPlantIds: number[]) => void;
}
export const SelectPlantsModal: React.FC<SelectPlantsModalProps> = ({ visible, onClose, onConfirm }) => {
const { data: myPlants, isLoading, isError, refetch } = useMyPlants();
const [selectedPlantIds, setSelectedPlantIds] = useState<number[]>([]);
const toggleSelection = (id: number) => {
setSelectedPlantIds((prev) =>
prev.includes(id) ? prev.filter((pid) => pid !== id) : [...prev, id]
);
};
const handleConfirm = () => {
onConfirm(selectedPlantIds);
setSelectedPlantIds([]);
};
const handleClose = () => {
setSelectedPlantIds([]);
onClose();
};
return (
<Modal visible={visible} animationType="slide" transparent>
<View style={styles.overlay}>
<View style={styles.modalContainer}>
<Text style={styles.title}>Select Your Plants</Text>
<Text style={styles.subtitle}>Select the plants you want to offer for swapping.</Text>
{isLoading && (
<View style={styles.centerContent}>
<ActivityIndicator size="large" color="#1EAE98" />
</View>
)}
{isError && (
<View style={styles.centerContent}>
<Text style={styles.errorText}>Failed to load your plants.</Text>
<TouchableOpacity onPress={() => refetch()} style={styles.retryButton}>
<Text style={styles.retryButtonText}>Try Again</Text>
</TouchableOpacity>
</View>
)}
{myPlants && (
<ScrollView style={styles.list}>
{myPlants.map((plant: PlantResponse) => {
const selected = selectedPlantIds.includes(plant.plantId);
return (
<TouchableOpacity
key={plant.plantId}
onPress={() => toggleSelection(plant.plantId)}
style={styles.listItem}
accessibilityRole="checkbox"
accessibilityState={{ checked: selected }}
>
<Ionicons
name={selected ? "checkbox-outline" : "checkbox"}
size={24}
color={selected ? "#1EAE98" : "#ccc"}
style={{marginRight:10}}
/>
<Text style={styles.listItemText}>{plant.speciesName}</Text>
</TouchableOpacity>
);
})}
</ScrollView>
)}
<View style={styles.actions}>
<TouchableOpacity onPress={handleClose} style={styles.cancelButton} accessibilityRole="button" accessibilityLabel="Cancel" accessibilityHint="Close modal without changes">
<Text style={styles.cancelButtonText}>Cancel</Text>
</TouchableOpacity>
<TouchableOpacity onPress={handleConfirm} style={styles.confirmButton} accessibilityRole="button" accessibilityLabel="Confirm selection" accessibilityHint="Send swipe requests for selected and non-selected plants">
<Text style={styles.confirmButtonText}>Confirm</Text>
</TouchableOpacity>
</View>
</View>
</View>
</Modal>
);
};
const styles = StyleSheet.create({
overlay: {
flex:1,
backgroundColor:'rgba(0,0,0,0.5)',
justifyContent:'center',
alignItems:'center'
},
modalContainer: {
width:'90%',
maxHeight:'80%',
backgroundColor:'#fff',
borderRadius:16,
padding:20,
justifyContent:'flex-start'
},
title:{
fontSize:20,
fontWeight:'700',
color:'#333',
marginBottom:10
},
subtitle:{
fontSize:14,
color:'#555',
marginBottom:20
},
centerContent:{
alignItems:'center',
justifyContent:'center',
paddingVertical:20
},
errorText:{
fontSize:16,
color:'#333',
marginBottom:10
},
retryButton:{
backgroundColor:'#1EAE98',
paddingVertical:10,
paddingHorizontal:20,
borderRadius:8
},
retryButtonText:{
color:'#fff',
fontWeight:'600'
},
list:{
maxHeight:300,
marginBottom:20
},
listItem:{
flexDirection:'row',
alignItems:'center',
paddingVertical:10,
borderBottomWidth:1,
borderBottomColor:'#eee'
},
listItemText:{
fontSize:16,
color:'#333'
},
actions:{
flexDirection:'row',
justifyContent:'flex-end',
marginTop:10
},
cancelButton:{
paddingHorizontal:15,
paddingVertical:10,
marginRight:10
},
cancelButtonText:{
fontSize:16,
color:'#333'
},
confirmButton:{
backgroundColor:'#1EAE98',
paddingHorizontal:15,
paddingVertical:10,
borderRadius:8
},
confirmButtonText:{
fontSize:16,
color:'#fff',
fontWeight:'600'
}
});
// File: app\features\main\components\SwipeableCard.tsx
useSharedValue,
useAnimatedGestureHandler,
useAnimatedStyle,
runOnJS,
withSpring
} from 'react-native-reanimated';
const { width } = Dimensions.get('window');
const SWIPE_THRESHOLD = 0.25 * width;
interface SwipeableCardProps {
plant: PlantResponse;
onSwipeLeft: (plantId: number) => void;
onSwipeRight: (plantId: number) => void;
}
export const SwipeableCard: React.FC<SwipeableCardProps> = ({ plant, onSwipeLeft, onSwipeRight }) => {
const translateX = useSharedValue(0);
const rotateZ = useSharedValue(0);
const gestureHandler = useAnimatedGestureHandler<PanGestureHandlerGestureEvent, { startX: number }>({
onStart: (_, ctx) => {
ctx.startX = translateX.value;
},
onActive: (event, ctx) => {
translateX.value = ctx.startX + event.translationX;
rotateZ.value = (event.translationX / width) * 0.15;
},
onEnd: (event) => {
if (event.translationX > SWIPE_THRESHOLD) {
translateX.value = withSpring(width * 1.5, {}, (finished) => {
if (finished) runOnJS(onSwipeRight)(plant.plantId);
});
} else if (event.translationX < -SWIPE_THRESHOLD) {
translateX.value = withSpring(-width * 1.5, {}, (finished) => {
if (finished) runOnJS(onSwipeLeft)(plant.plantId);
});
} else {
translateX.value = withSpring(0);
rotateZ.value = withSpring(0);
}
},
});
const animatedStyle = useAnimatedStyle(() => {
return {
transform: [
{ translateX: translateX.value },
{ rotateZ: `${rotateZ.value}rad` }
]
};
});
return (
<PanGestureHandler onGestureEvent={gestureHandler}>
<Animated.View style={[styles.card, animatedStyle]}>
<View style={styles.imageContainer}>
{plant.imageUrl ? (
<Image source={{ uri: plant.imageUrl }} style={styles.image} />
) : (
<View style={styles.imagePlaceholder}>
<Text style={styles.placeholderText}>No Image</Text>
</View>
)}
</View>
<View style={styles.contentContainer}>
<Text style={styles.plantName}>{plant.speciesName}</Text>
<Text style={styles.plantDescription} numberOfLines={3}>
{plant.description}
</Text>
</View>
</Animated.View>
</PanGestureHandler>
);
};
const styles = StyleSheet.create({
card: {
width: width * 0.9,
backgroundColor: '#fff',
borderRadius: 16,
overflow: 'hidden',
position: 'absolute',
alignSelf: 'center',
top: 0,
bottom: 0,
marginVertical: 'auto',
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 10,
elevation: 5,
},
imageContainer: {
width: '100%',
height: 300,
backgroundColor: '#fafafa',
},
image: {
width: '100%',
height: '100%',
resizeMode: 'cover',
},
imagePlaceholder: {
flex:1,
justifyContent:'center',
alignItems:'center',
backgroundColor:'#eee',
},
placeholderText: {
color:'#999'
},
contentContainer: {
padding: 16,
},
plantName: {
fontSize: 20,
fontWeight: '700',
color:'#333',
marginBottom:8
},
plantDescription: {
fontSize: 16,
lineHeight: 22,
color:'#555'
},
});
// File: app\features\main\hooks\useMatches.ts
export const useMyMatches = () => {
return useQuery('myMatches', matchService.getMyMatches, {
staleTime: 0,
refetchOnWindowFocus: true,
});
};
// File: app\features\main\hooks\usePlants.ts
export const useUserPlants = (userId: number) => {
return useQuery(['userPlants', userId], () => plantService.getUserPlants(userId), {
enabled: !!userId,
staleTime: 1000 * 60 * 5,
});
};
export const useMyPlants = () => {
const { userId } = useSelector((state: RootState) => state.auth);
return useQuery<PlantResponse[], Error>(
['myPlants', userId],
() => {
if (!userId) throw new Error('User not logged in');
return plantService.getMyPlants();
},
{
enabled: !!userId,
staleTime: 1000 * 60 * 5
}
);
};
// File: app\features\main\hooks\usePreferences.ts
export const useUserPreferences = () => {
const queryClient = useQueryClient();
const query = useQuery<UserPreferencesResponse, Error>(
['userPreferences'],
userPreferencesService.getPreferences,
{
staleTime: 1000 * 60 * 5
}
);
const mutation = useMutation(
(data: UserPreferencesRequest) => userPreferencesService.updatePreferences(data),
{
onSuccess: () => {
queryClient.invalidateQueries(['userPreferences']);
}
}
);
return {
...query,
updatePreferences: mutation.mutate,
isUpdating: mutation.isLoading
};
};
// File: app\features\main\hooks\useSwipe.ts
export const useLikablePlants = () => {
const query = useQuery<PlantResponse[], Error>(
['likablePlants'],
swipeService.getLikablePlants,
{
staleTime: 1000 * 60 * 1,
refetchOnWindowFocus: false,
retry: 1,
}
);
return query;
};
// File: app\features\main\hooks\useUser.ts
export const useUserProfile = () => {
const userId = useSelector((state: RootState) => state.auth.userId);
return useQuery<UserResponse, Error>(
['userProfile', userId],
() => {
if (!userId) {
throw new Error('No userId available');
}
return userService.getUser(userId);
},
{
enabled: !!userId,
staleTime: 1000 * 60 * 5
}
);
};
// File: app\features\main\screens\AddPlantScreen.tsx
const AddPlantScreen: React.FC = () => {
const { t } = useTranslation();
const [speciesName, setSpeciesName] = useState('');
const [description, setDescription] = useState('');
const [stage, setStage] = useState<PlantStage>(PlantStage.Cutting);
const [category, setCategory] = useState<PlantCategory>(PlantCategory.Other);
const [watering, setWatering] = useState<WateringNeed>(WateringNeed.ModerateWater);
const [light, setLight] = useState<LightRequirement>(LightRequirement.PartialShade);
const [image, setImage] = useState<any>(null);
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const handleSelectImage = async () => {
let result = await ImagePicker.launchImageLibraryAsync({
mediaTypes: ImagePicker.MediaTypeOptions.Images,
allowsEditing: true,
quality: 0.7,
aspect: [3, 4],
});
if (!result.canceled) {
setImage(result.assets[0]);
}
};
const handleSave = async () => {
if (!speciesName || !description || !image) {
Alert.alert("Error", "Please fill all required fields and select an image.");
return;
}
setLoading(true);
setError(null);
const formData = new FormData();
formData.append('image', {
uri: image,
name: 'plant.jpg',
type: 'image/jpeg'
} as any);
formData.append('speciesName', speciesName);
formData.append('description', description);
formData.append('plantStage', stage.toString());
formData.append('plantCategory', category.toString());
formData.append('wateringNeed', watering.toString());
formData.append('lightRequirement', light.toString());
try {
await plantService.addMyPlant({ plantDetails: { speciesName: speciesName, description: description, plantStage: stage, plantCategory: category, wateringNeed: watering, lightRequirement: light }, image: formData.get('image') as any });
Alert.alert("Success", "Plant added successfully.");
} catch {
setError(t('add_plant_error_message'));
} finally {
setLoading(false);
}
};
return (
<ScrollView style={styles.container} contentContainerStyle={{padding:20}}>
<Text style={styles.title}>{t('add_plant_title')}</Text>
{error && <Text style={styles.errorText}>{error}</Text>}
<Text style={styles.label}>{t('add_plant_species_name_label')}:</Text>
<TextInput style={styles.input} value={speciesName} onChangeText={setSpeciesName} />
<Text style={styles.label}>{t('add_plant_description_label')}:</Text>
<TextInput style={[styles.input, {height:80}]} value={description} onChangeText={setDescription} multiline />
<Text style={styles.label}>{t('add_plant_stage_label')}:</Text>
<TextInput style={styles.input} value={PlantStage[stage]} onChangeText={(txt) => setStage(PlantStage[txt as keyof typeof PlantStage] || PlantStage.Cutting)} />
<Text style={styles.label}>{t('add_plant_category_label')}:</Text>
<TextInput style={styles.input} value={PlantCategory[category]} onChangeText={(txt) => setCategory(PlantCategory[txt as keyof typeof PlantCategory] || PlantCategory.Other)} />
<Text style={styles.label}>{t('add_plant_watering_label')}:</Text>
<TextInput style={styles.input} value={WateringNeed[watering]} onChangeText={(txt) => setWatering(WateringNeed[txt as keyof typeof WateringNeed] || WateringNeed.ModerateWater)} />
<Text style={styles.label}>{t('add_plant_light_label')}:</Text>
<TextInput style={styles.input} value={LightRequirement[light]} onChangeText={(txt) => setLight(LightRequirement[txt as keyof typeof LightRequirement] || LightRequirement.PartialShade)} />
<Text style={styles.label}>{t('add_plant_select_image_button')}:</Text>
<TouchableOpacity onPress={handleSelectImage} style={styles.imageButton}>
<Ionicons name="image" size={24} color="#fff" />
<Text style={styles.imageButtonText}>{t('add_plant_select_image_button')}</Text>
</TouchableOpacity>
{image ? (
<Image source={{ uri: image }} style={styles.previewImage} />
) : (
<Text style={styles.noImageText}>{t('add_plant_no_image_selected')}</Text>
)}
{loading && <ActivityIndicator size="small" color="#1EAE98" style={{marginVertical:10}}/>}
<View style={styles.actions}>
<TouchableOpacity style={styles.cancelButton} onPress={() => Alert.alert("Canceled", "Plant addition canceled.")}>
<Text style={styles.cancelButtonText}>{t('add_plant_cancel_button')}</Text>
</TouchableOpacity>
<TouchableOpacity style={styles.saveButton} onPress={handleSave}>
<Text style={styles.saveButtonText}>{t('add_plant_save_button')}</Text>
</TouchableOpacity>
</View>
</ScrollView>
);
};
export default AddPlantScreen;
const styles = StyleSheet.create({
container:{
flex:1,
backgroundColor:'#f8f8f8'
},
title:{
fontSize:20,
fontWeight:'700',
color:'#333',
marginBottom:20
},
errorText:{
color:'#FF6B6B',
marginBottom:10
},
label:{
fontSize:14,
fontWeight:'600',
color:'#333',
marginBottom:4
},
input:{
borderWidth:1,
borderColor:'#ccc',
borderRadius:8,
padding:10,
marginBottom:10,
fontSize:14,
backgroundColor:'#fff'
},
imageButton:{
flexDirection:'row',
alignItems:'center',
backgroundColor:'#1EAE98',
padding:10,
borderRadius:8,
marginBottom:10
},
imageButtonText:{
color:'#fff',
fontSize:14,
marginLeft:5
},
previewImage:{
width:'100%',
height:200,
resizeMode:'cover',
borderRadius:8,
marginBottom:10
},
noImageText:{
fontSize:14,
color:'#555',
marginBottom:10
},
actions:{
flexDirection:'row',
justifyContent:'flex-end',
marginTop:10
},
cancelButton:{
marginRight:10
},
cancelButtonText:{
fontSize:16,
color:'#333'
},
saveButton:{
backgroundColor:'#1EAE98',
paddingHorizontal:15,
paddingVertical:10,
borderRadius:8
},
saveButtonText:{
fontSize:16,
color:'#fff',
fontWeight:'600'
}
});
// File: app\features\main\screens\ChatScreen.tsx

// File: app\features\main\screens\HomeScreen.tsx

// File: app\features\main\screens\MatchListScreen.tsx

// File: app\features\main\screens\MyProfileScreen.tsx
View,
Text,
StyleSheet,
ActivityIndicator,
TouchableOpacity,
FlatList,
Image,
Alert,
Dimensions,
Platform,
} from 'react-native';
const { width } = Dimensions.get('window');
const COLORS = {
primary: '#1EAE98',
accent: '#FF6F61',
background: '#F2F2F2',
textDark: '#2F4F4F',
textLight: '#FFFFFF',
cardBg: '#FFFFFF',
border: '#ddd',
};
const ProfileScreen: React.FC = () => {
const { t } = useTranslation();
const navigation = useNavigation();
const {
data: userProfile,
isLoading: loadingProfile,
isError: errorProfile,
refetch: refetchProfile,
} = useUserProfile();
const {
data: myPlants,
isLoading: loadingPlants,
isError: errorPlants,
refetch: refetchPlants,
} = useMyPlants();
const [editProfileVisible, setEditProfileVisible] = useState(false);
const [changeLocationVisible, setChangeLocationVisible] = useState(false);
const handleEditProfile = useCallback(() => {
setEditProfileVisible(true);
}, []);
const handleProfileUpdated = useCallback(() => {
refetchProfile();
}, [refetchProfile]);
const handleChangeLocation = useCallback(() => {
setChangeLocationVisible(true);
}, []);
const handleLocationUpdated = useCallback(() => {
refetchProfile();
}, [refetchProfile]);
const handleAddPlant = useCallback(() => {
navigation.navigate('AddPlant' as never);
}, [navigation]);
const renderPlantItem = ({ item }: { item: PlantResponse }) => (
<View style={styles.plantCard}>
{item.imageUrl ? (
<Image source={{ uri: item.imageUrl }} style={styles.plantImage} />
) : (
<View style={styles.plantPlaceholder}>
<Ionicons name="leaf" size={40} color={COLORS.primary} />
</View>
)}
<View style={styles.plantDetails}>
<Text style={styles.plantName} numberOfLines={1}>
{item.speciesName}
</Text>
</View>
</View>
);
if (loadingProfile || loadingPlants) {
return (
<SafeAreaView style={styles.centerContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loadingText}>{t('profile_loading_message')}</Text>
</SafeAreaView>
);
}
if (errorProfile || errorPlants) {
return (
<SafeAreaView style={styles.centerContainer}>
<Text style={styles.errorText}>{t('profile_error_message')}</Text>
<TouchableOpacity
onPress={() => {
refetchProfile();
refetchPlants();
}}
style={styles.retryButton}
>
<Text style={styles.retryButtonText}>{t('profile_retry_button')}</Text>
</TouchableOpacity>
</SafeAreaView>
);
}
if (!userProfile) {
return null;
}
const userLocation =
userProfile.locationLatitude && userProfile.locationLongitude
? `Lat: ${userProfile.locationLatitude.toFixed(2)}, Lng: ${userProfile.locationLongitude.toFixed(2)}`
: t('profile_no_location');
return (
<SafeAreaView style={styles.container}>
{}
<LinearGradient
colors={[COLORS.primary, '#5EE2C6']}
style={styles.headerContainer}
>
<View style={styles.headerTopRow}>
<Text style={styles.headerTitle}>{t('profile_title')}</Text>
<TouchableOpacity
onPress={handleEditProfile}
style={styles.headerActionButton}
accessibilityLabel={t('profile_edit_button')}
>
<MaterialIcons name="edit" size={24} color={COLORS.textLight} />
</TouchableOpacity>
</View>
<View style={styles.profileInfoContainer}>
{userProfile.profilePictureUrl ? (
<Image
source={{ uri: userProfile.profilePictureUrl }}
style={styles.profilePicture}
/>
) : (
<View style={styles.profilePlaceholder}>
<Ionicons
name="person-circle-outline"
size={90}
color="#ccc"
/>
</View>
)}
<View style={styles.profileTextSection}>
<Text style={styles.profileName}>{userProfile.name}</Text>
{userProfile.bio ? (
<>
<Text style={styles.profileLabel}>
{t('profile_bio_label')}:
</Text>
<Text style={styles.profileValue} numberOfLines={3}>
{userProfile.bio}
</Text>
</>
) : null}
<View style={styles.profileLocationSection}>
<Text style={styles.profileLabel}>
{t('profile_location_label')}:
</Text>
<Text style={styles.profileValue}>{userLocation}</Text>
</View>
<TouchableOpacity
onPress={handleChangeLocation}
style={styles.locationButton}
accessibilityRole="button"
accessibilityLabel={t('profile_change_location_button')}
>
<Ionicons
name="location-outline"
size={18}
color={COLORS.primary}
/>
<Text style={styles.locationButtonText}>
{t('profile_change_location_button')}
</Text>
</TouchableOpacity>
</View>
</View>
</LinearGradient>
{}
<View style={styles.plantsSectionWrapper}>
<View style={styles.plantsSectionHeader}>
<Text style={styles.plantsSectionTitle}>
{t('profile_my_plants_section')}
</Text>
<TouchableOpacity
onPress={handleAddPlant}
style={styles.addPlantButton}
accessibilityRole="button"
accessibilityLabel={t('profile_add_plant_button')}
>
<Ionicons name="add-circle" size={24} color={COLORS.primary} />
<Text style={styles.addPlantButtonText}>
{t('profile_add_plant_button')}
</Text>
</TouchableOpacity>
</View>
<View style={styles.plantsContainer}>
{myPlants && myPlants.length > 0 ? (
<FlatList
data={myPlants}
keyExtractor={(item) => item.plantId.toString()}
renderItem={renderPlantItem}
numColumns={2}
columnWrapperStyle={{ justifyContent: 'space-between' }}
contentContainerStyle={styles.plantListContent}
/>
) : (
<View style={styles.noPlantsContainer}>
<Text style={styles.noPlantsText}>
{t('profile_no_plants_message')}
</Text>
</View>
)}
</View>
</View>
{}
<EditProfileModal
visible={editProfileVisible}
initialName={userProfile.name}
initialBio={userProfile.bio || ''}
onClose={() => setEditProfileVisible(false)}
onUpdated={handleProfileUpdated}
/>
<ChangeLocationModal
visible={changeLocationVisible}
initialLatitude={userProfile.locationLatitude || undefined}
initialLongitude={userProfile.locationLongitude || undefined}
onClose={() => setChangeLocationVisible(false)}
onUpdated={handleLocationUpdated}
/>
</SafeAreaView>
);
};
export default ProfileScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: COLORS.background,
},
centerContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
padding: 20,
},
loadingText: {
fontSize: 16,
color: COLORS.textDark,
marginTop: 10,
},
errorText: {
fontSize: 16,
color: COLORS.textDark,
marginBottom: 20,
textAlign: 'center',
},
retryButton: {
backgroundColor: COLORS.primary,
paddingVertical: 10,
paddingHorizontal: 20,
borderRadius: 8,
},
retryButtonText: {
color: '#fff',
fontSize: 16,
fontWeight: '600',
},
headerContainer: {
paddingHorizontal: 20,
paddingVertical: 20,
borderBottomLeftRadius: 40,
borderBottomRightRadius: 40,
marginBottom: 10,
},
headerTopRow: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
},
headerTitle: {
fontSize: 24,
fontWeight: '700',
color: COLORS.textLight,
},
headerActionButton: {
padding: 8,
},
profileInfoContainer: {
flexDirection: 'row',
alignItems: 'center',
marginTop: 15,
},
profilePicture: {
width: 100,
height: 100,
borderRadius: 50,
backgroundColor: '#eee',
marginRight: 15,
borderWidth: 2,
borderColor: '#fff',
},
profilePlaceholder: {
width: 100,
height: 100,
borderRadius: 50,
backgroundColor: '#eee',
alignItems: 'center',
justifyContent: 'center',
marginRight: 15,
},
profileTextSection: {
flexShrink: 1,
},
profileName: {
fontSize: 18,
fontWeight: '700',
color: COLORS.textLight,
marginBottom: 6,
},
profileLabel: {
fontSize: 14,
fontWeight: '600',
color: COLORS.textLight,
marginBottom: 2,
},
profileValue: {
fontSize: 14,
color: COLORS.textLight,
marginBottom: 8,
},
profileLocationSection: {
marginTop: 6,
},
locationButton: {
flexDirection: 'row',
alignItems: 'center',
marginTop: 8,
paddingHorizontal: 10,
paddingVertical: 6,
borderWidth: 1,
borderColor: COLORS.primary,
borderRadius: 8,
alignSelf: 'flex-start',
backgroundColor: '#fff',
},
locationButtonText: {
color: COLORS.primary,
fontSize: 14,
marginLeft: 5,
fontWeight: '600',
},
plantsSectionWrapper: {
flex: 1,
paddingHorizontal: 10,
paddingTop: 10,
},
plantsSectionHeader: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginBottom: 10,
paddingHorizontal: 10,
},
plantsSectionTitle: {
fontSize: 20,
fontWeight: '700',
color: COLORS.textDark,
},
addPlantButton: {
flexDirection: 'row',
alignItems: 'center',
},
addPlantButtonText: {
fontSize: 14,
color: COLORS.primary,
marginLeft: 5,
fontWeight: '600',
},
plantsContainer: {
flex: 1,
},
plantListContent: {
paddingHorizontal: 10,
paddingBottom: 20,
},
noPlantsContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
padding: 20,
},
noPlantsText: {
fontSize: 16,
color: '#555',
textAlign: 'center',
},
plantCard: {
width: (width - 60) / 2,
backgroundColor: COLORS.cardBg,
borderRadius: 15,
marginBottom: 15,
overflow: 'hidden',
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
},
android: {
elevation: 3,
},
}),
},
plantImage: {
width: '100%',
height: 120,
resizeMode: 'cover',
},
plantPlaceholder: {
width: '100%',
height: 120,
backgroundColor: '#eee',
justifyContent: 'center',
alignItems: 'center',
},
plantDetails: {
padding: 10,
},
plantName: {
fontSize: 14,
fontWeight: '600',
color: COLORS.textDark,
textAlign: 'center',
},
});
// File: app\features\main\screens\SettingsScreen.tsx
const SettingsScreen = () => {
const { t, i18n } = useTranslation();
const [currentLang, setCurrentLang] = useState(i18n.language);
const handleLanguageChange = async (lang: string) => {
await i18n.changeLanguage(lang);
await storage.saveLanguage(lang);
setCurrentLang(lang);
};
return (
<View style={styles.container}>
<Text style={styles.header}>Settings</Text>
<Text style={styles.label}>Selected Language: {currentLang}</Text>
<View style={styles.buttons}>
<TouchableOpacity onPress={() => handleLanguageChange('en')} style={[styles.button, currentLang === 'en' && styles.selected]}>
<Text style={styles.buttonText}>English</Text>
</TouchableOpacity>
<TouchableOpacity onPress={() => handleLanguageChange('fr')} style={[styles.button, currentLang === 'fr' && styles.selected]}>
<Text style={styles.buttonText}>Français</Text>
</TouchableOpacity>
</View>
</View>
);
};
export default SettingsScreen;
const styles = StyleSheet.create({
container: {
flex:1,
backgroundColor:'#fff',
padding:20
},
header: {
fontSize:24,
fontWeight:'700',
marginBottom:20
},
label: {
fontSize:16,
marginBottom:20
},
buttons: {
flexDirection:'row'
},
button: {
padding:10,
borderRadius:8,
borderWidth:1,
borderColor:'#ccc',
marginRight:10
},
selected: {
backgroundColor:'#1EAE98',
borderColor:'#1EAE98'
},
buttonText: {
color:'#000'
}
});
// File: app\features\main\screens\SwipeScreen.tsx
const { width } = Dimensions.get('window');
const SwipeScreen: React.FC = () => {
const { data: plants, isLoading, isError, refetch } = useLikablePlants();
const { data: myPlants, isLoading: loadingMyPlants, isError: errorMyPlants, refetch: refetchMyPlants } = useMyPlants();
const [localPlants, setLocalPlants] = useState<PlantResponse[]>(plants || []);
const [modalVisible, setModalVisible] = useState(false);
const [pendingRightSwipePlant, setPendingRightSwipePlant] = useState<PlantResponse | null>(null);
React.useEffect(() => {
if (plants) {
setLocalPlants(plants);
}
}, [plants]);
const topCard = useMemo(() => {
return localPlants && localPlants.length > 0 ? localPlants[0] : null;
}, [localPlants]);
const removeTopCard = (plantId: number) => {
setLocalPlants((prev) => prev.filter((p) => p.plantId !== plantId));
};
const handleSwipeLeft = useCallback(async (plantId: number) => {
if (!myPlants) {
Alert.alert("Error", "Add some plants or cuttings if you want to start trading.");
return;
}
const swipeRequests: SwipeRequest[] = myPlants.map((userPlant) => ({
swiperPlantId: userPlant.plantId,
swipedPlantId: plantId,
isLike: false
}));
try {
await swipeService.sendSwipes(swipeRequests);
} catch {
Alert.alert("Error", "Failed to register swipe.");
}
removeTopCard(plantId);
}, [myPlants]);
const handleRightSwipeInitiation = useCallback((plantId: number) => {
if (!myPlants) {
Alert.alert("Error", "Add some plants or cuttings if you want to start trading.");
return;
}
const plantToLike = localPlants.find(p => p.plantId === plantId);
if (!plantToLike) return;
setPendingRightSwipePlant(plantToLike);
setModalVisible(true);
}, [localPlants]);
const handleRightSwipeConfirm = useCallback(async (selectedPlantIds: number[]) => {
if (!pendingRightSwipePlant || !myPlants) {
return;
}
const plantId = pendingRightSwipePlant.plantId;
const swipeRequests: SwipeRequest[] = myPlants.map((userPlant) => ({
swiperPlantId: userPlant.plantId,
swipedPlantId: plantId,
isLike: selectedPlantIds.includes(userPlant.plantId)
}));
try {
await swipeService.sendSwipes(swipeRequests);
} catch {
Alert.alert("Error", "Failed to send swipe requests.");
return;
}
removeTopCard(plantId);
setPendingRightSwipePlant(null);
setModalVisible(false);
}, [myPlants, pendingRightSwipePlant]);
const handleModalClose = () => {
setPendingRightSwipePlant(null);
setModalVisible(false);
};
const handlePassPress = () => {
if (topCard) {
handleSwipeLeft(topCard.plantId);
}
};
const handleLikePress = () => {
if (topCard) {
handleRightSwipeInitiation(topCard.plantId);
}
};
const handleFilterPress = () => {
Alert.alert("Filters", "Filter screen or modal would appear here.");
};
if (isLoading || loadingMyPlants) {
return (
<SafeAreaView style={styles.loadingContainer}>
<ActivityIndicator size="large" color="#1EAE98" />
<Text style={styles.loadingText}>Loading Plants...</Text>
</SafeAreaView>
);
}
if (isError || errorMyPlants) {
return (
<SafeAreaView style={styles.errorContainer}>
<Text style={styles.errorText}>Failed to load plants or your gallery.</Text>
<TouchableOpacity onPress={() => {refetch(); refetchMyPlants();}} style={styles.retryButton}>
<Text style={styles.retryButtonText}>Try Again</Text>
</TouchableOpacity>
</SafeAreaView>
);
}
return (
<SafeAreaView style={styles.container}>
<View style={styles.header}>
<Text style={styles.headerTitle}>Cuttr</Text>
<TouchableOpacity onPress={handleFilterPress} style={styles.headerFilterButton} accessible accessibilityLabel="Filter plants" accessibilityHint="Opens filter options">
<Ionicons name="options" size={24} color="#333" />
</TouchableOpacity>
</View>
<View style={styles.cardsContainer}>
{localPlants.map((plant, index) => {
const isTopCard = index === 0;
return (
<SwipeableCard
key={plant.plantId}
plant={plant}
onSwipeLeft={handleSwipeLeft}
onSwipeRight={handleRightSwipeInitiation}
/>
);
})}
{localPlants.length === 0 && (
<View style={styles.emptyState}>
<Text style={styles.emptyStateText}>No more plants to show.</Text>
<Text style={styles.emptyStateSubText}>Try adjusting your filters or come back later.</Text>
</View>
)}
</View>
{localPlants.length > 0 && (
<View style={styles.actionsContainer}>
<TouchableOpacity onPress={handlePassPress} style={[styles.actionButton, styles.passButton]} accessibilityRole="button" accessibilityLabel="Pass on this plant" accessibilityHint="Dislike and show next plant">
<MaterialIcons name="close" size={32} color="#fff" />
</TouchableOpacity>
<TouchableOpacity onPress={handleLikePress} style={[styles.actionButton, styles.likeButton]} accessibilityRole="button" accessibilityLabel="Like this plant" accessibilityHint="Show interest and match with this plant">
<MaterialIcons name="favorite" size={32} color="#fff" />
</TouchableOpacity>
</View>
)}
{myPlants && pendingRightSwipePlant && (
<SelectPlantsModal
visible={modalVisible}
onClose={handleModalClose}
onConfirm={handleRightSwipeConfirm}
/>
)}
</SafeAreaView>
);
};
export default SwipeScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor:'#f8f8f8',
alignItems:'center'
},
loadingContainer: {
flex:1,
justifyContent:'center',
alignItems:'center'
},
loadingText:{
marginTop:10,
fontSize:16,
color:'#333'
},
errorContainer: {
flex:1,
justifyContent:'center',
alignItems:'center',
padding:20
},
errorText:{
fontSize:18,
color:'#333',
marginBottom:20,
textAlign:'center'
},
retryButton:{
backgroundColor:'#1EAE98',
paddingVertical:12,
paddingHorizontal:20,
borderRadius:8
},
retryButtonText:{
color:'#fff',
fontSize:16,
fontWeight:'600'
},
header: {
width:'100%',
flexDirection:'row',
justifyContent:'space-between',
alignItems:'center',
paddingHorizontal:20,
paddingVertical:10,
borderBottomColor:'#ddd',
borderBottomWidth:1,
backgroundColor:'#fff'
},
headerTitle:{
fontSize:24,
fontWeight:'700',
color:'#333'
},
headerFilterButton:{
padding:8
},
cardsContainer:{
flex:1,
width:'100%',
justifyContent:'center',
alignItems:'center',
paddingTop:20
},
actionsContainer:{
flexDirection:'row',
justifyContent:'space-evenly',
alignItems:'center',
width:'100%',
paddingVertical:20,
backgroundColor:'#fff',
borderTopWidth:1,
borderTopColor:'#ddd'
},
actionButton:{
width:60,
height:60,
borderRadius:30,
justifyContent:'center',
alignItems:'center'
},
passButton:{
backgroundColor:'#FF6B6B'
},
likeButton:{
backgroundColor:'#1EAE98'
},
emptyState:{
alignItems:'center',
padding:20
},
emptyStateText:{
fontSize:20,
fontWeight:'700',
color:'#333',
marginBottom:8
},
emptyStateSubText:{
fontSize:16,
color:'#555',
textAlign:'center'
}
});
// File: app\features\main\store\matchesSlice.ts

// File: app\features\main\store\plantsSlice.ts

// File: app\features\main\store\userPreferencesSlice.ts
interface UserPreferencesState {
data: UserPreferencesResponse | null;
status: 'idle' | 'loading' | 'error';
error: string | null;
}
const initialState: UserPreferencesState = {
data: null,
status: 'idle',
error: null,
};
export const fetchUserPreferencesThunk = createAsyncThunk<UserPreferencesResponse, void, { rejectValue: string }>(
'userPreferences/fetch',
async (_, { rejectWithValue }) => {
try {
const preferences = await userPreferencesService.getPreferences();
return preferences;
} catch (error: any) {
return rejectWithValue(error.response?.data?.message || 'Failed to fetch user preferences');
}
}
);
export const updateUserPreferencesThunk = createAsyncThunk<UserPreferencesResponse, UserPreferencesRequest, { rejectValue: string }>(
'userPreferences/update',
async (data, { rejectWithValue }) => {
try {
const updated = await userPreferencesService.updatePreferences(data);
return updated;
} catch (error: any) {
return rejectWithValue(error.response?.data?.message || 'Failed to update user preferences');
}
}
);
export const userPreferencesSlice = createSlice({
name: 'userPreferences',
initialState,
reducers: {
clearUserPreferences(state) {
state.data = null;
state.status = 'idle';
state.error = null;
}
},
extraReducers: (builder) => {
builder
.addCase(fetchUserPreferencesThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(fetchUserPreferencesThunk.fulfilled, (state, action: PayloadAction<UserPreferencesResponse>) => {
state.status = 'idle';
state.data = action.payload;
})
.addCase(fetchUserPreferencesThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload as string;
})
.addCase(updateUserPreferencesThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(updateUserPreferencesThunk.fulfilled, (state, action: PayloadAction<UserPreferencesResponse>) => {
state.status = 'idle';
state.data = action.payload;
})
.addCase(updateUserPreferencesThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload as string;
});
}
});
export const { clearUserPreferences } = userPreferencesSlice.actions;
export const selectUserPreferences = (state: RootState) => state.userPreferences.data;
export const selectUserPreferencesStatus = (state: RootState) => state.userPreferences.status;
export const selectUserPreferencesError = (state: RootState) => state.userPreferences.error;
export default userPreferencesSlice.reducer;
// File: app\features\main\store\userSlice.ts
export const fetchUserProfile = createAsyncThunk<
UserResponse,
number,
{ rejectValue: string }
>(
'user/fetchUserProfile',
async (userId, { rejectWithValue }) => {
try {
const response = await api.get<UserResponse>(`/users/${userId}`);
return response.data;
} catch (error: any) {
return rejectWithValue(error.response?.data?.message || 'Failed to fetch user profile');
}
}
);
interface UserState {
profile: UserResponse | null;
status: 'idle' | 'loading' | 'error';
error: string | null;
}
const initialState: UserState = {
profile: null,
status: 'idle',
error: null
};
export const userSlice = createSlice({
name: 'user',
initialState,
reducers: {
clearUserProfile(state) {
state.profile = null;
state.status = 'idle';
state.error = null;
}
},
extraReducers: (builder) => {
builder
.addCase(fetchUserProfile.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(fetchUserProfile.fulfilled, (state, action: PayloadAction<UserResponse>) => {
state.status = 'idle';
state.profile = action.payload;
})
.addCase(fetchUserProfile.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload as string;
});
}
});
export const { clearUserProfile } = userSlice.actions;
// File: app\features\main\types\mainTypes.ts

// File: app\features\onboarding\screens\OnboardingLocationScreen.tsx
const { width, height } = Dimensions.get('window');
const OnboardingLocationScreen: React.FC = () => {
const queryClient = useQueryClient();
const [region, setRegion] = useState({
latitude: 37.78825,
longitude: -122.4324,
latitudeDelta: 0.0922,
longitudeDelta: 0.0421,
});
const [selectedLocation, setSelectedLocation] = useState<{
latitude: number;
longitude: number;
} | null>(null);
const handleMapPress = (e: MapPressEvent) => {
const { latitude, longitude } = e.nativeEvent.coordinate;
setSelectedLocation({ latitude, longitude });
setRegion((prev) => ({
...prev,
latitude,
longitude,
}));
};
const handleConfirmLocation = async () => {
if (!selectedLocation) {
Alert.alert('No location selected', 'Please tap on the map to select your approximate location');
return;
}
try {
await userService.updateLocation({
latitude: selectedLocation.latitude,
longitude: selectedLocation.longitude,
});
queryClient.invalidateQueries('userProfile');
} catch (error) {
Alert.alert('Error', 'Failed to update location. Please try again.');
}
};
return (
<View style={styles.container}>
<Text style={styles.title}>Set Your Location</Text>
<Text style={styles.subtitle}>
Tap on the map to drop a pin at your approximate location.
</Text>
<MapView
style={styles.map}
initialRegion={region}
onPress={handleMapPress}
>
{selectedLocation && (
<Marker coordinate={selectedLocation} />
)}
</MapView>
<TouchableOpacity onPress={handleConfirmLocation} style={styles.confirmButton}>
<Text style={styles.confirmButtonText}>Confirm & Continue</Text>
</TouchableOpacity>
</View>
);
};
export default OnboardingLocationScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
justifyContent: 'flex-start',
paddingTop: 50,
backgroundColor: '#fff',
},
title: {
fontSize: 20,
fontWeight: '700',
marginHorizontal: 20,
marginBottom: 8,
},
subtitle: {
fontSize: 14,
marginHorizontal: 20,
marginBottom: 16,
color: '#555',
},
map: {
width: width,
height: height * 0.55,
},
confirmButton: {
backgroundColor: '#1EAE98',
padding: 16,
margin: 20,
borderRadius: 8,
},
confirmButtonText: {
color: '#fff',
fontWeight: '600',
textAlign: 'center',
},
});
// File: app\features\onboarding\screens\OnboardingWelcomeScreen.tsx
const OnboardingWelcomeScreen: React.FC = () => {
const navigation = useNavigation();
const handleNextPress = () => {
navigation.navigate('OnboardingLocation' as never);
};
return (
<View style={styles.container}>
<Text style={styles.title}>Welcome to Cuttr!</Text>
<Text style={styles.subtitle}>
Here’s a quick intro to how you can swap plants safely and easily.
</Text>
{}
<TouchableOpacity onPress={handleNextPress} style={styles.button}>
<Text style={styles.buttonText}>Next: Choose Location</Text>
</TouchableOpacity>
</View>
);
};
export default OnboardingWelcomeScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
padding: 20,
justifyContent: 'center',
},
title: {
fontSize: 28,
fontWeight: '700',
marginBottom: 10,
},
subtitle: {
fontSize: 16,
marginBottom: 40,
},
button: {
backgroundColor: '#1EAE98',
padding: 14,
borderRadius: 8,
},
buttonText: {
color: '#fff',
fontWeight: '600',
textAlign: 'center',
},
});
// File: app\hooks\useAuthToken.ts
export const useAuthToken = () => {
const [initializing, setInitializing] = useState(true);
const [accessToken, setAccessToken] = useState<string | null>(null);
const [refreshToken, setRefreshToken] = useState<string | null>(null);
useEffect(() => {
const loadTokens = async () => {
const at = await storage.getAccessToken();
const rt = await storage.getRefreshToken();
setAccessToken(at);
setRefreshToken(rt);
setInitializing(false);
};
loadTokens();
}, []);
return { initializing, accessToken, refreshToken };
};
// File: app\hooks\useAxiosErrorHandler.ts

// File: app\hooks\useNetworkStatus.ts

// File: app\i18n\index.ts
export async function initI18n() {
await i18n
.use(initReactI18next)
.init({
fallbackLng: 'en',
lng: Localization.locale,
resources: {
en: { translation: en },
fr: { translation: fr },
},
interpolation: {
escapeValue: false,
},
});
return i18n;
}
// File: app\i18n\locales\en.json
{
"welcome_back": "Welcome Back",
"create_account": "Create Account",
"login": "Login",
"register": "Register",
"email": "Email",
"password": "Password",
"name": "Name",
"no_account_register": "Don’t have an account? Register",
"have_account_login": "Already have an account? Login",
"profile_title": "My Profile",
"profile_loading_message": "Loading your profile...",
"profile_error_message": "Failed to load your profile.",
"profile_retry_button": "Try Again",
"profile_name_label": "Name",
"profile_bio_label": "Bio",
"profile_location_label": "Location",
"profile_no_location": "No location set",
"profile_edit_button": "Edit Profile",
"profile_change_location_button": "Change Location",
"profile_add_plant_button": "Add Plant",
"profile_my_plants_section": "My Plants",
"profile_no_plants_message": "You have no plants yet. Add one to get started!",
"edit_profile_title": "Edit Profile",
"edit_profile_name_label": "Name",
"edit_profile_bio_label": "Bio",
"edit_profile_confirm_button": "Confirm",
"edit_profile_cancel_button": "Cancel",
"edit_profile_error_message": "Failed to update profile.",
"change_location_title": "Change Location",
"change_location_instructions": "Tap on the map to select your location.",
"change_location_confirm_button": "Confirm",
"change_location_cancel_button": "Cancel",
"change_location_error_message": "Failed to update location.",
"add_plant_title": "Add a New Plant",
"add_plant_species_name_label": "Species Name",
"add_plant_description_label": "Description",
"add_plant_stage_label": "Stage",
"add_plant_category_label": "Category",
"add_plant_watering_label": "Watering Need",
"add_plant_light_label": "Light Requirement",
"add_plant_size_label": "Size",
"add_plant_indoor_outdoor_label": "Indoor/Outdoor",
"add_plant_propagation_ease_label": "Propagation Ease",
"add_plant_pet_friendly_label": "Pet Friendly",
"add_plant_extras_label": "Extras",
"add_plant_select_image_button": "Select Image",
"add_plant_save_button": "Save",
"add_plant_cancel_button": "Cancel",
"add_plant_error_message": "Failed to add plant.",
"add_plant_no_image_selected": "No image selected."
}
// File: app\i18n\locales\fr.json
{
"welcome_back": "Bon Retour",
"create_account": "Créer un Compte",
"login": "Connexion",
"register": "S'inscrire",
"email": "E-mail",
"password": "Mot de Passe",
"name": "Nom",
"no_account_register": "Vous n'avez pas de compte ? Inscrivez-vous",
"have_account_login": "Vous avez déjà un compte ? Connectez-vous",
"profile_title": "Mon Profil",
"profile_loading_message": "Chargement de votre profil...",
"profile_error_message": "Impossible de charger votre profil.",
"profile_retry_button": "Réessayer",
"profile_name_label": "Nom",
"profile_bio_label": "Bio",
"profile_location_label": "Localisation",
"profile_no_location": "Aucune localisation définie",
"profile_edit_button": "Modifier le Profil",
"profile_change_location_button": "Changer la Localisation",
"profile_add_plant_button": "Ajouter une Plante",
"profile_my_plants_section": "Mes Plantes",
"profile_no_plants_message": "Vous n'avez pas encore de plantes. Ajoutez-en une pour commencer !",
"edit_profile_title": "Modifier le Profil",
"edit_profile_name_label": "Nom",
"edit_profile_bio_label": "Bio",
"edit_profile_confirm_button": "Confirmer",
"edit_profile_cancel_button": "Annuler",
"edit_profile_error_message": "Impossible de mettre à jour le profil.",
"change_location_title": "Changer de Localisation",
"change_location_instructions": "Appuyez sur la carte pour sélectionner votre localisation.",
"change_location_confirm_button": "Confirmer",
"change_location_cancel_button": "Annuler",
"change_location_error_message": "Impossible de mettre à jour la localisation.",
"add_plant_title": "Ajouter une Nouvelle Plante",
"add_plant_species_name_label": "Nom de l'Espèce",
"add_plant_description_label": "Description",
"add_plant_stage_label": "Stade",
"add_plant_category_label": "Catégorie",
"add_plant_watering_label": "Besoins en Arrosage",
"add_plant_light_label": "Besoin en Lumière",
"add_plant_size_label": "Taille",
"add_plant_indoor_outdoor_label": "Intérieur/Extérieur",
"add_plant_propagation_ease_label": "Facilité de Propagation",
"add_plant_pet_friendly_label": "Adapté aux Animaux",
"add_plant_extras_label": "Extras",
"add_plant_select_image_button": "Sélectionner une Image",
"add_plant_save_button": "Enregistrer",
"add_plant_cancel_button": "Annuler",
"add_plant_error_message": "Impossible d'ajouter la plante.",
"add_plant_no_image_selected": "Aucune image sélectionnée."
}
// File: app\navigation\AppNavigator.tsx
const AppNavigator = () => {
const { accessToken } = useSelector((state: RootState) => state.auth);
const { data: userProfile, isLoading: userProfileLoading } = useUserProfile();
if (!accessToken) {
return <AuthNavigator />;
}
if (userProfileLoading) {
return (
<View style={styles.loadingContainer}>
<ActivityIndicator size="large" color="#1EAE98" />
</View>
);
}
if (!userProfile?.locationLatitude || !userProfile?.locationLongitude) {
return <OnboardingNavigator />;
}
return <MainNavigator />;
};
export default AppNavigator;
const styles = StyleSheet.create({
loadingContainer: {
flex: 1,
alignItems: 'center',
justifyContent: 'center',
},
});
// File: app\navigation\AuthNavigator.tsx
const Stack = createNativeStackNavigator();
const AuthNavigator = () => {
return (
<Stack.Navigator>
<Stack.Screen name="Login" component={LoginScreen} options={{ headerShown: false }} />
<Stack.Screen name="Register" component={RegisterScreen} options={{ headerShown: false }} />
</Stack.Navigator>
);
};
export default AuthNavigator;
// File: app\navigation\MainNavigator.tsx
const Tab = createBottomTabNavigator();
const icons: Record<string, number> = {
Swipe: require('../../assets/images/swiping.png'),
Profile: require('../../assets/images/profile.png'),
Settings: require('../../assets/images/settings.png'),
};
const MainNavigator = () => {
return (
<Tab.Navigator
screenOptions={({ route }) => ({
headerShown: false,
tabBarIcon: ({ focused, color, size }) => {
const iconSource = icons[route.name];
return (
<Image
source={iconSource}
style={[
styles.icon,
{ tintColor: focused ? '#673ab7' : '#222' },
{ width: size, height: size },
]}
/>
);
},
tabBarActiveTintColor: '#673ab7',
tabBarInactiveTintColor: 'gray',
})}
>
<Tab.Screen name="Swipe" component={SwipeScreen}/>
<Tab.Screen name="Profile" component={MyProfileScreen}/>
<Tab.Screen name="Settings" component={SettingsScreen}/>
</Tab.Navigator>
);
};
export default MainNavigator;
const styles = StyleSheet.create({
icon: {
width: 24,
height: 24,
},
});
// File: app\navigation\NavigationTypes.ts

// File: app\navigation\OnboardingNavigator.tsx
const Stack = createNativeStackNavigator();
const OnboardingNavigator = () => {
return (
<Stack.Navigator screenOptions={{ headerShown: false }}>
{}
<Stack.Screen name="OnboardingWelcome" component={OnboardingWelcomeScreen} />
{}
<Stack.Screen name="OnboardingLocation" component={OnboardingLocationScreen} />
</Stack.Navigator>
);
};
export default OnboardingNavigator;
// File: app\store\hooks.ts
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
// File: app\store\index.ts
export const store = configureStore({
reducer: {
auth: authSlice.reducer,
user: userSlice.reducer,
userPreferences: userPreferencesSlice.reducer,
globalError: globalErrorSlice.reducer,
},
middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(loggingMiddleware),
});
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
// File: app\store\rootReducer.ts

// File: app\store\middlewares\loggingMiddleware.ts
export const loggingMiddleware: Middleware = (storeAPI) => (next) => (action: any) => {
if (__DEV__) {
log.debug("Redux Action Dispatched", { type: action.type, payload: action.payload });
}
const result = next(action);
return result;
};
// File: app\store\slices\globalErrorSlice.ts
interface GlobalErrorState {
message: string | null;
}
const initialState: GlobalErrorState = {
message: null,
};
export const globalErrorSlice = createSlice({
name: 'globalError',
initialState,
reducers: {
setGlobalError(state, action: PayloadAction<string>) {
state.message = action.payload;
},
clearGlobalError(state) {
state.message = null;
},
},
});
export const { setGlobalError, clearGlobalError } = globalErrorSlice.actions;
// File: app\theme\colors.ts

// File: app\theme\index.ts

// File: app\theme\spacing.ts

// File: app\theme\typography.ts

// File: app\types\apiTypes.ts
export interface RefreshTokenRequest {
refreshToken: string;
}
export interface MessageRequest {
matchId: number;
messageText: string;
}
export interface PlantCreateRequest {
plantDetails: PlantRequest;
image: File;
}
export interface PlantRequest {
speciesName: string;
description: string;
plantStage: PlantStage;
plantCategory: PlantCategory;
wateringNeed: WateringNeed;
lightRequirement: LightRequirement;
size?: Size;
indoorOutdoor?: IndoorOutdoor;
propagationEase?: PropagationEase;
petFriendly?: PetFriendly;
extras?: Extras[];
}
export interface PlantUpdateRequest {
speciesName: string;
careRequirements: string;
description: string;
category: string;
}
export interface ReportRequest {
reportedUserId: number;
reason: string;
comments: string;
}
export interface SwipeRequest {
swiperPlantId: number;
swipedPlantId: number;
isLike: boolean;
}
export interface UpdateLocationRequest {
latitude: number;
longitude: number;
}
export interface UserLoginRequest {
email: string;
password: string;
}
export interface UserPreferencesRequest {
searchRadius: number;
preferedPlantStage: PlantStage[];
preferedPlantCategory: PlantCategory[];
preferedWateringNeed: WateringNeed[];
preferedLightRequirement: LightRequirement[];
preferedSize: Size[];
preferedIndoorOutdoor: IndoorOutdoor[];
preferedPropagationEase: PropagationEase[];
preferedPetFriendly: PetFriendly[];
preferedExtras: Extras[];
}
export interface UserProfileImageUpdateRequest {
image: File;
}
export interface UserRegistrationRequest {
email: string;
password: string;
name: string;
}
export interface UserUpdateRequest {
name: string;
bio: string;
}
export interface AuthTokenResponse {
accessToken: string;
refreshToken: string;
tokenType: string;
expiresIn: number;
}
export interface MatchResponse {
matchId: number;
plant1: PlantResponse;
plant2: PlantResponse;
user1: UserResponse;
user2: UserResponse;
}
export interface MessageResponse {
messageId: number;
matchId: number;
senderUserId: number;
messageText: string;
sentAt: Date;
isRead: boolean;
}
export interface PlantResponse {
plantId: number;
userId: number;
speciesName: string;
description: string;
plantStage: PlantStage;
plantCategory: PlantCategory;
wateringNeed: WateringNeed;
lightRequirement: LightRequirement;
size?: Size;
indoorOutdoor?: IndoorOutdoor;
propagationEase?: PropagationEase;
petFriendly?: PetFriendly;
extras?: Extras[];
imageUrl: string;
}
export interface ReportResponse {
reportId: number;
reporterUserId: number;
reportedUserId: number;
reason: string;
comments: string;
createdAt: Date;
isResolved: boolean;
}
export interface SwipeResponse {
isMatch: boolean;
match: MatchResponse;
}
export interface UserLoginResponse {
userId: number;
email: string;
tokens: AuthTokenResponse;
}
export interface UserPreferencesResponse {
userId: number;
searchRadius: number;
preferedPlantStage: PlantStage[];
preferedPlantCategory: PlantCategory[];
preferedWateringNeed: WateringNeed[];
preferedLightRequirement: LightRequirement[];
preferedSize: Size[];
preferedIndoorOutdoor: IndoorOutdoor[];
preferedPropagationEase: PropagationEase[];
preferedPetFriendly: PetFriendly[];
preferedExtras: Extras[];
}
export interface UserResponse {
userId: number;
email: string;
name: string;
profilePictureUrl: string;
bio: string;
locationLatitude?: number;
locationLongitude?: number;
}
// File: app\types\enums.ts
export enum PlantStage {
Cutting = "Cutting",
GrownPlantTree = "GrownPlantTree"
}
export enum PlantCategory {
Succulent = "Succulent",
Cactus = "Cactus",
Fern = "Fern",
Orchid = "Orchid",
Herb = "Herb",
Palm = "Palm",
LeafyHouseplant = "LeafyHouseplant",
FloweringHouseplant = "FloweringHouseplant",
Other = "Other"
}
export enum WateringNeed {
VeryLowWater = "VeryLowWater",
LowWater = "LowWater",
ModerateWater = "ModerateWater",
HighWater = "HighWater",
VeryHighWater = "VeryHighWater"
}
export enum LightRequirement {
FullSun = "FullSun",
PartialShade = "PartialShade",
Shade = "Shade"
}
export enum Size {
SmallSize = "SmallSize",
MediumSize = "MediumSize",
LargeSize = "LargeSize"
}
export enum IndoorOutdoor {
Indoor = "Indoor",
Outdoor = "Outdoor",
IndoorAndOutdoor = "IndoorAndOutdoor"
}
export enum PropagationEase {
EasyPropagation = "EasyPropagation",
ModeratePropagation = "ModeratePropagation",
DifficultPropagation = "DifficultPropagation"
}
export enum PetFriendly {
PetFriendly = "PetFriendly",
NotPetFriendly = "NotPetFriendly",
}
export enum Extras {
Fragrant = "Fragrant",
Edible = "Edible",
Medicinal = "Medicinal",
AirPurifying = "AirPurifying",
Decorative = "Decorative",
Flowering = "Flowering",
TropicalVibe = "TropicalVibe",
FoliageHeavy = "FoliageHeavy",
DroughtTolerant = "DroughtTolerant",
HumidityLoving = "HumidityLoving",
LowMaintenance = "LowMaintenance",
WinterHardy = "WinterHardy",
BeginnerFriendly = "BeginnerFriendly",
Fruiting = "Fruiting",
PollinatorFriendly = "PollinatorFriendly",
FastGrowing = "FastGrowing",
VariegatedFoliage = "VariegatedFoliage",
Climbing = "Climbing",
GroundCover = "GroundCover",
Rare = "Rare"
}
// File: app\types\global.ts

// File: app\utils\formatting.ts

// File: app\utils\index.ts

// File: app\utils\logger.ts
const defaultConfig = {
severity: __DEV__ ? 'debug' : 'warn',
};
export const log = logger.createLogger(defaultConfig);
// File: app\utils\storage.ts
const ACCESS_TOKEN_KEY = "ACCESS_TOKEN_KEY";
const REFRESH_TOKEN_KEY = "REFRESH_TOKEN_KEY";
const LANGUAGE_KEY = "LANGUAGE_KEY";
export const storage = {
saveTokens: async (accessToken: string, refreshToken: string) => {
await SecureStore.setItemAsync(ACCESS_TOKEN_KEY, accessToken);
await SecureStore.setItemAsync(REFRESH_TOKEN_KEY, refreshToken);
},
getAccessToken: async () => SecureStore.getItemAsync(ACCESS_TOKEN_KEY),
getRefreshToken: async () => SecureStore.getItemAsync(REFRESH_TOKEN_KEY),
clearTokens: async () => {
await SecureStore.deleteItemAsync(ACCESS_TOKEN_KEY);
await SecureStore.deleteItemAsync(REFRESH_TOKEN_KEY);
},
saveLanguage: async (language: string) => {
await SecureStore.setItemAsync(LANGUAGE_KEY, language);
},
getLanguage: async () => SecureStore.getItemAsync(LANGUAGE_KEY),
};
// File: app\utils\validation.ts

// File: scripts\reset-project.js
#!/usr/bin/env node
const fs = require("fs");
const path = require("path");
const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const newDir = "app-example";
const newAppDir = "app";
const newDirPath = path.join(root, newDir);
const indexContent = `import { Text, View } from "react-native";
export default function Index() {
return (
<View
style={{
flex: 1,
justifyContent: "center",
alignItems: "center",
}}
>
<Text>Edit app/index.tsx to edit this screen.</Text>
</View>
);
}
`;
const layoutContent = `import { Stack } from "expo-router";
export default function RootLayout() {
return <Stack />;
}
`;
const moveDirectories = async () => {
try {
await fs.promises.mkdir(newDirPath, { recursive: true });
console.log(`📁 /${newDir} directory created.`);
for (const dir of oldDirs) {
const oldDirPath = path.join(root, dir);
const newDirPath = path.join(root, newDir, dir);
if (fs.existsSync(oldDirPath)) {
await fs.promises.rename(oldDirPath, newDirPath);
console.log(`➡️ /${dir} moved to /${newDir}/${dir}.`);
} else {
console.log(`➡️ /${dir} does not exist, skipping.`);
}
}
const newAppDirPath = path.join(root, newAppDir);
await fs.promises.mkdir(newAppDirPath, { recursive: true });
console.log("\n📁 New /app directory created.");
const indexPath = path.join(newAppDirPath, "index.tsx");
await fs.promises.writeFile(indexPath, indexContent);
console.log("📄 app/index.tsx created.");
const layoutPath = path.join(newAppDirPath, "_layout.tsx");
await fs.promises.writeFile(layoutPath, layoutContent);
console.log("📄 app/_layout.tsx created.");
console.log("\n✅ Project reset complete. Next steps:");
console.log(
"1. Run `npx expo start` to start a development server.\n2. Edit app/index.tsx to edit the main screen.\n3. Delete the /app-example directory when you're done referencing it."
);
} catch (error) {
console.error(`Error during script execution: ${error}`);
}
};
moveDirectories();