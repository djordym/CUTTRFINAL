
// File: app.json
{
"expo": {
"name": "MyCuttrApp",
"slug": "MyCuttrApp",
"version": "1.0.0",
"orientation": "portrait",
"icon": "./assets/icon.png",
"userInterfaceStyle": "light",
"newArchEnabled": true,
"splash": {
"image": "./assets/splash-icon.png",
"resizeMode": "contain",
"backgroundColor": "#ffffff"
},
"ios": {
"supportsTablet": true
},
"android": {
"adaptiveIcon": {
"foregroundImage": "./assets/adaptive-icon.png",
"backgroundColor": "#ffffff"
}
},
"web": {
"favicon": "./assets/favicon.png"
}
}
}
// File: index.ts
registerRootComponent(App);
// File: package.json
{
"name": "mycuttrapp",
"license": "0BSD",
"version": "1.0.0",
"main": "index.ts",
"scripts": {
"start": "expo start",
"android": "expo start --android",
"ios": "expo start --ios",
"web": "expo start --web"
},
"dependencies": {
"@react-navigation/bottom-tabs": "^7.2.0",
"@react-navigation/native": "^7.0.14",
"@react-navigation/native-stack": "^7.2.0",
"@react-navigation/stack": "^7.1.1",
"@reduxjs/toolkit": "^2.5.0",
"axios": "^1.7.9",
"expo": "~52.0.20",
"expo-secure-store": "^14.0.0",
"expo-status-bar": "~2.0.0",
"i18next": "^24.1.2",
"react": "18.3.1",
"react-i18next": "^15.2.0",
"react-native": "0.76.5",
"react-native-localize": "^3.3.0",
"react-query": "^3.39.3",
"react-redux": "^9.2.0"
},
"devDependencies": {
"@babel/core": "^7.25.2",
"@types/react": "~18.3.12",
"@types/react-redux": "^7.1.34",
"typescript": "^5.3.3"
},
"private": true
}
// File: tsconfig.json
{
"extends": "expo/tsconfig.base",
"compilerOptions": {
"strict": true
}
}
// File: src\App.tsx
const queryClient = new QueryClient();
const App = () => {
const [i18nInstance, setI18nInstance] = useState<any>(null);
useEffect(() => {
const setupI18n = async () => {
const i18n = await initI18n();
setI18nInstance(i18n);
};
setupI18n();
}, []);
if (!i18nInstance) {
return (
<View style={{flex:1,justifyContent:'center',alignItems:'center'}}>
<ActivityIndicator size="large" />
</View>
);
}
return (
<Provider store={store}>
<QueryClientProvider client={queryClient}>
<I18nextProvider i18n={i18nInstance}>
<AppNavigator />
</I18nextProvider>
</QueryClientProvider>
</Provider>
);
};
export default App;
// File: src\api\authService.ts
UserLoginRequest,
UserLoginResponse,
RefreshTokenRequest,
AuthTokenResponse,
UserRegistrationRequest
} from '../types/apiTypes';
export const authService = {
login: async (data: UserLoginRequest): Promise<UserLoginResponse> => {
const response = await api.post<UserLoginResponse>('/auth/login', data);
return response.data;
},
refreshToken: async (data: RefreshTokenRequest): Promise<AuthTokenResponse> => {
const response = await api.post<AuthTokenResponse>('/auth/refresh', data);
return response.data;
},
register: async (data: UserRegistrationRequest): Promise<UserLoginResponse> => {
const response = await api.post<UserLoginResponse>('/users/register', data);
return response.data;
},
logout: async (): Promise<void> => {
await api.post('/api/auth/logout');
},
};
// File: src\api\axiosConfig.ts
const api = axios.create({
baseURL: 'YOUR_BASE_URL',
timeout: 10000,
});
api.interceptors.request.use(
async (config) => {
const state = store.getState();
const token = state.auth.accessToken;
if (token && config.headers) {
config.headers.Authorization = `Bearer ${token}`;
}
return config;
},
(error) => {
return Promise.reject(error);
}
);
let isRefreshing = false;
let pendingRequests: Array<(token: string) => void> = [];
api.interceptors.response.use(
response => response,
async (error) => {
const originalRequest = error.config;
if (error.response?.status === 401 && !originalRequest._retry) {
if (!isRefreshing) {
isRefreshing = true;
originalRequest._retry = true;
try {
const { payload: newTokens } = await store.dispatch(refreshTokenThunk());
isRefreshing = false;
pendingRequests.forEach(cb => cb(newTokens?.AccessToken || ''));
pendingRequests = [];
return api(originalRequest);
} catch (refreshError) {
isRefreshing = false;
pendingRequests = [];
return Promise.reject(refreshError);
}
}
return new Promise((resolve) => {
pendingRequests.push((token: string) => {
originalRequest.headers.Authorization = 'Bearer ' + token;
resolve(api(originalRequest));
});
});
}
return Promise.reject(error);
}
);
export default api;
// File: src\api\matchService.ts
export const matchService = {
getMyMatches: async (): Promise<MatchResponse[]> => {
const response = await api.get<MatchResponse[]>('/matches/me');
return response.data;
},
getMatchById: async (matchId: number): Promise<MatchResponse> => {
const response = await api.get<MatchResponse>(`/matches/${matchId}`);
return response.data;
}
};
// File: src\api\messageService.ts
export const messageService = {
sendMessage: async (data: MessageRequest): Promise<MessageResponse> => {
const response = await api.post<MessageResponse>('/messages/me', data);
return response.data;
},
getMessagesForMatch: async (matchId: number): Promise<MessageResponse[]> => {
const response = await api.get<MessageResponse[]>(`/matches/${matchId}/messages`);
return response.data;
}
};
// File: src\api\plantService.ts
export const plantService = {
addMyPlant: async (data: PlantCreateRequest): Promise<PlantResponse> => {
const formData = new FormData();
formData.append('Image', data.Image);
formData.append('SpeciesName', data.PlantDetails.SpeciesName);
formData.append('Description', data.PlantDetails.Description);
formData.append('PlantStage', data.PlantDetails.PlantStage);
formData.append('PlantCategory', data.PlantDetails.PlantCategory);
formData.append('WateringNeed', data.PlantDetails.WateringNeed);
formData.append('LightRequirement', data.PlantDetails.LightRequirement);
if (data.PlantDetails.Size) formData.append('Size', data.PlantDetails.Size);
if (data.PlantDetails.IndoorOutdoor) formData.append('IndoorOutdoor', data.PlantDetails.IndoorOutdoor);
if (data.PlantDetails.PropagationEase) formData.append('PropagationEase', data.PlantDetails.PropagationEase);
if (data.PlantDetails.PetFriendly) formData.append('PetFriendly', data.PlantDetails.PetFriendly);
if (data.PlantDetails.Extras) {
data.PlantDetails.Extras.forEach((extra) => formData.append('Extras', extra));
}
const response = await api.post<PlantResponse>('/plants/me', formData, {
headers: { 'Content-Type': 'multipart/form-data' }
});
return response.data;
},
getPlantById: async (plantId: number): Promise<PlantResponse> => {
const response = await api.get<PlantResponse>(`/plants/${plantId}`);
return response.data;
},
updateMyPlant: async (plantId: number, data: PlantRequest): Promise<PlantResponse> => {
const response = await api.put<PlantResponse>(`/plants/me/${plantId}`, data);
return response.data;
},
deleteMyPlant: async (plantId: number): Promise<void> => {
await api.delete(`/plants/me/${plantId}`);
},
getUserPlants: async (userId: number): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>(`/users/${userId}/plants`);
return response.data;
},
getMyPlants: async (): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>('/users/me/plants');
return response.data;
}
};
// File: src\api\reportService.ts
export const reportService = {
createReport: async (data: ReportRequest): Promise<ReportResponse> => {
const response = await api.post<ReportResponse>('/reports', data);
return response.data;
}
};
// File: src\api\swipeService.ts
export const swipeService = {
sendSwipes: async (swipes: SwipeRequest[]): Promise<SwipeResponse> => {
const response = await api.post<SwipeResponse>('/swipes/me', swipes);
return response.data;
},
getLikablePlants: async (): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>('/swipes/me/likable-plants');
return response.data;
}
};
// File: src\api\userPreferencesService.ts
export const userPreferencesService = {
getPreferences: async (): Promise<UserPreferencesResponse> => {
const response = await api.get<UserPreferencesResponse>('/userpreferences');
return response.data;
},
updatePreferences: async (data: UserPreferencesRequest): Promise<UserPreferencesResponse> => {
const response = await api.post<UserPreferencesResponse>('/userpreferences', data);
return response.data;
}
};
// File: src\api\userService.ts
export const userService = {
register: async (data: { Email: string; Password: string; Name: string }): Promise<UserResponse> => {
const response = await api.post<UserResponse>('/users/register', data);
return response.data;
},
getUser: async (userId: number): Promise<UserResponse> => {
const response = await api.get<UserResponse>(`/users/${userId}`);
return response.data;
},
updateMe: async (data: UserUpdateRequest): Promise<UserResponse> => {
const response = await api.put<UserResponse>('/users/me', data);
return response.data;
},
deleteMe: async (): Promise<void> => {
await api.delete('/users/me');
},
updateProfilePicture: async (data: UserProfileImageUpdateRequest): Promise<UserResponse> => {
const formData = new FormData();
formData.append('Image', data.Image);
const response = await api.put<UserResponse>('/users/me/profile-picture', formData, {
headers: { 'Content-Type': 'multipart/form-data' }
});
return response.data;
},
updateLocation: async (data: UpdateLocationRequest): Promise<void> => {
await api.put('/users/me/location', data);
}
};
// File: src\components\index.ts

// File: src\components\common\BrandedButton.tsx
interface Props {
title: string;
onPress: () => void;
disabled?: boolean;
}
const BrandedButton: React.FC<Props> = ({ title, onPress, disabled }) => {
return (
<TouchableOpacity onPress={onPress} style={[styles.button, disabled && {opacity:0.5}]} disabled={disabled}>
<Text style={styles.buttonText}>{title}</Text>
</TouchableOpacity>
);
};
export default BrandedButton;
const styles = StyleSheet.create({
button: {
backgroundColor: '#1EAE98',
padding: 16,
borderRadius: 8,
alignItems:'center',
marginVertical:10
},
buttonText: {
color:'#fff',
fontSize:16,
fontWeight:'600'
}
});
// File: src\components\common\TextInputField.tsx
interface Props {
value: string;
onChangeText: (text: string) => void;
placeholder?: string;
secureTextEntry?: boolean;
}
const TextInputField: React.FC<Props> = ({ value, onChangeText, placeholder, secureTextEntry }) => {
return (
<View style={styles.container}>
<TextInput
style={styles.input}
value={value}
onChangeText={onChangeText}
placeholder={placeholder}
secureTextEntry={secureTextEntry}
placeholderTextColor="#999"
/>
</View>
);
};
export default TextInputField;
const styles = StyleSheet.create({
container: {
marginVertical: 10,
borderWidth:1,
borderColor:'#ccc',
borderRadius:8,
},
input: {
padding:12,
fontSize:16,
}
});
// File: src\components\feedback\ErrorMessage.tsx
interface Props {
message: string | null;
}
const ErrorMessage: React.FC<Props> = ({ message }) => {
if (!message) return null;
return (
<View style={styles.container}>
<Text style={styles.text}>{message}</Text>
</View>
);
};
export default ErrorMessage;
const styles = StyleSheet.create({
container: {
backgroundColor: '#FF6B6B',
padding: 10,
marginBottom:10,
borderRadius:8
},
text: {
color: '#fff',
fontWeight:'500',
textAlign:'center'
}
});
// File: src\components\feedback\ErrorState.tsx

// File: src\components\feedback\LoadingSpinner.tsx

// File: src\context\AuthContext.tsx

// File: src\features\auth\index.ts

// File: src\features\auth\hooks\useAuth.ts

// File: src\features\auth\screens\LoginScreen.tsx
const LoginScreen = () => {
const { t } = useTranslation();
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const { status, error } = useSelector((state: RootState) => state.auth);
const dispatch = useDispatch();
const navigation = useNavigation();
const handleLogin = async () => {
await dispatch(loginThunk({ email, password }));
};
return (
<KeyboardAvoidingView style={styles.container} behavior="padding">
<Image source={require('../../../../assets/images/logo.png')} style={styles.logo} />
<Text style={styles.title}>{t('welcome_back')}</Text>
<ErrorMessage message={error} />
<TextInputField
value={email}
onChangeText={setEmail}
placeholder={t('email')}
/>
<TextInputField
value={password}
onChangeText={setPassword}
placeholder={t('password')}
secureTextEntry
/>
<BrandedButton title={t('login')} onPress={handleLogin} disabled={status === 'loading'} />
<TouchableOpacity onPress={() => navigation.navigate('Register' as never)}>
<Text style={styles.link}>{t('no_account_register')}</Text>
</TouchableOpacity>
</KeyboardAvoidingView>
);
};
export default LoginScreen;
const styles = StyleSheet.create({
container: {
flex:1,
justifyContent:'center',
padding:20,
backgroundColor:'#fff'
},
logo: {
width:100,
height:100,
alignSelf:'center',
marginBottom:20
},
title: {
fontSize:24,
fontWeight:'700',
textAlign:'center',
marginBottom:20
},
link: {
color:'#1EAE98',
textAlign:'center',
marginTop:20
}
});
// File: src\features\auth\screens\RegisterScreen.tsx
const RegisterScreen = () => {
const { t } = useTranslation();
const [name, setName] = useState('');
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const { status, error } = useSelector((state: RootState) => state.auth);
const dispatch = useDispatch();
const navigation = useNavigation();
const handleRegister = async () => {
await dispatch(registerThunk({ email, password, name }));
};
return (
<KeyboardAvoidingView style={styles.container} behavior="padding">
<Image source={require('../../../../assets/images/logo.png')} style={styles.logo} />
<Text style={styles.title}>{t('create_account')}</Text>
<ErrorMessage message={error} />
<TextInputField
value={name}
onChangeText={setName}
placeholder={t('name')}
/>
<TextInputField
value={email}
onChangeText={setEmail}
placeholder={t('email')}
/>
<TextInputField
value={password}
onChangeText={setPassword}
placeholder={t('password')}
secureTextEntry
/>
<BrandedButton title={t('register')} onPress={handleRegister} disabled={status === 'loading'} />
<TouchableOpacity onPress={() => navigation.navigate('Login' as never)}>
<Text style={styles.link}>{t('have_account_login')}</Text>
</TouchableOpacity>
</KeyboardAvoidingView>
);
};
export default RegisterScreen;
const styles = StyleSheet.create({
container: {
flex:1,
justifyContent:'center',
padding:20,
backgroundColor:'#fff'
},
logo: {
width:100,
height:100,
alignSelf:'center',
marginBottom:20
},
title: {
fontSize:24,
fontWeight:'700',
textAlign:'center',
marginBottom:20
},
link: {
color:'#1EAE98',
textAlign:'center',
marginTop:20
}
});
// File: src\features\auth\store\authSlice.ts
UserLoginRequest,
UserLoginResponse,
UserRegistrationRequest,
RefreshTokenRequest,
AuthTokenResponse
} from '../../../types/apiTypes';
interface AuthState {
accessToken: string | null;
refreshToken: string | null;
userId: number | null;
email: string | null;
status: 'idle' | 'loading' | 'error';
error: string | null;
}
const initialState: AuthState = {
accessToken: null,
refreshToken: null,
userId: null,
email: null,
status: 'idle',
error: null
};
export const loginThunk = createAsyncThunk<
UserLoginResponse,
UserLoginRequest,
{ rejectValue: string }
>(
'auth/login',
async (credentials, { rejectWithValue }) => {
try {
const data = await authService.login(credentials);
await storage.saveTokens(data.Tokens.AccessToken, data.Tokens.RefreshToken);
return data;
} catch (error: any) {
return rejectWithValue(error.response?.data?.message || 'Login failed');
}
}
);
export const registerThunk = createAsyncThunk<
UserLoginResponse,
UserRegistrationRequest,
{ rejectValue: string }
>(
'auth/register',
async (payload, { rejectWithValue }) => {
try {
const data = await authService.register(payload);
await storage.saveTokens(data.Tokens.AccessToken, data.Tokens.RefreshToken);
return data;
} catch (error: any) {
return rejectWithValue(error.response?.data?.message || 'Registration failed');
}
}
);
export const refreshTokenThunk = createAsyncThunk<
AuthTokenResponse,
void,
{ state: RootState; rejectValue: string }
>(
'auth/refreshToken',
async (_, { getState, rejectWithValue }) => {
const state = getState();
const refreshToken = state.auth.refreshToken;
if (!refreshToken) {
return rejectWithValue('No refresh token available');
}
const payload: RefreshTokenRequest = { RefreshToken: refreshToken };
try {
const data = await authService.refreshToken(payload);
await storage.saveTokens(data.AccessToken, data.RefreshToken);
return data;
} catch (error: any) {
return rejectWithValue('Token refresh failed');
}
}
);
export const authSlice = createSlice({
name: 'auth',
initialState,
reducers: {
setInitialTokens(
state,
action: PayloadAction<{ accessToken: string | null; refreshToken: string | null; userId: number | null; email: string | null }>
) {
state.accessToken = action.payload.accessToken;
state.refreshToken = action.payload.refreshToken;
state.userId = action.payload.userId;
state.email = action.payload.email;
},
logout(state) {
state.accessToken = null;
state.refreshToken = null;
state.userId = null;
state.email = null;
state.error = null;
state.status = 'idle';
storage.clearTokens();
}
},
extraReducers: (builder) => {
builder
.addCase(loginThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(loginThunk.fulfilled, (state, action) => {
state.status = 'idle';
state.accessToken = action.payload.Tokens.AccessToken;
state.refreshToken = action.payload.Tokens.RefreshToken;
state.userId = action.payload.UserId;
state.email = action.payload.Email;
})
.addCase(loginThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload || 'Unknown error';
})
.addCase(registerThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(registerThunk.fulfilled, (state, action) => {
state.status = 'idle';
state.accessToken = action.payload.Tokens.AccessToken;
state.refreshToken = action.payload.Tokens.RefreshToken;
state.userId = action.payload.UserId;
state.email = action.payload.Email;
})
.addCase(registerThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload || 'Unknown error';
})
.addCase(refreshTokenThunk.fulfilled, (state, action) => {
state.accessToken = action.payload.AccessToken;
state.refreshToken = action.payload.RefreshToken;
})
.addCase(refreshTokenThunk.rejected, (state) => {
state.accessToken = null;
state.refreshToken = null;
state.userId = null;
state.email = null;
});
}
});
export const { logout, setInitialTokens } = authSlice.actions;
// File: src\features\auth\types\authTypes.ts

// File: src\features\main\index.ts

// File: src\features\main\hooks\useMatches.ts
export const useMyMatches = () => {
return useQuery('myMatches', matchService.getMyMatches, {
staleTime: 0,
refetchOnWindowFocus: true,
});
};
// File: src\features\main\hooks\usePlants.ts
export const useUserPlants = (userId: number) => {
return useQuery(['userPlants', userId], () => plantService.getUserPlants(userId), {
enabled: !!userId,
staleTime: 1000 * 60 * 5,
});
};
// File: src\features\main\screens\ChatScreen.tsx

// File: src\features\main\screens\HomeScreen.tsx

// File: src\features\main\screens\MatchListScreen.tsx

// File: src\features\main\screens\ProfileScreen.tsx

// File: src\features\main\screens\SettingsScreen.tsx
const SettingsScreen = () => {
const { t, i18n } = useTranslation();
const [currentLang, setCurrentLang] = useState(i18n.language);
const handleLanguageChange = async (lang: string) => {
await i18n.changeLanguage(lang);
await storage.saveLanguage(lang);
setCurrentLang(lang);
};
return (
<View style={styles.container}>
<Text style={styles.header}>Settings</Text>
<Text style={styles.label}>Selected Language: {currentLang}</Text>
<View style={styles.buttons}>
<TouchableOpacity onPress={() => handleLanguageChange('en')} style={[styles.button, currentLang === 'en' && styles.selected]}>
<Text style={styles.buttonText}>English</Text>
</TouchableOpacity>
<TouchableOpacity onPress={() => handleLanguageChange('fr')} style={[styles.button, currentLang === 'fr' && styles.selected]}>
<Text style={styles.buttonText}>Français</Text>
</TouchableOpacity>
</View>
</View>
);
};
export default SettingsScreen;
const styles = StyleSheet.create({
container: {
flex:1,
backgroundColor:'#fff',
padding:20
},
header: {
fontSize:24,
fontWeight:'700',
marginBottom:20
},
label: {
fontSize:16,
marginBottom:20
},
buttons: {
flexDirection:'row'
},
button: {
padding:10,
borderRadius:8,
borderWidth:1,
borderColor:'#ccc',
marginRight:10
},
selected: {
backgroundColor:'#1EAE98',
borderColor:'#1EAE98'
},
buttonText: {
color:'#000'
}
});
// File: src\features\main\screens\SwipeScreen.tsx

// File: src\features\main\store\matchesSlice.ts

// File: src\features\main\store\plantsSlice.ts

// File: src\features\main\store\userPreferencesSlice.ts
interface UserPreferencesState {
data: UserPreferencesResponse | null;
status: 'idle' | 'loading' | 'error';
error: string | null;
}
const initialState: UserPreferencesState = {
data: null,
status: 'idle',
error: null,
};
export const fetchUserPreferencesThunk = createAsyncThunk<UserPreferencesResponse, void, { rejectValue: string }>(
'userPreferences/fetch',
async (_, { rejectWithValue }) => {
try {
const preferences = await userPreferencesService.getPreferences();
return preferences;
} catch (error: any) {
return rejectWithValue(error.response?.data?.message || 'Failed to fetch user preferences');
}
}
);
export const updateUserPreferencesThunk = createAsyncThunk<UserPreferencesResponse, UserPreferencesRequest, { rejectValue: string }>(
'userPreferences/update',
async (data, { rejectWithValue }) => {
try {
const updated = await userPreferencesService.updatePreferences(data);
return updated;
} catch (error: any) {
return rejectWithValue(error.response?.data?.message || 'Failed to update user preferences');
}
}
);
export const userPreferencesSlice = createSlice({
name: 'userPreferences',
initialState,
reducers: {
clearUserPreferences(state) {
state.data = null;
state.status = 'idle';
state.error = null;
}
},
extraReducers: (builder) => {
builder
.addCase(fetchUserPreferencesThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(fetchUserPreferencesThunk.fulfilled, (state, action: PayloadAction<UserPreferencesResponse>) => {
state.status = 'idle';
state.data = action.payload;
})
.addCase(fetchUserPreferencesThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload as string;
})
.addCase(updateUserPreferencesThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(updateUserPreferencesThunk.fulfilled, (state, action: PayloadAction<UserPreferencesResponse>) => {
state.status = 'idle';
state.data = action.payload;
})
.addCase(updateUserPreferencesThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload as string;
});
}
});
export const { clearUserPreferences } = userPreferencesSlice.actions;
export const selectUserPreferences = (state: RootState) => state.userPreferences.data;
export const selectUserPreferencesStatus = (state: RootState) => state.userPreferences.status;
export const selectUserPreferencesError = (state: RootState) => state.userPreferences.error;
export default userPreferencesSlice.reducer;
// File: src\features\main\store\userSlice.ts
export const fetchUserProfile = createAsyncThunk<
UserResponse,
number,
{ rejectValue: string }
>(
'user/fetchUserProfile',
async (userId, { rejectWithValue }) => {
try {
const response = await api.get<UserResponse>(`/users/${userId}`);
return response.data;
} catch (error: any) {
return rejectWithValue(error.response?.data?.message || 'Failed to fetch user profile');
}
}
);
interface UserState {
profile: UserResponse | null;
status: 'idle' | 'loading' | 'error';
error: string | null;
}
const initialState: UserState = {
profile: null,
status: 'idle',
error: null
};
export const userSlice = createSlice({
name: 'user',
initialState,
reducers: {
clearUserProfile(state) {
state.profile = null;
state.status = 'idle';
state.error = null;
}
},
extraReducers: (builder) => {
builder
.addCase(fetchUserProfile.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(fetchUserProfile.fulfilled, (state, action: PayloadAction<UserResponse>) => {
state.status = 'idle';
state.profile = action.payload;
})
.addCase(fetchUserProfile.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload as string;
});
}
});
export const { clearUserProfile } = userSlice.actions;
// File: src\features\main\types\mainTypes.ts

// File: src\hooks\useAuthToken.ts
export const useAuthToken = () => {
const [initializing, setInitializing] = useState(true);
const [accessToken, setAccessToken] = useState<string | null>(null);
const [refreshToken, setRefreshToken] = useState<string | null>(null);
useEffect(() => {
const loadTokens = async () => {
const at = await storage.getAccessToken();
const rt = await storage.getRefreshToken();
setAccessToken(at);
setRefreshToken(rt);
setInitializing(false);
};
loadTokens();
}, []);
return { initializing, accessToken, refreshToken };
};
// File: src\hooks\useAxiosErrorHandler.ts

// File: src\hooks\useNetworkStatus.ts

// File: src\i18n\index.ts
export const initI18n = async () => {
let chosenLanguage = await storage.getLanguage();
if (!chosenLanguage) {
const locales = RNLocalize.getLocales();
const deviceLang = locales.length > 0 ? locales[0].languageCode : 'en';
chosenLanguage = ['en', 'fr'].includes(deviceLang) ? deviceLang : 'en';
await storage.saveLanguage(chosenLanguage);
}
i18n
.use(initReactI18next)
.init({
compatibilityJSON: 'v3',
lng: chosenLanguage,
fallbackLng: 'en',
resources: {
en: { translation: en },
fr: { translation: fr },
},
interpolation: {
escapeValue: false
}
});
return i18n;
};
// File: src\i18n\locales\en.json
{
"welcome_back": "Welcome Back",
"create_account": "Create Account",
"login": "Login",
"register": "Register",
"email": "Email",
"password": "Password",
"name": "Name",
"no_account_register": "Don’t have an account? Register",
"have_account_login": "Already have an account? Login"
}
// File: src\i18n\locales\fr.json

// File: src\navigation\AppNavigator.tsx
const AppNavigator = () => {
const dispatch = useDispatch();
const { accessToken, userId } = useSelector((state: RootState) => state.auth);
const { profile, status: userStatus } = useSelector((state: RootState) => state.user);
useEffect(() => {
if (accessToken && userId && !profile && userStatus === 'idle') {
dispatch(fetchUserProfile(userId) as any);
}
}, [accessToken, userId, profile, userStatus, dispatch]);
if (!accessToken) {
return (
<NavigationContainer>
<AuthNavigator />
</NavigationContainer>
);
}
if (userStatus === 'loading' || (!profile && userId)) {
return (
<View style={{ flex:1, justifyContent:'center', alignItems:'center' }}>
<ActivityIndicator size="large" />
</View>
);
}
return (
<NavigationContainer>
<MainNavigator />
</NavigationContainer>
);
};
export default AppNavigator;
// File: src\navigation\AuthNavigator.tsx
const Stack = createNativeStackNavigator();
const AuthNavigator = () => {
return (
<Stack.Navigator>
<Stack.Screen name="Login" component={LoginScreen} options={{ headerShown: false }} />
<Stack.Screen name="Register" component={RegisterScreen} options={{ headerShown: false }} />
</Stack.Navigator>
);
};
export default AuthNavigator;
// File: src\navigation\MainNavigator.tsx
const Tab = createBottomTabNavigator();
const MainNavigator = () => {
return (
<Tab.Navigator>
<Tab.Screen name="Home" component={HomeScreen} options={{ headerShown: false }} />
<Tab.Screen name="Profile" component={ProfileScreen} options={{ headerShown: false }} />
<Tab.Screen name="Settings" component={SettingsScreen} options={{ headerShown: false }} />
</Tab.Navigator>
);
};
export default MainNavigator;
// File: src\navigation\NavigationTypes.ts

// File: src\store\index.ts
export const store = configureStore({
reducer: {
auth: authSlice.reducer,
user: userSlice.reducer,
userPreferences: userPreferencesSlice.reducer,
},
});
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
// File: src\store\rootReducer.ts

// File: src\store\middlewares\tokenRefreshMiddleware.ts

// File: src\theme\colors.ts

// File: src\theme\index.ts

// File: src\theme\spacing.ts

// File: src\theme\typography.ts

// File: src\types\apiTypes.ts
export interface RefreshTokenRequest {
RefreshToken: string;
}
export interface MessageRequest {
MatchId: number;
MessageText: string;
}
export interface PlantCreateRequest {
PlantDetails: PlantRequest;
Image: IFormFile;
}
export interface PlantRequest {
SpeciesName: string;
Description: string;
PlantStage: PlantStage;
PlantCategory: PlantCategory;
WateringNeed: WateringNeed;
LightRequirement: LightRequirement;
Size?: Size;
IndoorOutdoor?: IndoorOutdoor;
PropagationEase?: PropagationEase;
PetFriendly?: PetFriendly;
Extras?: Extras[];
}
export interface PlantUpdateRequest {
SpeciesName: string;
CareRequirements: string;
Description: string;
Category: string;
}
export interface ReportRequest {
ReportedUserId: number;
Reason: string;
Comments: string;
}
export interface SwipeRequest {
SwiperPlantId: number;
SwipedPlantId: number;
IsLike: boolean;
}
export interface UpdateLocationRequest {
Latitude: number;
Longitude: number;
}
export interface UserLoginRequest {
Email: string;
Password: string;
}
export interface UserPreferencesRequest {
SearchRadius: number;
PreferedPlantStage: PlantStage[];
PreferedPlantCategory: PlantCategory[];
PreferedWateringNeed: WateringNeed[];
PreferedLightRequirement: LightRequirement[];
PreferedSize: Size[];
PreferedIndoorOutdoor: IndoorOutdoor[];
PreferedPropagationEase: PropagationEase[];
PreferedPetFriendly: PetFriendly[];
PreferedExtras: Extras[];
}
export interface UserProfileImageUpdateRequest {
Image: IFormFile;
}
export interface UserRegistrationRequest {
Email: string;
Password: string;
Name: string;
}
export interface UserUpdateRequest {
Name: string;
Bio: string;
}
export interface AuthTokenResponse {
AccessToken: string;
RefreshToken: string;
TokenType: string;
ExpiresIn: number;
}
export interface MatchResponse {
MatchId: number;
Plant1: PlantResponse;
Plant2: PlantResponse;
User1: UserResponse;
User2: UserResponse;
}
export interface MessageResponse {
MessageId: number;
MatchId: number;
SenderUserId: number;
MessageText: string;
SentAt: Date;
IsRead: boolean;
}
export interface PlantResponse {
PlantId: number;
UserId: number;
SpeciesName: string;
Description: string;
PlantStage: PlantStage;
PlantCategory: PlantCategory;
WateringNeed: WateringNeed;
LightRequirement: LightRequirement;
Size?: Size;
IndoorOutdoor?: IndoorOutdoor;
PropagationEase?: PropagationEase;
PetFriendly?: PetFriendly;
Extras?: Extras[];
ImageUrl: string;
}
export interface ReportResponse {
ReportId: number;
ReporterUserId: number;
ReportedUserId: number;
Reason: string;
Comments: string;
CreatedAt: Date;
IsResolved: boolean;
}
export interface SwipeResponse {
IsMatch: boolean;
Match: MatchResponse;
}
export interface UserLoginResponse {
UserId: number;
Email: string;
Tokens: AuthTokenResponse;
}
export interface UserPreferencesResponse {
UserId: number;
SearchRadius: number;
PreferedPlantStage: PlantStage[];
PreferedPlantCategory: PlantCategory[];
PreferedWateringNeed: WateringNeed[];
PreferedLightRequirement: LightRequirement[];
PreferedSize: Size[];
PreferedIndoorOutdoor: IndoorOutdoor[];
PreferedPropagationEase: PropagationEase[];
PreferedPetFriendly: PetFriendly[];
PreferedExtras: Extras[];
}
export interface UserResponse {
UserId: number;
Email: string;
Name: string;
ProfilePictureUrl: string;
Bio: string;
LocationLatitude?: number;
LocationLongitude?: number;
}
// File: src\types\enums.ts
export enum PlantStage {
Cutting,
GrownPlantTree
}
export enum PlantCategory {
Succulent,
Cactus,
Fern,
Orchid,
Herb,
Palm,
LeafyHouseplant,
FloweringHouseplant,
Other
}
export enum WateringNeed {
VeryLowWater,
LowWater,
ModerateWater,
HighWater,
VeryHighWater
}
export enum LightRequirement {
FullSun,
PartialShade,
Shade
}
export enum Size {
SmallSize,
MediumSize,
LargeSize
}
export enum IndoorOutdoor {
Indoor,
Outdoor,
IndoorAndOutdoor
}
export enum PropagationEase {
EasyPropagation,
ModeratePropagation,
DifficultPropagation
}
export enum PetFriendly {
PetFriendly,
NotPetFriendly,
}
export enum Extras {
Fragrant,
Edible,
Medicinal,
AirPurifying,
Decorative,
Flowering,
TropicalVibe,
FoliageHeavy,
DroughtTolerant,
HumidityLoving,
LowMaintenance,
WinterHardy,
BeginnerFriendly,
Fruiting,
PollinatorFriendly,
FastGrowing,
VariegatedFoliage,
Climbing,
GroundCover,
Rare
}
// File: src\types\global.ts

// File: src\utils\formatting.ts

// File: src\utils\index.ts

// File: src\utils\storage.ts
const ACCESS_TOKEN_KEY = "ACCESS_TOKEN_KEY";
const REFRESH_TOKEN_KEY = "REFRESH_TOKEN_KEY";
const LANGUAGE_KEY = "LANGUAGE_KEY";
export const storage = {
saveTokens: async (accessToken: string, refreshToken: string) => {
await SecureStore.setItemAsync(ACCESS_TOKEN_KEY, accessToken);
await SecureStore.setItemAsync(REFRESH_TOKEN_KEY, refreshToken);
},
getAccessToken: async () => SecureStore.getItemAsync(ACCESS_TOKEN_KEY),
getRefreshToken: async () => SecureStore.getItemAsync(REFRESH_TOKEN_KEY),
clearTokens: async () => {
await SecureStore.deleteItemAsync(ACCESS_TOKEN_KEY);
await SecureStore.deleteItemAsync(REFRESH_TOKEN_KEY);
},
saveLanguage: async (language: string) => {
await SecureStore.setItemAsync(LANGUAGE_KEY, language);
},
getLanguage: async () => SecureStore.getItemAsync(LANGUAGE_KEY),
};
// File: src\utils\validation.ts
