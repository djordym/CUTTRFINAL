
// File: app.json
{
"expo": {
"name": "MyCuttrApp",
"slug": "MyCuttrApp",
"version": "1.0.0",
"orientation": "portrait",
"icon": "./assets/images/icon.png",
"scheme": "myapp",
"userInterfaceStyle": "automatic",
"newArchEnabled": true,
"ios": {
"supportsTablet": true
},
"android": {
"adaptiveIcon": {
"foregroundImage": "./assets/images/adaptive-icon.png",
"backgroundColor": "#00000000"
}
},
"web": {
"bundler": "metro",
"output": "static",
"favicon": "./assets/images/favicon.png"
},
"plugins": [
"expo-router",
[
"expo-splash-screen",
{
"image": "./assets/images/splash-icon.png",
"imageWidth": 200,
"resizeMode": "contain",
"backgroundColor": "#00000000"
}
],
"expo-localization"
],
"experiments": {
"typedRoutes": true
}
}
}
// File: babel.config.js
module.exports = function(api) {
api.cache(true);
return {
presets: ['babel-preset-expo'],
plugins: ['react-native-reanimated/plugin'],
};
};
// File: expo-env.d.ts

// File: package.json
{
"name": "mycuttrapp",
"main": "expo-router/entry",
"version": "1.0.0",
"scripts": {
"start": "expo start",
"reset-project": "node ./scripts/reset-project.js",
"android": "expo start --android",
"ios": "expo start --ios",
"web": "expo start --web",
"test": "jest --watchAll",
"lint": "expo lint"
},
"jest": {
"preset": "jest-expo"
},
"dependencies": {
"@expo/vector-icons": "^14.0.2",
"@react-native-community/slider": "^4.5.5",
"@react-navigation/bottom-tabs": "^7.2.0",
"@react-navigation/native": "^7.0.14",
"@react-navigation/native-stack": "^7.2.0",
"@react-navigation/stack": "^7.1.1",
"@reduxjs/toolkit": "^2.5.0",
"axios": "^1.7.9",
"expo": "^52.0.23",
"expo-blur": "~14.0.1",
"expo-constants": "~17.0.3",
"expo-font": "~13.0.2",
"expo-haptics": "~14.0.0",
"expo-image-manipulator": "^13.0.5",
"expo-image-picker": "^16.0.3",
"expo-linear-gradient": "~14.0.1",
"expo-linking": "~7.0.3",
"expo-localization": "~16.0.0",
"expo-router": "~4.0.15",
"expo-secure-store": "^14.0.0",
"expo-splash-screen": "~0.29.18",
"expo-status-bar": "^2.0.0",
"expo-symbols": "~0.2.0",
"expo-system-ui": "~4.0.6",
"expo-web-browser": "~14.0.1",
"i18next": "^24.2.0",
"react": "18.3.1",
"react-dom": "18.3.1",
"react-i18next": "^15.2.0",
"react-native": "^0.76.5",
"react-native-gesture-handler": "~2.20.2",
"react-native-logs": "^5.3.0",
"react-native-maps": "1.18.0",
"react-native-reanimated": "^3.16.6",
"react-native-safe-area-context": "4.12.0",
"react-native-screens": "^4.4.0",
"react-native-vector-icons": "^10.2.0",
"react-native-web": "~0.19.13",
"react-native-webview": "13.12.5",
"react-query": "^3.39.3",
"react-redux": "^9.2.0"
},
"devDependencies": {
"@babel/core": "^7.26.0",
"@types/jest": "^29.5.12",
"@types/react": "~18.3.12",
"@types/react-redux": "^7.1.34",
"@types/react-test-renderer": "^18.3.0",
"jest": "^29.2.1",
"jest-expo": "~52.0.2",
"react-test-renderer": "18.3.1",
"typescript": "^5.7.2"
},
"private": true
}
// File: tsconfig.json
{
"extends": "expo/tsconfig.base",
"compilerOptions": {
"strict": true
},
"include": [
"***.tsx",
".expo/types*.ts",
"expo-env.d.ts"
]
}
// File: app\ErrorBoundary.tsx
interface ErrorBoundaryProps {
children: React.ReactNode;
}
export class ErrorBoundary extends React.Component<ErrorBoundaryProps> {
state = { hasError: false };
static getDerivedStateFromError(error: Error) {
return { hasError: true };
}
componentDidCatch(error: Error, info: any) {
log.error("Uncaught error in component tree", { error, info });
}
render() {
if (this.state.hasError) {
return (
<View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
<Text>An unexpected error occurred.</Text>
</View>
);
}
return this.props.children;
}
}
// File: app\index.tsx
const queryClient = new QueryClient();
export default function App() {
log.debug('App.tsx rendering...');
const [i18nInstance, setI18nInstance] = useState<any>(null);
useEffect(() => {
const setupI18n = async () => {
const i18n = await initI18n();
setI18nInstance(i18n);
};
setupI18n();
}, []);
if (!i18nInstance) {
return (
<View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
<ActivityIndicator size="large" />
</View>
);
}
return (
<ErrorBoundary>
<Provider store={store}>
<QueryClientProvider client={queryClient}>
{}
<I18nextProvider i18n={i18nInstance}>
<GestureHandlerRootView>
<StatusBar
style="dark"
backgroundColor='#1EAE98'
/>
<AppNavigator />
</GestureHandlerRootView>
</I18nextProvider>
</QueryClientProvider>
</Provider>
</ErrorBoundary>
);
}
// File: app\api\authService.ts
UserLoginRequest,
UserLoginResponse,
RefreshTokenRequest,
AuthTokenResponse,
UserRegistrationRequest
} from '../types/apiTypes';
export const authService = {
login: async (data: UserLoginRequest): Promise<UserLoginResponse> => {
const response = await api.post<UserLoginResponse>('/auth/login', data);
return response.data;
},
refreshToken: async (data: RefreshTokenRequest): Promise<AuthTokenResponse> => {
const response = await api.post<AuthTokenResponse>('/auth/refresh', data);
return response.data;
},
register: async (data: UserRegistrationRequest): Promise<UserLoginResponse> => {
const response = await api.post<UserLoginResponse>('/users/register', data);
log.debug('response', response);
return response.data;
},
logout: async (): Promise<void> => {
await api.post('/api/auth/logout');
},
};
// File: app\api\axiosConfig.ts
let isRefreshing = false;
let pendingRequests: Array<(token: string) => void> = [];
const api = axios.create({
baseURL: "http:
timeout: 10000,
});
api.interceptors.request.use(
async (config) => {
const state: RootState = store.getState();
const token = state.auth.accessToken;
if (token && config.headers) {
config.headers.Authorization = `Bearer ${token}`;
}
log.debug("API Request", {
baseUrl : api.defaults.baseURL,
url: config.url,
method: config.method,
data: config.data,
headers: config.headers,
});
return config;
},
(error) => {
log.error("API Request Error", error);
return Promise.reject(error);
}
);
api.interceptors.response.use(
(response) => {
log.debug("API Response", {
url: response.config.url,
status: response.status,
data: response.data,
header: response.headers,
});
return response;
},
async (error) => {
log.error("API Response Error", {
url: error.config.url,
message: error.message,
status: error.response.status,
data: error.response.data,
headers: error.response.headers,
});
if (!error.response) {
store.dispatch(setGlobalError("Network Error: Unable to connect."));
return Promise.reject(error);
}
const { status } = error.response;
const originalRequest = error.config;
if (status === 401 && !originalRequest._retry) {
if (!isRefreshing) {
isRefreshing = true;
originalRequest._retry = true;
try {
const result = await store.dispatch(refreshTokenThunk());
let newTokens: AuthTokenResponse | undefined;
if (refreshTokenThunk.fulfilled.match(result)) {
newTokens = result.payload;
console.log("New tokens:", newTokens);
} else {
console.error(
"Token refresh failed:",
result.payload || result.error.message
);
}
isRefreshing = false;
pendingRequests.forEach((cb) => cb(newTokens?.accessToken || ""));
pendingRequests = [];
return api(originalRequest);
} catch (refreshError) {
isRefreshing = false;
pendingRequests = [];
store.dispatch(logout());
return Promise.reject(refreshError);
}
}
return new Promise((resolve) => {
pendingRequests.push((token: string) => {
originalRequest.headers.Authorization = `Bearer ${token}`;
resolve(api(originalRequest));
});
});
}
let errorMessage: string;
if (typeof error.response.data === "string") {
errorMessage = error.response.data;
} else if (error.response.data?.message) {
errorMessage = error.response.data.message;
} else {
errorMessage = "An error occurred. Please try again later.";
}
store.dispatch(setGlobalError(errorMessage));
return Promise.reject(error);
}
);
export default api;
// File: app\api\matchService.ts
export const matchService = {
getMyMatches: async (): Promise<MatchResponse[]> => {
const response = await api.get<MatchResponse[]>('/matches/me');
return response.data;
},
getMatchById: async (matchId: number): Promise<MatchResponse> => {
const response = await api.get<MatchResponse>(`/matches/${matchId}`);
return response.data;
}
};
// File: app\api\messageService.ts
export const messageService = {
sendMessage: async (data: MessageRequest): Promise<MessageResponse> => {
const response = await api.post<MessageResponse>('/messages/me', data);
return response.data;
},
getMessagesForMatch: async (matchId: number): Promise<MessageResponse[]> => {
const response = await api.get<MessageResponse[]>(`/matches/${matchId}/messages`);
return response.data;
}
};
// File: app\api\plantService.ts
PlantCreateRequest,
PlantResponse,
PlantRequest,
} from "../types/apiTypes";
export const plantService = {
addMyPlant: async (data: PlantCreateRequest): Promise<PlantResponse> => {
const formData = new FormData();
formData.append("Image", data.image);
formData.append("PlantDetails.SpeciesName", data.plantDetails.speciesName);
formData.append(
"PlantDetails.PlantStage",
String(data.plantDetails.plantStage)
);
formData.append(
"PlantDetails.Description",
data.plantDetails.description ?? ""
);
formData.append(
"PlantDetails.PlantCategory",
data.plantDetails.plantCategory != null
? String(data.plantDetails.plantCategory)
: ""
);
formData.append(
"PlantDetails.WateringNeed",
data.plantDetails.wateringNeed != null
? String(data.plantDetails.wateringNeed)
: ""
);
formData.append(
"PlantDetails.LightRequirement",
data.plantDetails.lightRequirement != null
? String(data.plantDetails.lightRequirement)
: ""
);
formData.append(
"PlantDetails.Size",
data.plantDetails.size != null ? String(data.plantDetails.size) : ""
);
formData.append(
"PlantDetails.IndoorOutdoor",
data.plantDetails.indoorOutdoor != null
? String(data.plantDetails.indoorOutdoor)
: ""
);
formData.append(
"PlantDetails.PropagationEase",
data.plantDetails.propagationEase != null
? String(data.plantDetails.propagationEase)
: ""
);
formData.append(
"PlantDetails.PetFriendly",
data.plantDetails.petFriendly != null
? String(data.plantDetails.petFriendly)
: ""
);
if (data.plantDetails.extras && data.plantDetails.extras.length > 0) {
data.plantDetails.extras.forEach((extra) => {
formData.append("PlantDetails.Extras", String(extra));
});
}
const response = await api.post<PlantResponse>("/plants/me", formData, {
headers: { "Content-Type": "multipart/form-data" },
});
return response.data;
},
getPlantById: async (plantId: number): Promise<PlantResponse> => {
const response = await api.get<PlantResponse>(`/plants/${plantId}`);
return response.data;
},
updateMyPlant: async (
plantId: number,
data: PlantRequest
): Promise<PlantResponse> => {
const response = await api.put<PlantResponse>(
`/plants/me/${plantId}`,
data
);
return response.data;
},
deleteMyPlant: async (plantId: number): Promise<void> => {
await api.delete(`/plants/me/${plantId}`);
},
getUserPlants: async (userId: number): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>(`/users/${userId}/plants`);
return response.data;
},
getMyPlants: async (): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>("/users/me/plants");
return response.data;
},
};
// File: app\api\reportService.ts
export const reportService = {
createReport: async (data: ReportRequest): Promise<ReportResponse> => {
const response = await api.post<ReportResponse>('/reports', data);
return response.data;
}
};
// File: app\api\swipeService.ts
export const swipeService = {
sendSwipes: async (swipes: SwipeRequest[]): Promise<SwipeResponse> => {
const response = await api.post<SwipeResponse>('/swipes/me', swipes);
return response.data;
},
getLikablePlants: async (): Promise<PlantResponse[]> => {
const response = await api.get<PlantResponse[]>('/swipes/me/likable-plants');
return response.data;
}
};
// File: app\api\userPreferencesService.ts
export const userPreferencesService = {
getPreferences: async (): Promise<UserPreferencesResponse> => {
const response = await api.get<UserPreferencesResponse>('/userpreferences');
return response.data;
},
updatePreferences: async (data: UserPreferencesRequest): Promise<UserPreferencesResponse> => {
const response = await api.post<UserPreferencesResponse>('/userpreferences', data);
return response.data;
}
};
// File: app\api\userService.ts
export const userService = {
register: async (data: { Email: string; Password: string; Name: string }): Promise<UserResponse> => {
const response = await api.post<UserResponse>('/users/register', data);
return response.data;
},
getUser: async (userId: number): Promise<UserResponse> => {
const response = await api.get<UserResponse>(`/users/${userId}`);
return response.data;
},
updateMe: async (data: UserUpdateRequest): Promise<UserResponse> => {
const response = await api.put<UserResponse>('/users/me', data);
return response.data;
},
deleteMe: async (): Promise<void> => {
await api.delete('/users/me');
},
updateProfilePicture: async (data: UserProfileImageUpdateRequest): Promise<UserResponse> => {
const formData = new FormData();
formData.append('Image', data.image);
const response = await api.put<UserResponse>('/users/me/profile-picture', formData, {
headers: { 'Content-Type': 'multipart/form-data' }
});
return response.data;
},
updateLocation: async (data: UpdateLocationRequest): Promise<void> => {
await api.put('/users/me/location', data);
},
getCurrentUserProfile: async (): Promise<UserResponse> => {
const response = await api.get<UserResponse>('/users/me');
return response.data;
},
};
// File: app\components\index.ts

// File: app\components\common\BrandedButton.tsx
interface Props {
title: string;
onPress: () => void;
disabled?: boolean;
}
const BrandedButton: React.FC<Props> = ({ title, onPress, disabled }) => {
return (
<TouchableOpacity onPress={onPress} style={[styles.button, disabled && {opacity:0.5}]} disabled={disabled}>
<Text style={styles.buttonText}>{title}</Text>
</TouchableOpacity>
);
};
export default BrandedButton;
const styles = StyleSheet.create({
button: {
backgroundColor: '#1EAE98',
padding: 16,
borderRadius: 8,
alignItems:'center',
marginVertical:10
},
buttonText: {
color:'#fff',
fontSize:16,
fontWeight:'600'
}
});
// File: app\components\common\TextInputField.tsx
interface Props {
value: string;
onChangeText: (text: string) => void;
placeholder?: string;
secureTextEntry?: boolean;
}
const TextInputField: React.FC<Props> = ({ value, onChangeText, placeholder, secureTextEntry }) => {
return (
<View style={styles.container}>
<TextInput
style={styles.input}
value={value}
onChangeText={onChangeText}
placeholder={placeholder}
secureTextEntry={secureTextEntry}
placeholderTextColor="#999"
/>
</View>
);
};
export default TextInputField;
const styles = StyleSheet.create({
container: {
marginVertical: 10,
borderWidth:1,
borderColor:'#ccc',
borderRadius:8,
},
input: {
padding:12,
fontSize:16,
}
});
// File: app\components\feedback\ErrorMessage.tsx
interface Props {
message: string | null;
}
const ErrorMessage: React.FC<Props> = ({ message }) => {
if (!message) return null;
return (
<View style={styles.container}>
<Text style={styles.text}>{message}</Text>
</View>
);
};
export default ErrorMessage;
const styles = StyleSheet.create({
container: {
backgroundColor: '#FF6B6B',
padding: 10,
marginBottom:10,
borderRadius:8
},
text: {
color: '#fff',
fontWeight:'500',
textAlign:'center'
}
});
// File: app\components\feedback\ErrorState.tsx

// File: app\components\feedback\LoadingSpinner.tsx

// File: app\context\AuthContext.tsx

// File: app\features\auth\index.ts

// File: app\features\auth\hooks\useAuth.ts

// File: app\features\auth\screens\LoginScreen.tsx
const LoginScreen = () => {
const { t } = useTranslation();
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const { status, error } = useAppSelector((state: RootState) => state.auth);
const dispatch = useAppDispatch();
const navigation = useNavigation();
const handleLogin = async () => {
let userLoginRequest: UserLoginRequest = {
email: email,
password: password
};
log.debug('Pressed login button, userLoginRequest:', userLoginRequest);
await dispatch(loginThunk(userLoginRequest));
};
return (
<KeyboardAvoidingView style={styles.container} behavior="padding">
<Image source={require('../../../../assets/images/logo.png')} style={styles.logo} />
<Text style={styles.title}>{t('welcome_back')}</Text>
<ErrorMessage message={error} />
<TextInputField
value={email}
onChangeText={setEmail}
placeholder={t('email')}
/>
<TextInputField
value={password}
onChangeText={setPassword}
placeholder={t('password')}
secureTextEntry
/>
<BrandedButton title={t('login')} onPress={handleLogin} disabled={status === 'loading'} />
<TouchableOpacity onPress={() => navigation.navigate('Register' as never)}>
<Text style={styles.link}>{t('no_account_register')}</Text>
</TouchableOpacity>
</KeyboardAvoidingView>
);
};
export default LoginScreen;
const styles = StyleSheet.create({
container: {
flex:1,
justifyContent:'center',
padding:20,
backgroundColor:'#fff'
},
logo: {
width:100,
height:100,
alignSelf:'center',
marginBottom:20
},
title: {
fontSize:24,
fontWeight:'700',
textAlign:'center',
marginBottom:20
},
link: {
color:'#1EAE98',
textAlign:'center',
marginTop:20
}
});
// File: app\features\auth\screens\RegisterScreen.tsx
const RegisterScreen = () => {
const { t } = useTranslation();
const [name, setName] = useState('');
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const { status, error } = useAppSelector((state: RootState) => state.auth);
const dispatch = useAppDispatch();
const navigation = useNavigation();
const handleRegister = async () => {
const userRegistrationRequest: UserRegistrationRequest = {
email: email,
password: password,
name: name,
};
log.debug('Pressed register button, userRegistrationRequest:', userRegistrationRequest);
await dispatch(registerThunk(userRegistrationRequest));
};
return (
<KeyboardAvoidingView style={styles.container} behavior="padding">
<Image source={require('../../../../assets/images/logo.png')} style={styles.logo} />
<Text style={styles.title}>{t('create_account')}</Text>
<ErrorMessage message={error} />
<TextInputField
value={name}
onChangeText={setName}
placeholder={t('name')}
/>
<TextInputField
value={email}
onChangeText={setEmail}
placeholder={t('email')}
/>
<TextInputField
value={password}
onChangeText={setPassword}
placeholder={t('password')}
secureTextEntry
/>
<BrandedButton title={t('register')} onPress={handleRegister} disabled={status === 'loading'} />
<TouchableOpacity onPress={() => navigation.navigate('Login' as never)}>
<Text style={styles.link}>{t('have_account_login')}</Text>
</TouchableOpacity>
</KeyboardAvoidingView>
);
};
export default RegisterScreen;
const styles = StyleSheet.create({
container: {
flex:1,
justifyContent:'center',
padding:20,
backgroundColor:'#fff'
},
logo: {
width:100,
height:100,
alignSelf:'center',
marginBottom:20
},
title: {
fontSize:24,
fontWeight:'700',
textAlign:'center',
marginBottom:20
},
link: {
color:'#1EAE98',
textAlign:'center',
marginTop:20
}
});
// File: app\features\auth\store\authSlice.ts
UserLoginRequest,
UserLoginResponse,
UserRegistrationRequest,
RefreshTokenRequest,
AuthTokenResponse
} from '../../../types/apiTypes';
interface AuthState {
accessToken: string | null;
refreshToken: string | null;
userId: number | null;
email: string | null;
status: 'idle' | 'loading' | 'error';
error: string | null;
}
const initialState: AuthState = {
accessToken: null,
refreshToken: null,
userId: null,
email: null,
status: 'idle',
error: null
};
export const loginThunk = createAsyncThunk<
UserLoginResponse,
UserLoginRequest,
{ rejectValue: string }
>(
'auth/login',
async (credentials, { rejectWithValue }) => {
try {
const data = await authService.login(credentials);
log.debug('loginThunk data:', data);
await storage.saveTokens(data.tokens.accessToken, data.tokens.refreshToken);
return data;
} catch (error: any) {
log.error("Login error details:", error);
return rejectWithValue(error.response?.data?.message || 'Login failed');
}
}
);
export const registerThunk = createAsyncThunk<
UserLoginResponse,
UserRegistrationRequest,
{ rejectValue: string }
>(
'auth/register',
async (payload, { rejectWithValue }) => {
try {
const data = await authService.register(payload);
await storage.saveTokens(data.tokens.accessToken, data.tokens.refreshToken);
return data;
} catch (error: any) {
log.error("Registration error details:", error);
if (error.response) {
log.error("Registration error response data:", error.response.data);
log.error("Registration error response status:", error.response.status);
log.error("Registration error response headers:", error.response.headers);
} else {
log.error("Registration error: no response object", error.message);
}
return rejectWithValue(error.response?.data || 'Registration failed');
}
}
);
export const refreshTokenThunk = createAsyncThunk<
AuthTokenResponse,
void,
{ state: RootState; rejectValue: string }
>(
'auth/refreshToken',
async (_, { getState, rejectWithValue }) => {
const state = getState();
const refreshToken = state.auth.refreshToken;
if (!refreshToken) {
return rejectWithValue('No refresh token available');
}
const payload: RefreshTokenRequest = { refreshToken: refreshToken };
try {
const data = await authService.refreshToken(payload);
await storage.saveTokens(data.accessToken, data.refreshToken);
return data;
} catch (error: any) {
return rejectWithValue('Token refresh failed');
}
}
);
export const authSlice = createSlice({
name: 'auth',
initialState,
reducers: {
setInitialTokens(
state,
action: PayloadAction<{ accessToken: string | null; refreshToken: string | null; userId: number | null; email: string | null }>
) {
state.accessToken = action.payload.accessToken;
state.refreshToken = action.payload.refreshToken;
state.userId = action.payload.userId;
state.email = action.payload.email;
},
logout(state) {
state.accessToken = null;
state.refreshToken = null;
state.userId = null;
state.email = null;
state.error = null;
state.status = 'idle';
storage.clearTokens();
}
},
extraReducers: (builder) => {
builder
.addCase(loginThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(loginThunk.fulfilled, (state, action) => {
state.status = 'idle';
state.accessToken = action.payload.tokens.accessToken;
state.refreshToken = action.payload.tokens.refreshToken;
state.userId = action.payload.userId;
state.email = action.payload.email;
})
.addCase(loginThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload || 'Unknown error';
})
.addCase(registerThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(registerThunk.fulfilled, (state, action) => {
state.status = 'idle';
state.accessToken = action.payload.tokens.accessToken;
state.refreshToken = action.payload.tokens.refreshToken;
state.userId = action.payload.userId;
state.email = action.payload.email;
})
.addCase(registerThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload || 'Unknown error';
})
.addCase(refreshTokenThunk.fulfilled, (state, action) => {
state.accessToken = action.payload.accessToken;
state.refreshToken = action.payload.refreshToken;
})
.addCase(refreshTokenThunk.rejected, (state) => {
state.accessToken = null;
state.refreshToken = null;
state.userId = null;
state.email = null;
storage.clearTokens();
});
}
});
export const { logout, setInitialTokens } = authSlice.actions;
// File: app\features\auth\types\authTypes.ts

// File: app\features\main\index.ts

// File: app\features\main\components\ChangeLocationModal.tsx
Modal,
View,
Text,
StyleSheet,
TouchableOpacity,
ActivityIndicator,
TextInput,
Alert,
} from 'react-native';
interface ChangeLocationModalProps {
visible: boolean;
initialLatitude?: number;
initialLongitude?: number;
onClose: () => void;
onUpdated: () => void;
}
export const ChangeLocationModal: React.FC<ChangeLocationModalProps> = ({
visible,
initialLatitude,
initialLongitude,
onClose,
onUpdated,
}) => {
const { t } = useTranslation();
const [markerPosition, setMarkerPosition] = useState<{
lat: number;
lng: number;
} | null>(null);
const [region, setRegion] = useState<Region | null>(null);
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const [searchInput, setSearchInput] = useState('');
const hasInitialCoords =
typeof initialLatitude === 'number' &&
!Number.isNaN(initialLatitude) &&
typeof initialLongitude === 'number' &&
!Number.isNaN(initialLongitude);
useEffect(() => {
if (visible) {
if (hasInitialCoords) {
setRegion({
latitude: initialLatitude!,
longitude: initialLongitude!,
latitudeDelta: 0.05,
longitudeDelta: 0.05,
});
setMarkerPosition({ lat: initialLatitude!, lng: initialLongitude! });
} else {
setRegion({
latitude: 37.78825,
longitude: -122.4324,
latitudeDelta: 0.05,
longitudeDelta: 0.05,
});
setMarkerPosition(null);
}
setSearchInput('');
setError(null);
}
}, [visible, hasInitialCoords, initialLatitude, initialLongitude]);
const handleMapPress = (e: MapPressEvent) => {
const { coordinate } = e.nativeEvent;
setMarkerPosition({ lat: coordinate.latitude, lng: coordinate.longitude });
};
const handleRegionChangeComplete = (newRegion: Region) => {
setRegion(newRegion);
};
const handleConfirm = async () => {
if (!markerPosition) {
onClose();
return;
}
setLoading(true);
setError(null);
const payload: UpdateLocationRequest = {
latitude: markerPosition.lat,
longitude: markerPosition.lng,
};
try {
await userService.updateLocation(payload);
onUpdated();
onClose();
} catch {
setError(t('change_location_error_message'));
} finally {
setLoading(false);
}
};
const handleCancel = () => {
onClose();
};
const handleSearch = useCallback(async () => {
if (!searchInput) return;
setLoading(true);
setError(null);
try {
const url = `https:
searchInput
)}&format=json&limit=1`;
const response = await fetch(url);
const data = await response.json();
if (data && data.length > 0) {
const { lat, lon } = data[0];
const latNum = parseFloat(lat);
const lonNum = parseFloat(lon);
const newRegion: Region = {
latitude: latNum,
longitude: lonNum,
latitudeDelta: 0.05,
longitudeDelta: 0.05,
};
setRegion(newRegion);
setMarkerPosition({ lat: latNum, lng: lonNum });
} else {
setError(t('No results found for that location.'));
}
} catch (err) {
console.error('Geocoding error:', err);
setError(t('change_location_error_message'));
} finally {
setLoading(false);
}
}, [searchInput, t]);
if (!visible) {
return null;
}
return (
<Modal visible={visible} animationType="slide" transparent>
<View style={styles.overlay}>
<View style={styles.modalContainer}>
<Text style={styles.title}>{t('change_location_title')}</Text>
<Text style={styles.subtitle}>{t('change_location_instructions')}</Text>
{}
<View style={styles.searchRow}>
<TextInput
style={styles.searchInput}
placeholder={t('Enter a city or country...')}
value={searchInput}
onChangeText={setSearchInput}
returnKeyType="search"
onSubmitEditing={handleSearch}
/>
<TouchableOpacity onPress={handleSearch} style={styles.searchButton}>
<Text style={styles.searchButtonText}>{t('Search')}</Text>
</TouchableOpacity>
</View>
{error && <Text style={styles.errorText}>{error}</Text>}
<View style={styles.mapContainer}>
{region && (
<MapView
style={{ flex: 1 }}
region={region}
onRegionChangeComplete={handleRegionChangeComplete}
onPress={handleMapPress}
>
{markerPosition && (
<Marker
coordinate={{
latitude: markerPosition.lat,
longitude: markerPosition.lng,
}}
/>
)}
</MapView>
)}
</View>
{loading && (
<ActivityIndicator size="small" color="#1EAE98" style={{ marginVertical: 10 }} />
)}
<View style={styles.actions}>
<TouchableOpacity
onPress={handleCancel}
style={styles.cancelButton}
accessibilityRole="button"
>
<Text style={styles.cancelButtonText}>
{t('change_location_cancel_button')}
</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={handleConfirm}
style={styles.confirmButton}
accessibilityRole="button"
>
<Text style={styles.confirmButtonText}>
{t('change_location_confirm_button')}
</Text>
</TouchableOpacity>
</View>
</View>
</View>
</Modal>
);
};
const styles = StyleSheet.create({
overlay: {
flex: 1,
backgroundColor: 'rgba(0,0,0,0.5)',
justifyContent: 'center',
alignItems: 'center',
},
modalContainer: {
width: '90%',
height: '80%',
backgroundColor: '#fff',
borderRadius: 16,
padding: 20,
},
title: {
fontSize: 18,
fontWeight: '700',
color: '#333',
marginBottom: 10,
},
subtitle: {
fontSize: 14,
color: '#555',
marginBottom: 10,
},
searchRow: {
flexDirection: 'row',
alignItems: 'center',
marginBottom: 10,
},
searchInput: {
flex: 1,
borderWidth: 1,
borderColor: '#ccc',
borderRadius: 8,
paddingHorizontal: 10,
paddingVertical: 6,
marginRight: 8,
},
searchButton: {
backgroundColor: '#1EAE98',
paddingHorizontal: 15,
paddingVertical: 10,
borderRadius: 8,
},
searchButtonText: {
color: '#fff',
fontWeight: '600',
},
errorText: {
color: '#FF6B6B',
marginBottom: 10,
},
mapContainer: {
flex: 1,
borderRadius: 8,
overflow: 'hidden',
marginBottom: 10,
backgroundColor: '#eee',
},
actions: {
flexDirection: 'row',
justifyContent: 'flex-end',
},
cancelButton: {
marginRight: 10,
backgroundColor: '#f0f0f0',
paddingHorizontal: 15,
paddingVertical: 10,
borderRadius: 8,
},
cancelButtonText: {
fontSize: 16,
color: '#333',
fontWeight: '600',
},
confirmButton: {
backgroundColor: '#1EAE98',
paddingHorizontal: 15,
paddingVertical: 10,
borderRadius: 8,
},
confirmButtonText: {
fontSize: 16,
color: '#fff',
fontWeight: '600',
},
});
// File: app\features\main\components\EditProfileModal.tsx
interface EditProfileModalProps {
visible: boolean;
initialName: string;
initialBio: string;
onClose: () => void;
onUpdated: () => void;
}
export const EditProfileModal: React.FC<EditProfileModalProps> = ({ visible, initialName, initialBio, onClose, onUpdated }) => {
const { t } = useTranslation();
const [name, setName] = useState(initialName);
const [bio, setBio] = useState(initialBio);
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const handleConfirm = async () => {
setLoading(true);
setError(null);
const payload: UserUpdateRequest = { name: name, bio: bio };
try {
await userService.updateMe(payload);
onUpdated();
onClose();
} catch {
setError(t('edit_profile_error_message'));
} finally {
setLoading(false);
}
};
const handleCancel = () => {
onClose();
};
return (
<Modal visible={visible} animationType="slide" transparent>
<View style={styles.overlay}>
<View style={styles.modalContainer}>
<Text style={styles.title}>{t('edit_profile_title')}</Text>
{error && <Text style={styles.errorText}>{error}</Text>}
<Text style={styles.label}>{t('edit_profile_name_label')}:</Text>
<TextInput
style={styles.input}
value={name}
onChangeText={setName}
accessibilityLabel={t('edit_profile_name_label')}
/>
<Text style={styles.label}>{t('edit_profile_bio_label')}:</Text>
<TextInput
style={[styles.input, { height:80 }]}
value={bio}
onChangeText={setBio}
multiline
accessibilityLabel={t('edit_profile_bio_label')}
/>
{loading && <ActivityIndicator size="small" color="#1EAE98" style={{marginVertical:10}}/>}
<View style={styles.actions}>
<TouchableOpacity onPress={handleCancel} style={styles.cancelButton} accessibilityRole="button">
<Text style={styles.cancelButtonText}>{t('edit_profile_cancel_button')}</Text>
</TouchableOpacity>
<TouchableOpacity onPress={handleConfirm} style={styles.confirmButton} accessibilityRole="button">
<Text style={styles.confirmButtonText}>{t('edit_profile_confirm_button')}</Text>
</TouchableOpacity>
</View>
</View>
</View>
</Modal>
);
};
const styles = StyleSheet.create({
overlay:{
flex:1,
backgroundColor:'rgba(0,0,0,0.5)',
justifyContent:'center',
alignItems:'center'
},
modalContainer:{
width:'90%',
backgroundColor:'#fff',
borderRadius:16,
padding:20
},
title:{
fontSize:18,
fontWeight:'700',
color:'#333',
marginBottom:10
},
errorText:{
color:'#FF6B6B',
marginBottom:10
},
label:{
fontSize:14,
fontWeight:'600',
color:'#333',
marginBottom:4
},
input:{
borderWidth:1,
borderColor:'#ccc',
borderRadius:8,
padding:10,
marginBottom:10,
fontSize:14
},
actions:{
flexDirection:'row',
justifyContent:'flex-end',
marginTop:10
},
cancelButton:{
marginRight:10
},
cancelButtonText:{
fontSize:16,
color:'#333'
},
confirmButton:{
backgroundColor:'#1EAE98',
paddingHorizontal:15,
paddingVertical:10,
borderRadius:8
},
confirmButtonText:{
fontSize:16,
color:'#fff',
fontWeight:'600'
}
});
// File: app\features\main\components\MultiSelectTagGroup.tsx
interface MultiSelectTagGroupProps<T extends string | number> {
values: T[];
selectedValues: T[];
onToggle: (val: T) => void;
}
function MultiSelectTagGroup<T extends string | number>({
values,
selectedValues,
onToggle,
}: MultiSelectTagGroupProps<T>) {
return (
<View style={styles.tagGroupContainer}>
{values.map((val) => {
const isSelected = selectedValues.includes(val);
return (
<TouchableOpacity
key={String(val)}
style={[
styles.singleTag,
isSelected && styles.singleTagSelected,
]}
onPress={() => onToggle(val)}
>
<Text
style={[
styles.singleTagText,
isSelected && styles.singleTagTextSelected,
]}
>
{val}
</Text>
</TouchableOpacity>
);
})}
</View>
);
}
export default MultiSelectTagGroup;
const styles = StyleSheet.create({
tagGroupContainer: {
flexDirection: 'row',
flexWrap: 'wrap',
marginBottom: 6,
},
singleTag: {
borderWidth: 1,
borderColor: '#1EAE98',
borderRadius: 20,
paddingVertical: 6,
paddingHorizontal: 12,
marginRight: 8,
marginBottom: 8,
},
singleTagSelected: {
backgroundColor: '#1EAE98',
},
singleTagText: {
fontSize: 12,
color: '#1EAE98',
},
singleTagTextSelected: {
color: '#fff',
fontWeight: '600',
},
});
// File: app\features\main\components\SelectPlantsModal.tsx

// File: app\features\main\components\SwipeableCard.tsx
StyleSheet,
View,
Image,
Text,
Dimensions,
} from 'react-native';
useSharedValue,
useAnimatedGestureHandler,
useAnimatedStyle,
runOnJS,
withSpring,
} from 'react-native-reanimated';
const { width } = Dimensions.get('window');
const SWIPE_THRESHOLD = 0.25 * width;
const COLORS = {
primary: '#1EAE98',
accent: '#FF6F61',
background: '#F2F2F2',
textDark: '#2F4F4F',
textLight: '#FFFFFF',
cardBg: '#FFFFFF',
border: '#ddd',
};
interface SwipeableCardProps {
plant: PlantResponse;
onSwipeLeft: (plantId: number) => void;
onSwipeRight: (plantId: number) => void;
}
export const SwipeableCard: React.FC<SwipeableCardProps> = ({
plant,
onSwipeLeft,
onSwipeRight,
}) => {
const translateX = useSharedValue(0);
const rotateZ = useSharedValue(0);
const allTags = [
plant.plantStage,
plant.plantCategory,
plant.wateringNeed,
plant.lightRequirement,
plant.size,
plant.indoorOutdoor,
plant.propagationEase,
plant.petFriendly,
...(plant.extras ?? [])
].filter(Boolean);
const gestureHandler = useAnimatedGestureHandler<
PanGestureHandlerGestureEvent,
{ startX: number }
>({
onStart: (_, ctx) => {
ctx.startX = translateX.value;
},
onActive: (event, ctx) => {
translateX.value = ctx.startX + event.translationX;
rotateZ.value = (event.translationX / width) * 0.15;
},
onEnd: (event) => {
if (event.translationX > SWIPE_THRESHOLD) {
translateX.value = withSpring(width * 1.5, {}, (finished) => {
if (finished) runOnJS(onSwipeRight)(plant.plantId);
});
} else if (event.translationX < -SWIPE_THRESHOLD) {
translateX.value = withSpring(-width * 1.5, {}, (finished) => {
if (finished) runOnJS(onSwipeLeft)(plant.plantId);
});
} else {
translateX.value = withSpring(0);
rotateZ.value = withSpring(0);
}
},
});
const animatedStyle = useAnimatedStyle(() => ({
transform: [
{ translateX: translateX.value },
{ rotateZ: `${rotateZ.value}rad` },
],
}));
return (
<PanGestureHandler onGestureEvent={gestureHandler}>
<Animated.View style={[styles.cardContainer, animatedStyle]}>
<View style={styles.fullImageContainer}>
{plant.imageUrl ? (
<Image
source={{ uri: plant.imageUrl }}
style={styles.fullImage}
resizeMode="contain"
/>
) : (
<View style={styles.plantPlaceholder}>
<Ionicons name="leaf" size={60} color={COLORS.primary} />
</View>
)}
<View style={styles.imageOverlay}>
<LinearGradient
colors={['rgba(0,0,0,0)', 'rgba(0,0,0,1)']}
style={styles.overlayContent}
>
</LinearGradient>
</View>
</View>
<View style={styles.tagContainer}>
{}
<Text style={styles.fullPlantName} numberOfLines={1}>
{plant.speciesName}
</Text>
{}
{allTags.length > 0 && (
<View style={styles.tagRow}>
{allTags.map((tag) => (
<View key={tag} style={styles.tag}>
<Text style={styles.tagText}>{tag}</Text>
</View>
))}
</View>
)}
{}
{plant.description ? (
<Text style={styles.fullDescription} numberOfLines={3}>
{plant.description}
</Text>
) : null}
</View>
<View style={styles.underImageExtension} />
</Animated.View>
</PanGestureHandler>
);
};
const styles = StyleSheet.create({
cardContainer: {
position: 'absolute',
width: width * 0.9,
borderRadius: 8,
overflow: 'hidden',
marginVertical: 'auto',
backgroundColor: COLORS.cardBg,
shadowColor: '#000',
shadowOpacity: 0.12,
shadowRadius: 5,
shadowOffset: { width: 0, height: 3 },
elevation: 3,
},
innerContainer: {
flex: 1,
borderRadius: 8,
overflow: 'hidden',
},
fullImageContainer: {
width: '100%',
position: 'relative',
aspectRatio: 3 / 4,
},
fullImage: {
...StyleSheet.absoluteFillObject,
},
plantPlaceholder: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
backgroundColor: '#eee',
},
imageOverlay: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
},
overlayContent: {
position:'relative',
bottom: 0,
paddingTop: 200,
},
underImageExtension: {
backgroundColor: 'black',
zIndex: -1,
height: 50,
},
tagContainer: {
padding: 5,
position: 'absolute',
bottom: 0,
},
fullPlantName: {
fontSize: 18,
fontWeight: '700',
color: '#fff',
marginBottom: 6,
},
tagRow: {
flexDirection: 'row',
flexWrap: 'wrap',
marginBottom: 6,
},
tag: {
backgroundColor: COLORS.primary,
borderRadius: 12,
paddingHorizontal: 8,
paddingVertical: 4,
marginRight: 6,
},
tagText: {
color: '#fff',
fontSize: 12,
fontWeight: '600',
},
fullDescription: {
color: '#fff',
fontSize: 14,
fontWeight: '400',
},
});
// File: app\features\main\hooks\useMatchConversation.ts
export const useMatchConversation = (matchId: number) => {
const queryClient = useQueryClient();
const messagesQuery = useQuery<MessageResponse[], Error>(
['messages', matchId],
() => messageService.getMessagesForMatch(matchId),
{
enabled: matchId > 0,
staleTime: 1000 * 30,
}
);
const sendMessageMutation = useMutation<
MessageResponse,
unknown,
Omit<MessageRequest, 'matchId'>
>(
async (payload) => {
return await messageService.sendMessage({ matchId, ...payload });
},
{
onSuccess: () => {
queryClient.invalidateQueries(['messages', matchId]);
},
}
);
return {
messages: messagesQuery.data,
isLoadingMessages: messagesQuery.isLoading,
isErrorMessages: messagesQuery.isError,
refetchMessages: messagesQuery.refetch,
sendMessage: sendMessageMutation.mutate,
isSending: sendMessageMutation.isLoading,
};
};
// File: app\features\main\hooks\usePlants.ts
export const useUserPlants = (userId: number) => {
return useQuery(['userPlants', userId], () => plantService.getUserPlants(userId), {
enabled: !!userId,
staleTime: 1000 * 60 * 5,
});
};
export const useMyPlants = () => {
const { userId } = useSelector((state: RootState) => state.auth);
return useQuery<PlantResponse[], Error>(
['myPlants', userId],
() => {
if (!userId) throw new Error('User not logged in');
return plantService.getMyPlants();
},
{
enabled: !!userId,
staleTime: 1000 * 60 * 5
}
);
};
// File: app\features\main\hooks\usePreferences.ts
export const useUserPreferences = () => {
const queryClient = useQueryClient();
const query = useQuery<UserPreferencesResponse, Error>(
['userPreferences'],
userPreferencesService.getPreferences,
{
staleTime: 1000 * 60 * 5
}
);
const mutation = useMutation(
(data: UserPreferencesRequest) => userPreferencesService.updatePreferences(data),
{
onSuccess: () => {
queryClient.invalidateQueries(['userPreferences']);
queryClient.invalidateQueries(['likablePlants']);
}
}
);
return {
...query,
updatePreferences: mutation.mutate,
isUpdating: mutation.isLoading
};
};
// File: app\features\main\hooks\useSearchRadius.ts
export const useSearchRadius = () => {
const { data: preferences, isLoading, isError } = useUserPreferences();
return {
searchRadius: preferences?.searchRadius ?? 0,
isLoading,
isError,
};
};
// File: app\features\main\hooks\useSwipe.ts
export const useLikablePlants = () => {
const query = useQuery<PlantResponse[], Error>(
['likablePlants'],
swipeService.getLikablePlants,
{
staleTime: 1000 * 60 * 1,
refetchOnWindowFocus: true,
retry: 1,
}
);
return query;
};
// File: app\features\main\hooks\useUser.ts
export const useUserProfile = () => {
const userId = useSelector((state: RootState) => state.auth.userId);
return useQuery<UserResponse, Error>(
['userProfile', userId],
() => {
if (!userId) {
throw new Error('No userId available');
}
return userService.getUser(userId);
},
{
enabled: !!userId,
staleTime: 1000 * 60 * 5
}
);
};
// File: app\features\main\hooks\useUserMatches.ts
export const useUserMatches = () => {
return useQuery<MatchResponse[]>(
'userMatches',
() => matchService.getMyMatches(),
{
staleTime: 1000 * 60,
}
);
};
// File: app\features\main\screens\AddPlantScreen.tsx
View,
Text,
StyleSheet,
TouchableOpacity,
ScrollView,
Image,
Alert,
TextInput,
ActivityIndicator,
Platform,
} from 'react-native';
PlantCreateRequest,
PlantRequest,
} from '../../../types/apiTypes';
PlantCategory,
PlantStage,
WateringNeed,
LightRequirement,
Size,
IndoorOutdoor,
PropagationEase,
PetFriendly,
Extras,
} from '../../../types/enums';
const SingleSelectTagGroup = <T extends string | number>({
values,
selectedValue,
onSelect,
isRequired,
}: {
values: T[];
selectedValue: T | null;
onSelect: (val: T | null) => void;
isRequired?: boolean;
}) => {
return (
<View style={styles.tagGroupContainer}>
{values.map((val) => {
const isSelected = val === selectedValue;
return (
<TouchableOpacity
key={String(val)}
style={[
styles.singleTag,
isSelected && styles.singleTagSelected,
]}
onPress={() => {
if (isRequired) {
onSelect(val);
} else {
onSelect(isSelected ? null : val);
}
}}
>
<Text
style={[
styles.singleTagText,
isSelected && styles.singleTagTextSelected,
]}
>
{val}
</Text>
</TouchableOpacity>
);
})}
</View>
);
};
const AddPlantScreen: React.FC = () => {
const { t } = useTranslation();
const navigation = useNavigation();
const [speciesName, setSpeciesName] = useState('');
const [stage, setStage] = useState<PlantStage | null>(null);
const [image, setImage] = useState<any>(null);
const queryClient = useQueryClient();
const [category, setCategory] = useState<PlantCategory | null>(null);
const [watering, setWatering] = useState<WateringNeed | null>(null);
const [light, setLight] = useState<LightRequirement | null>(null);
const [size, setSize] = useState<Size | null>(null);
const [indoorOutdoor, setIndoorOutdoor] = useState<IndoorOutdoor | null>(null);
const [propagationEase, setPropagationEase] = useState<PropagationEase | null>(
null
);
const [petFriendly, setPetFriendly] = useState<PetFriendly | null>(null);
const [selectedExtras, setSelectedExtras] = useState<Extras[]>([]);
const [description, setDescription] = useState('');
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const handleSelectImageOption = async () => {
Alert.alert(
t('add_plant_select_image_title'),
t('add_plant_select_image_desc'),
[
{
text: t('add_plant_select_picture_button'),
onPress: pickImageFromLibrary,
},
{
text: t('add_plant_take_picture_button'),
onPress: takePictureWithCamera,
},
{
text: t('add_plant_cancel_button'),
style: 'cancel',
},
]
);
};
const pickImageFromLibrary = async () => {
try {
const result = await ImagePicker.launchImageLibraryAsync({
mediaTypes: ImagePicker.MediaTypeOptions.Images,
allowsEditing: true,
aspect: [3, 4],
quality: 0.7,
});
if (!result.canceled) {
const resized = await resizeImage(result.assets[0].uri);
setImage(resized);
}
} catch (err) {
console.error('pickImageFromLibrary error:', err);
Alert.alert('Error', 'Could not open image library.');
}
};
const takePictureWithCamera = async () => {
try {
const cameraPermission = await ImagePicker.requestCameraPermissionsAsync();
if (!cameraPermission.granted) {
Alert.alert('Error', 'Camera permission denied.');
return;
}
const result = await ImagePicker.launchCameraAsync({
allowsEditing: true,
aspect: [3, 4],
quality: 0.7,
});
if (!result.canceled) {
const resized = await resizeImage(result.assets[0].uri);
setImage(resized);
}
} catch (err) {
console.error('takePictureWithCamera error:', err);
Alert.alert('Error', 'Could not open camera.');
}
};
const resizeImage = async (uri: string) => {
return await ImageManipulator.manipulateAsync(
uri,
[{ resize: { width: 800 } }],
{ compress: 0.7, format: ImageManipulator.SaveFormat.JPEG }
);
};
const handleExtraToggle = (extra: Extras) => {
setSelectedExtras((prev) =>
prev.includes(extra)
? prev.filter((e) => e !== extra)
: [...prev, extra]
);
};
const isExtraSelected = (extra: Extras) => selectedExtras.includes(extra);
const handleCancel = () => {
navigation.goBack();
}
const handleSave = async () => {
if (!speciesName.trim()) {
Alert.alert('Validation Error', 'Species name is required.');
return;
}
if (!stage) {
Alert.alert('Validation Error', 'Plant stage is required.');
return;
}
if (!image) {
Alert.alert('Validation Error', 'An image is required.');
return;
}
setLoading(true);
setError(null);
try {
const plantRequest: PlantRequest = {
speciesName: speciesName.trim(),
plantStage: stage,
description: description.trim() ? description : null,
plantCategory: category,
wateringNeed: watering,
lightRequirement: light,
size: size,
indoorOutdoor: indoorOutdoor,
propagationEase: propagationEase,
petFriendly: petFriendly,
extras: selectedExtras,
};
const photo = {
uri: image.uri,
name: 'plant.jpg',
type: 'image/jpeg',
} as any;
const plantCreateRequest: PlantCreateRequest = {
plantDetails: plantRequest,
image: photo,
};
await plantService.addMyPlant(plantCreateRequest);
queryClient.invalidateQueries('myPlants');
navigation.goBack();
} catch (err) {
console.error('Error adding plant:', err);
setError(t('add_plant_error_message'));
} finally {
setLoading(false);
}
};
return (
<View style={styles.container}>
{}
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={styles.gradientBackground}
>
<View style={styles.headerRow}>
<Text style={styles.headerTitle}>{t('add_plant_title')}</Text>
<MaterialIcons name="local_florist" size={24} color="#fff" />
</View>
<ScrollView
contentContainerStyle={styles.scrollContent}
showsVerticalScrollIndicator={false}
>
<View style={styles.formContainer}>
{error && <Text style={styles.errorText}>{error}</Text>}
{}
<Text style={styles.label}>{t('add_plant_species_name_label')}:</Text>
<TextInput
style={styles.input}
value={speciesName}
onChangeText={setSpeciesName}
placeholder="e.g. Monstera Deliciosa"
/>
{}
<Text style={styles.label}>{t('add_plant_description_label')}:</Text>
<TextInput
style={[styles.input, { height: 80 }]}
value={description}
onChangeText={setDescription}
multiline
/>
{}
<Text style={styles.label}>{t('add_plant_stage_label')}:</Text>
<SingleSelectTagGroup<PlantStage>
values={Object.values(PlantStage)}
selectedValue={stage}
onSelect={(val) => setStage(val)}
isRequired={true}
/>
{}
<Text style={styles.label}>{t('add_plant_category_label')}:</Text>
<SingleSelectTagGroup<PlantCategory>
values={Object.values(PlantCategory)}
selectedValue={category}
onSelect={(val) => {
setCategory(val === category ? null : val);
}}
isRequired={false}
/>
{}
<Text style={styles.label}>{t('add_plant_watering_label')}:</Text>
<SingleSelectTagGroup<WateringNeed>
values={Object.values(WateringNeed)}
selectedValue={watering}
onSelect={(val) => setWatering(val === watering ? null : val)}
/>
{}
<Text style={styles.label}>{t('add_plant_light_label')}:</Text>
<SingleSelectTagGroup<LightRequirement>
values={Object.values(LightRequirement)}
selectedValue={light}
onSelect={(val) => setLight(val === light ? null : val)}
/>
{}
<Text style={styles.label}>{t('add_plant_size_question')}:</Text>
<SingleSelectTagGroup<Size>
values={Object.values(Size)}
selectedValue={size}
onSelect={(val) => setSize(val === size ? null : val)}
/>
{}
<Text style={styles.label}>{t('add_plant_indoor_outdoor_question')}:</Text>
<SingleSelectTagGroup<IndoorOutdoor>
values={Object.values(IndoorOutdoor)}
selectedValue={indoorOutdoor}
onSelect={(val) => setIndoorOutdoor(val === indoorOutdoor ? null : val)}
/>
{}
<Text style={styles.label}>{t('add_plant_propagation_ease_question')}:</Text>
<SingleSelectTagGroup<PropagationEase>
values={Object.values(PropagationEase)}
selectedValue={propagationEase}
onSelect={(val) => setPropagationEase(val === propagationEase ? null : val)}
/>
{}
<Text style={styles.label}>{t('add_plant_pet_friendly_question')}:</Text>
<SingleSelectTagGroup<PetFriendly>
values={Object.values(PetFriendly)}
selectedValue={petFriendly}
onSelect={(val) => setPetFriendly(val === petFriendly ? null : val)}
/>
{}
<Text style={styles.label}>{t('add_plant_extras_question')}:</Text>
<View style={styles.extrasContainer}>
{Object.values(Extras).map((extra) => {
const selected = isExtraSelected(extra);
return (
<TouchableOpacity
key={extra}
style={[
styles.extraTag,
selected && styles.extraTagSelected,
]}
onPress={() => handleExtraToggle(extra)}
>
<Text
style={[
styles.extraTagText,
selected && styles.extraTagTextSelected,
]}
>
{extra}
</Text>
</TouchableOpacity>
);
})}
</View>
{}
<Text style={styles.label}>{t('add_plant_select_image_title')}:</Text>
<TouchableOpacity style={styles.imageButton} onPress={handleSelectImageOption}>
<Ionicons name="image" size={24} color="#fff" />
<Text style={styles.imageButtonText}>
{t('add_plant_select_image_title')}
</Text>
</TouchableOpacity>
{image ? (
<Image source={{ uri: image.uri }} style={styles.previewImage} />
) : (
<Text style={styles.noImageText}>
{t('add_plant_no_image_selected')}
</Text>
)}
{loading && (
<ActivityIndicator
size="small"
color={COLORS.primary}
style={{ marginVertical: 10 }}
/>
)}
{}
<View style={styles.actions}>
<TouchableOpacity
style={styles.cancelButton}
onPress={handleCancel}
>
<Text style={styles.cancelButtonText}>
{t('add_plant_cancel_button')}
</Text>
</TouchableOpacity>
<TouchableOpacity style={styles.saveButton} onPress={handleSave}>
<Text style={styles.saveButtonText}>
{t('add_plant_save_button')}
</Text>
</TouchableOpacity>
</View>
</View>
</ScrollView>
</LinearGradient>
</View>
);
};
export default AddPlantScreen;
const COLORS = {
primary: '#1EAE98',
secondary: '#5EE2C6',
accent: '#FF6F61',
textLight: '#fff',
textDark: '#333',
background: '#f8f8f8',
};
const styles = StyleSheet.create({
container: {
flex: 1,
},
gradientBackground: {
flex: 1,
},
scrollContent: {
paddingTop: 0,
paddingBottom: 30,
},
headerRow: {
position: 'sticky',
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginHorizontal: 20,
marginBottom: 10,
},
headerTitle: {
fontSize: 24,
fontWeight: 'bold',
color: COLORS.textLight,
},
formContainer: {
backgroundColor: '#fff',
marginHorizontal: 20,
borderRadius: 12,
padding: 16,
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
shadowOffset: { width: 0, height: 4 },
},
android: {
elevation: 3,
},
}),
},
errorText: {
color: COLORS.accent,
marginBottom: 10,
fontWeight: '600',
},
label: {
fontSize: 14,
fontWeight: '600',
color: COLORS.textDark,
marginTop: 12,
marginBottom: 4,
},
input: {
borderWidth: 1,
borderColor: '#ccc',
borderRadius: 8,
paddingHorizontal: 10,
paddingVertical: 8,
fontSize: 14,
},
tagGroupContainer: {
flexDirection: 'row',
flexWrap: 'wrap',
marginBottom: 6,
},
singleTag: {
borderWidth: 1,
borderColor: COLORS.primary,
borderRadius: 20,
paddingVertical: 6,
paddingHorizontal: 12,
marginRight: 8,
marginBottom: 8,
},
singleTagSelected: {
backgroundColor: COLORS.primary,
},
singleTagText: {
fontSize: 12,
color: COLORS.primary,
},
singleTagTextSelected: {
color: '#fff',
fontWeight: '600',
},
extrasContainer: {
flexDirection: 'row',
flexWrap: 'wrap',
marginTop: 4,
},
extraTag: {
borderWidth: 1,
borderColor: COLORS.primary,
borderRadius: 20,
paddingVertical: 6,
paddingHorizontal: 12,
marginRight: 8,
marginBottom: 8,
},
extraTagSelected: {
backgroundColor: COLORS.primary,
},
extraTagText: {
fontSize: 12,
color: COLORS.primary,
},
extraTagTextSelected: {
color: '#fff',
fontWeight: '600',
},
imageButton: {
flexDirection: 'row',
alignItems: 'center',
backgroundColor: COLORS.primary,
padding: 10,
borderRadius: 8,
marginTop: 6,
},
imageButtonText: {
fontSize: 14,
color: '#fff',
marginLeft: 6,
fontWeight: '600',
},
previewImage: {
width: '100%',
aspectRatio: 3 / 4,
borderRadius: 8,
marginTop: 6,
marginBottom: 10,
resizeMode: 'cover',
},
noImageText: {
fontSize: 14,
color: '#555',
marginTop: 6,
marginBottom: 10,
},
actions: {
flexDirection: 'row',
justifyContent: 'flex-end',
marginTop: 16,
},
cancelButton: {
borderWidth: 1,
borderColor: COLORS.primary,
borderRadius: 8,
paddingVertical: 10,
paddingHorizontal: 16,
marginRight: 10,
},
cancelButtonText: {
fontSize: 14,
color: COLORS.primary,
fontWeight: '600',
},
saveButton: {
backgroundColor: COLORS.primary,
borderRadius: 8,
paddingVertical: 10,
paddingHorizontal: 16,
},
saveButtonText: {
fontSize: 14,
color: '#fff',
fontWeight: '600',
},
});
// File: app\features\main\screens\ChatScreen.tsx
View,
Text,
StyleSheet,
ActivityIndicator,
TextInput,
TouchableOpacity,
FlatList,
KeyboardAvoidingView,
Platform,
Alert,
} from 'react-native';
const COLORS = {
primary: '#1EAE98',
accent: '#FF6F61',
textDark: '#2F4F4F',
textLight: '#fff',
background: '#F8F8F8',
bubbleLeft: '#fff',
bubbleRight: '#DCF8C6',
};
const ChatScreen: React.FC = () => {
const { t } = useTranslation();
const route = useRoute();
const navigation = useNavigation();
const { otherUserId } = route.params as { otherUserId: number };
const {
data: userProfile,
isLoading: loadingProfile,
isError: errorProfile,
} = useUserProfile();
const {
data: myMatches,
isLoading: loadingMatches,
isError: errorMatches,
} = useUserMatches();
const relevantMatches = useMemo<MatchResponse[]>(() => {
if (!myMatches || !userProfile) return [];
const myUserId = userProfile.userId;
return myMatches.filter((m) => {
return (
(m.user1.userId === myUserId && m.user2.userId === otherUserId) ||
(m.user2.userId === myUserId && m.user1.userId === otherUserId)
);
});
}, [myMatches, userProfile, otherUserId]);
const [activeMatchId, setActiveMatchId] = useState<number | null>(null);
useEffect(() => {
if (relevantMatches.length > 0 && !activeMatchId) {
setActiveMatchId(relevantMatches[0].matchId);
}
}, [relevantMatches, activeMatchId]);
const {
messages,
isLoadingMessages,
isErrorMessages,
refetchMessages,
sendMessage,
isSending,
} = useMatchConversation(activeMatchId ?? 0);
const sortedMessages = useMemo(() => {
if (!messages) return [];
return [...messages].sort(
(a, b) => new Date(a.sentAt).getTime() - new Date(b.sentAt).getTime()
);
}, [messages]);
const flatListRef = useRef<FlatList<MessageResponse>>(null);
useEffect(() => {
if (sortedMessages.length > 0) {
setTimeout(() => {
flatListRef.current?.scrollToEnd({ animated: true });
}, 300);
}
}, [sortedMessages]);
const [inputText, setInputText] = useState('');
const handleSendMessage = useCallback(() => {
if (!inputText.trim()) return;
if (!activeMatchId) {
Alert.alert('Error', 'No active match selected to send messages.');
return;
}
const text = inputText.trim();
setInputText('');
sendMessage(
{ messageText: text },
{
onError: (error) => {
console.error('Error sending message:', error);
Alert.alert('Error', 'Failed to send message');
},
onSuccess: () => {
},
}
);
}, [activeMatchId, inputText, sendMessage]);
const renderTabs = () => {
if (relevantMatches.length <= 1) return null;
return (
<View style={styles.tabContainer}>
{relevantMatches.map((match) => {
const isActive = match.matchId === activeMatchId;
const p1 = match.plant1?.speciesName || 'Plant1';
const p2 = match.plant2?.speciesName || 'Plant2';
const label = `${p1} ↔ ${p2}`;
return (
<TouchableOpacity
key={match.matchId}
onPress={() => setActiveMatchId(match.matchId)}
style={[styles.tabButton, isActive && styles.tabButtonActive]}
>
<Text
style={[styles.tabButtonText, isActive && styles.tabButtonTextActive]}
numberOfLines={1}
>
{label}
</Text>
</TouchableOpacity>
);
})}
</View>
);
};
if (loadingProfile || loadingMatches || (activeMatchId && isLoadingMessages)) {
return (
<SafeAreaProvider style={styles.centerContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loadingText}>{t('chat_loading_conversation')}</Text>
</SafeAreaProvider>
);
}
if (errorProfile || errorMatches || isErrorMessages) {
return (
<SafeAreaProvider style={styles.centerContainer}>
<Text style={styles.errorText}>{t('chat_error_message')}</Text>
<TouchableOpacity style={styles.retryButton} onPress={refetchMessages}>
<Text style={styles.retryButtonText}>{t('chat_retry_button')}</Text>
</TouchableOpacity>
</SafeAreaProvider>
);
}
if (relevantMatches.length === 0) {
return (
<SafeAreaProvider style={styles.centerContainer}>
<Text style={styles.noMessagesText}>{t('chat_no_matches_with_user')}</Text>
</SafeAreaProvider>
);
}
const hasMessages = messages && messages.length > 0;
return (
<SafeAreaProvider style={styles.container}>
{}
<View style={styles.header}>
<TouchableOpacity style={styles.backButton} onPress={() => navigation.goBack()}>
<Ionicons name="chevron-back" size={24} color={COLORS.textLight} />
</TouchableOpacity>
<Text style={styles.headerTitle}>{t('chat_title')}</Text>
</View>
{}
{renderTabs()}
{}
{!hasMessages ? (
<View style={styles.emptyChatContainer}>
<Text style={styles.noMessagesText}>{t('chat_no_messages_yet')}</Text>
</View>
) : (
<FlatList
ref={flatListRef}
data={sortedMessages}
keyExtractor={(item) => item.messageId.toString()}
contentContainerStyle={styles.listContent}
renderItem={({ item }) => {
const isMine = item.senderUserId === userProfile?.userId;
return <MessageBubble message={item} isMine={isMine} />;
}}
/>
)}
{}
<KeyboardAvoidingView
behavior={Platform.OS === 'ios' ? 'padding' : undefined}
keyboardVerticalOffset={10}
>
<View style={styles.inputContainer}>
<TextInput
style={styles.textInput}
value={inputText}
onChangeText={setInputText}
placeholder={t('chat_message_placeholder')}
multiline
/>
{isSending ? (
<ActivityIndicator style={{ marginRight: 12 }} color={COLORS.primary} />
) : (
<TouchableOpacity onPress={handleSendMessage} style={styles.sendButton}>
<Ionicons name="send" size={20} color="#fff" />
</TouchableOpacity>
)}
</View>
</KeyboardAvoidingView>
</SafeAreaProvider>
);
};
interface BubbleProps {
message: MessageResponse;
isMine: boolean;
}
const MessageBubble: React.FC<BubbleProps> = ({ message, isMine }) => {
return (
<View
style={[
styles.bubbleContainer,
isMine ? styles.bubbleRightContainer : styles.bubbleLeftContainer,
]}
>
<View style={[styles.bubble, isMine ? styles.bubbleRight : styles.bubbleLeft]}>
<Text style={styles.bubbleText}>{message.messageText}</Text>
<Text style={styles.timestamp}>
{new Date(message.sentAt).toLocaleTimeString([], {
hour: '2-digit',
minute: '2-digit',
})}
</Text>
</View>
</View>
);
};
export default ChatScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: COLORS.background,
},
centerContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
paddingHorizontal: 20,
},
loadingText: {
fontSize: 16,
color: COLORS.textDark,
marginTop: 10,
textAlign: 'center',
},
errorText: {
fontSize: 16,
color: COLORS.textDark,
marginBottom: 10,
textAlign: 'center',
},
retryButton: {
backgroundColor: COLORS.primary,
borderRadius: 8,
paddingHorizontal: 16,
paddingVertical: 10,
marginTop: 10,
},
retryButtonText: {
color: '#fff',
fontWeight: '600',
},
noMessagesText: {
fontSize: 16,
color: COLORS.textDark,
textAlign: 'center',
},
header: {
flexDirection: 'row',
alignItems: 'center',
backgroundColor: COLORS.primary,
paddingHorizontal: 15,
paddingVertical: 12,
borderBottomLeftRadius: 20,
borderBottomRightRadius: 20,
elevation: 2,
},
backButton: {
marginRight: 10,
},
headerTitle: {
fontSize: 20,
fontWeight: '700',
color: COLORS.textLight,
},
tabContainer: {
flexDirection: 'row',
backgroundColor: '#fff',
marginHorizontal: 10,
marginTop: 10,
borderRadius: 8,
elevation: 2,
overflow: 'hidden',
},
tabButton: {
paddingHorizontal: 12,
paddingVertical: 8,
},
tabButtonActive: {
backgroundColor: COLORS.primary,
},
tabButtonText: {
fontSize: 14,
color: COLORS.primary,
},
tabButtonTextActive: {
color: '#fff',
fontWeight: '600',
},
emptyChatContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
},
listContent: {
padding: 10,
paddingBottom: 60,
},
bubbleContainer: {
marginVertical: 6,
},
bubbleLeftContainer: {
alignSelf: 'flex-start',
},
bubbleRightContainer: {
alignSelf: 'flex-end',
},
bubble: {
maxWidth: '80%',
borderRadius: 8,
paddingHorizontal: 12,
paddingVertical: 8,
},
bubbleLeft: {
backgroundColor: COLORS.bubbleLeft,
borderTopLeftRadius: 0,
},
bubbleRight: {
backgroundColor: COLORS.bubbleRight,
borderTopRightRadius: 0,
},
bubbleText: {
fontSize: 14,
color: '#333',
},
timestamp: {
marginTop: 5,
fontSize: 10,
color: '#777',
textAlign: 'right',
},
inputContainer: {
flexDirection: 'row',
paddingVertical: 8,
paddingHorizontal: 10,
backgroundColor: '#fff',
borderTopWidth: 1,
borderTopColor: '#ddd',
alignItems: 'flex-end',
},
textInput: {
flex: 1,
minHeight: 40,
maxHeight: 100,
backgroundColor: '#f2f2f2',
borderRadius: 20,
paddingHorizontal: 12,
paddingVertical: 8,
marginRight: 8,
fontSize: 14,
},
sendButton: {
backgroundColor: COLORS.primary,
borderRadius: 20,
padding: 10,
},
});
// File: app\features\main\screens\ConnectionsScreen.tsx
View,
Text,
StyleSheet,
ActivityIndicator,
TouchableOpacity,
FlatList,
Image,
Dimensions,
} from 'react-native';
const COLORS = {
primary: '#1EAE98',
background: '#F8F8F8',
textDark: '#2F4F4F',
border: '#ddd',
textLight: '#fff',
accent: '#FF6F61',
};
const { width } = Dimensions.get('window');
const ConnectionsScreen: React.FC = () => {
const { t } = useTranslation();
const navigation = useNavigation();
const {
data: userProfile,
isLoading: loadingProfile,
isError: errorProfile,
} = useUserProfile();
const {
data: matches,
isLoading: loadingMatches,
isError: errorMatches,
refetch: refetchMatches,
} = useUserMatches();
const myUserId = userProfile?.userId;
const groupedConversations = useMemo(() => {
if (!matches || !myUserId) return [];
const map = new Map<number, MatchResponse[]>();
for (const m of matches) {
const otherUserId =
m.user1.userId === myUserId ? m.user2.userId : m.user1.userId;
if (!map.has(otherUserId)) {
map.set(otherUserId, []);
}
map.get(otherUserId)!.push(m);
}
return Array.from(map.entries()).map(([otherUserId, matchList]) => ({
otherUserId,
matchList,
}));
}, [matches, myUserId]);
const handleConversationPress = useCallback(
(otherUserId: number) => {
navigation.navigate('ConversationScreen' as never, { otherUserId } as never);
},
[navigation]
);
if (loadingProfile || loadingMatches) {
return (
<SafeAreaProvider style={styles.centerContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loadingText}>{t('connections_loading')}</Text>
</SafeAreaProvider>
);
}
if (errorProfile || errorMatches) {
return (
<SafeAreaProvider style={styles.centerContainer}>
<Text style={styles.errorText}>{t('connections_error')}</Text>
<TouchableOpacity style={styles.retryButton} onPress={refetchMatches}>
<Text style={styles.retryButtonText}>{t('connections_retry_button')}</Text>
</TouchableOpacity>
</SafeAreaProvider>
);
}
const renderEmptyState = () => {
return (
<View style={styles.emptyStateContainer}>
{}
<Ionicons name="people-outline" size={64} color={COLORS.accent} style={{ marginBottom: 20 }} />
<Text style={styles.emptyStateTitle}>{t('connections_none_title')}</Text>
<Text style={styles.emptyStateMessage}>
{t('connections_none_message')}
</Text>
<TouchableOpacity
style={styles.emptyStateButton}
onPress={() => {
navigation.navigate('SwipeScreen' as never);
}}
>
<Text style={styles.emptyStateButtonText}>
{t('connections_none_action')}
</Text>
</TouchableOpacity>
</View>
);
};
return (
<SafeAreaProvider style={styles.container}>
{}
<View style={styles.header}>
<Text style={styles.headerTitle}>
{t('connections_title', 'Connections')}
</Text>
</View>
{}
{(!groupedConversations || groupedConversations.length === 0) && (
renderEmptyState()
)}
{}
{groupedConversations && groupedConversations.length > 0 && (
<FlatList
data={groupedConversations}
keyExtractor={(item) => item.otherUserId.toString()}
contentContainerStyle={{ paddingBottom: 20 }}
renderItem={({ item }) => {
const { otherUserId, matchList } = item;
const firstMatch = matchList[0];
const isUser1Me = firstMatch.user1.userId === myUserId;
const otherUser: UserResponse = isUser1Me
? firstMatch.user2
: firstMatch.user1;
return (
<TouchableOpacity
style={styles.rowContainer}
onPress={() => handleConversationPress(otherUserId)}
activeOpacity={0.8}
>
<Image
source={
otherUser.profilePictureUrl
? { uri: otherUser.profilePictureUrl }
: require('../../../../assets/images/icon.png')
}
style={styles.avatar}
/>
<View style={styles.textSection}>
<Text style={styles.userName}>{otherUser.name}</Text>
<Text style={styles.matchCount}>
{t('connections_matches_label', { count: matchList.length })}
</Text>
</View>
<Ionicons
name="chevron-forward"
size={24}
color={COLORS.textDark}
/>
</TouchableOpacity>
);
}}
/>
)}
</SafeAreaProvider>
);
};
export default ConnectionsScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: COLORS.background,
},
centerContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
},
loadingText: {
marginTop: 10,
fontSize: 16,
color: COLORS.textDark,
},
errorText: {
fontSize: 16,
color: COLORS.textDark,
marginBottom: 10,
textAlign: 'center',
},
retryButton: {
paddingHorizontal: 16,
paddingVertical: 10,
backgroundColor: COLORS.primary,
borderRadius: 8,
},
retryButtonText: {
color: '#fff',
fontWeight: '600',
},
header: {
paddingHorizontal: 20,
paddingVertical: 15,
backgroundColor: COLORS.primary,
borderBottomLeftRadius: 20,
borderBottomRightRadius: 20,
marginBottom: 10,
elevation: 3,
},
headerTitle: {
fontSize: 22,
fontWeight: '700',
color: COLORS.textLight,
},
rowContainer: {
flexDirection: 'row',
alignItems: 'center',
backgroundColor: '#fff',
marginHorizontal: 10,
marginVertical: 6,
borderRadius: 8,
padding: 10,
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
shadowOffset: { width: 0, height: 2 },
elevation: 2,
},
avatar: {
width: 52,
height: 52,
borderRadius: 26,
marginRight: 12,
backgroundColor: '#eee',
},
textSection: {
flex: 1,
justifyContent: 'center',
},
userName: {
fontSize: 16,
fontWeight: '600',
color: COLORS.textDark,
marginBottom: 4,
},
matchCount: {
fontSize: 14,
color: '#777',
},
emptyStateContainer: {
flex: 1,
alignItems: 'center',
justifyContent: 'center',
paddingHorizontal: 30,
},
emptyStateTitle: {
fontSize: 20,
fontWeight: 'bold',
color: COLORS.textDark,
marginBottom: 8,
textAlign: 'center',
},
emptyStateMessage: {
fontSize: 14,
color: '#555',
textAlign: 'center',
marginBottom: 20,
},
emptyStateButton: {
backgroundColor: COLORS.accent,
paddingHorizontal: 16,
paddingVertical: 10,
borderRadius: 8,
marginTop: 10,
},
emptyStateButtonText: {
color: '#fff',
fontWeight: '600',
fontSize: 14,
},
});
// File: app\features\main\screens\HomeScreen.tsx

// File: app\features\main\screens\MyProfileScreen.tsx
View,
Text,
StyleSheet,
ActivityIndicator,
TouchableOpacity,
Image,
Dimensions,
Platform,
ScrollView,
Alert,
} from 'react-native';
const { width } = Dimensions.get('window');
const COLORS = {
primary: '#1EAE98',
accent: '#FF6F61',
background: '#F2F2F2',
textDark: '#2F4F4F',
textLight: '#FFFFFF',
cardBg: '#FFFFFF',
border: '#ddd',
};
const MyProfileScreen: React.FC = () => {
const { t } = useTranslation();
const navigation = useNavigation();
const {
data: userProfile,
isLoading: loadingProfile,
isError: errorProfile,
refetch: refetchProfile,
} = useUserProfile();
const {
data: myPlants,
isLoading: loadingPlants,
isError: errorPlants,
refetch: refetchPlants,
} = useMyPlants();
const {
searchRadius,
isLoading: srLoading,
isError: srError,
} = useSearchRadius();
const [editProfileVisible, setEditProfileVisible] = useState(false);
const [changeLocationVisible, setChangeLocationVisible] = useState(false);
const [showFullSize, setShowFullSize] = useState(false);
const handleChangeProfilePicture = useCallback(() => {
Alert.alert(
t('profile_change_picture_title'),
t('profile_change_picture_msg'),
[
{ text: t('profile_picture_select_library'), onPress: pickImageFromLibrary },
{ text: t('profile_picture_take_photo'), onPress: takePictureWithCamera },
{ text: t('profile_picture_cancel'), style: 'cancel' },
]
);
}, [t]);
const pickImageFromLibrary = async () => {
try {
const result = await ImagePicker.launchImageLibraryAsync({
mediaTypes: ImagePicker.MediaTypeOptions.Images,
allowsEditing: true,
aspect: [1, 1],
quality: 0.7,
});
if (!result.canceled && result.assets[0].uri) {
const resized = await resizeImage(result.assets[0].uri);
await uploadProfilePicture(resized);
}
} catch (err) {
console.error('pickImageFromLibrary error:', err);
Alert.alert('Error', 'Could not open image library.');
}
};
const takePictureWithCamera = async () => {
try {
const cameraPermission = await ImagePicker.requestCameraPermissionsAsync();
if (!cameraPermission.granted) {
Alert.alert('Error', 'Camera permission denied.');
return;
}
const result = await ImagePicker.launchCameraAsync({
allowsEditing: true,
aspect: [1, 1],
quality: 0.7,
});
if (!result.canceled && result.assets[0].uri) {
const resized = await resizeImage(result.assets[0].uri);
await uploadProfilePicture(resized);
}
} catch (err) {
console.error('takePictureWithCamera error:', err);
Alert.alert('Error', 'Could not open camera.');
}
};
const resizeImage = async (uri: string) => {
return await ImageManipulator.manipulateAsync(
uri,
[{ resize: { width: 800 } }],
{ compress: 0.7, format: ImageManipulator.SaveFormat.JPEG }
);
};
const uploadProfilePicture = async (img: ImageManipulator.ImageResult) => {
try {
const photo = {
uri: img.uri,
name: 'profile.jpg',
type: 'image/jpeg',
} as any;
await userService.updateProfilePicture({ image: photo });
refetchProfile();
} catch (err) {
console.error('Error uploading profile picture:', err);
Alert.alert('Error', 'Profile picture update failed.');
}
};
const handleEditProfile = useCallback(() => {
setEditProfileVisible(true);
}, []);
const handleProfileUpdated = useCallback(() => {
refetchProfile();
}, [refetchProfile]);
const handleChangeLocation = useCallback(() => {
setChangeLocationVisible(true);
}, []);
const handleLocationUpdated = useCallback(() => {
refetchProfile();
}, [refetchProfile]);
const handleAddPlant = useCallback(() => {
navigation.navigate('AddPlant' as never);
}, [navigation]);
const userHasLocation =
userProfile?.locationLatitude !== undefined &&
userProfile?.locationLongitude !== undefined;
const region = userHasLocation
? {
latitude: userProfile.locationLatitude!,
longitude: userProfile.locationLongitude!,
latitudeDelta: 0.05,
longitudeDelta: 0.05,
}
: undefined;
const renderPlantItem = (item: PlantResponse) => {
if (!showFullSize) {
return (
<View key={item.plantId} style={styles.plantCardThumbnail}>
{item.imageUrl ? (
<Image
source={{ uri: item.imageUrl }}
style={styles.thumbImage}
resizeMode="contain"
/>
) : (
<View style={styles.plantPlaceholder}>
<Ionicons name="leaf" size={40} color={COLORS.primary} />
</View>
)}
<View style={styles.thumbTextWrapper}>
<Text style={styles.thumbPlantName} numberOfLines={1}>
{item.speciesName}
</Text>
</View>
</View>
);
} else {
const alltags = [
item.plantStage,
item.plantCategory,
item.wateringNeed,
item.lightRequirement,
item.size,
item.indoorOutdoor,
item.propagationEase,
item.petFriendly,
...(item.extras ?? [])
].filter(Boolean);
return (
<View key={item.plantId} style={styles.plantCardFull}>
<View style={styles.fullImageContainer}>
{item.imageUrl ? (
<Image
source={{ uri: item.imageUrl }}
style={styles.fullImage}
resizeMode="contain"
/>
) : (
<View style={styles.plantPlaceholder}>
<Ionicons name="leaf" size={60} color={COLORS.primary} />
</View>
)}
<View style={styles.fullImageOverlay}>
<LinearGradient
colors={['rgba(0, 0, 0, 0)', 'rgba(0, 0, 0, 1)']}
style={styles.overlayContent}>
<Text style={styles.fullPlantName}>{item.speciesName}</Text>
{alltags.length > 0 && (
<View style={styles.tagRow}>
{alltags.map((tag) => (
<View key={tag} style={styles.tag}>
<Text style={styles.tagText}>{tag}</Text>
</View>
))}
</View>
)}
{item.description ? (
<Text style={styles.fullDescription}>{item.description}</Text>
) : null}
</LinearGradient>
</View>
</View>
</View>
);
}
};
let content: JSX.Element;
if (loadingProfile || loadingPlants || srLoading) {
content = (
<SafeAreaView style={styles.centerContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loadingText}>{t('profile_loading_message')}</Text>
</SafeAreaView>
);
} else if (errorProfile || errorPlants || srError) {
content = (
<SafeAreaView style={styles.centerContainer}>
<Text style={styles.errorText}>{t('profile_error_message')}</Text>
<TouchableOpacity
onPress={() => {
refetchProfile();
refetchPlants();
}}
style={styles.retryButton}
>
<Text style={styles.retryButtonText}>
{t('profile_retry_button')}
</Text>
</TouchableOpacity>
</SafeAreaView>
);
} else if (!userProfile) {
content = (
<SafeAreaView style={styles.centerContainer}>
<Text style={styles.errorText}>
{t('profile_no_user_profile_error')}
</Text>
</SafeAreaView>
);
} else {
content = (
<SafeAreaProvider style={styles.container}>
<ScrollView
style={{ flex: 1 }}
contentContainerStyle={{ paddingBottom: 40 }}>
<LinearGradient
colors={[COLORS.primary, '#5EE2C6']}
style={styles.headerContainer}>
<View style={styles.headerTopRow}>
<Text style={styles.headerTitle}>{userProfile.name}'s {t('profile_title')}</Text>
<TouchableOpacity
onPress={handleEditProfile}
style={styles.headerActionButton}
accessibilityLabel={t('profile_edit_button')}>
<MaterialIcons name="edit" size={24} color={COLORS.textLight} />
</TouchableOpacity>
</View>
{}
<View style={styles.profileInfoContainer}>
<TouchableOpacity
onPress={handleChangeProfilePicture}
activeOpacity={0.8}
style={styles.profilePictureWrapper}>
{userProfile.profilePictureUrl ? (
<Image
source={{ uri: userProfile.profilePictureUrl }}
style={styles.profilePicture}
/>
) : (
<View style={styles.profilePlaceholder}>
<Ionicons name="person-circle-outline" size={90} color="#ccc" />
</View>
)}
<View style={styles.cameraIconWrapper}>
<Ionicons name="camera" size={18} color={COLORS.textLight} />
</View>
</TouchableOpacity>
{userProfile.bio ? (
<Text style={styles.bioText} numberOfLines={50}>
{userProfile.bio}
</Text>
) : (
<Text style={styles.bioPlaceholder} numberOfLines={3}>
{t('profile_no_bio_placeholder')}
</Text>
)}
<View style={styles.locationContainer}>
<Text style={styles.locationLabel}>
{t('profile_location_label')}:
</Text>
{userHasLocation ? (
<View style={styles.mapContainer}>
<MapView
style={styles.map}
initialRegion={region}
scrollEnabled={false}
zoomEnabled={false}
rotateEnabled={false}
pitchEnabled={false}
>
<Circle
center={{
latitude: region.latitude,
longitude: region.longitude,
}}
radius={2000}
strokeWidth={1.5}
strokeColor="rgba(30, 174, 152, 1)"
fillColor="rgba(30, 174, 152, 0.2)"
/>
</MapView>
</View>
) : (
<Text style={styles.noLocationText}>
{t('profile_no_location')}
</Text>
)}
<TouchableOpacity
onPress={handleChangeLocation}
style={styles.locationButton}
accessibilityRole="button"
accessibilityLabel={t('profile_change_location_button')}>
<Ionicons name="location-outline" size={18} color={COLORS.primary} />
<Text style={styles.locationButtonText}>
{t('profile_change_location_button')}
</Text>
</TouchableOpacity>
</View>
</View>
</LinearGradient>
<View style={styles.plantsSectionWrapper}>
<View style={styles.plantsSectionHeader}>
<Text style={styles.plantsSectionTitle}>
{userProfile.name}{t('profile_my_plants_section')}
</Text>
<TouchableOpacity
onPress={handleAddPlant}
style={styles.addPlantButton}
accessibilityRole="button"
accessibilityLabel={t('profile_add_plant_button')}>
<Ionicons name="add-circle" size={24} color={COLORS.primary} />
<Text style={styles.addPlantButtonText}>
{t('profile_add_plant_button')}
</Text>
</TouchableOpacity>
</View>
<View style={styles.viewToggleContainer}>
<TouchableOpacity
onPress={() => setShowFullSize(false)}
style={[
styles.viewToggleOption,
!showFullSize && styles.viewToggleOptionActive,
]}
activeOpacity={0.9}>
<Text
style={[
styles.viewToggleText,
!showFullSize && styles.viewToggleTextActive,
]}>
{t('Thumbnails')}
</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => setShowFullSize(true)}
style={[
styles.viewToggleOption,
showFullSize && styles.viewToggleOptionActive,
]}
activeOpacity={0.9}>
<Text
style={[
styles.viewToggleText,
showFullSize && styles.viewToggleTextActive,
]}>
{t('Full Size')}
</Text>
</TouchableOpacity>
</View>
{myPlants && myPlants.length > 0 ? (
<View
style={[
showFullSize
? styles.fullViewContainer
: styles.thumbViewContainer,
]}>
{myPlants.map((plant) => renderPlantItem(plant))}
</View>
) : (
<View style={styles.noPlantsContainer}>
<Text style={styles.noPlantsText}>
{t('profile_no_plants_message')}
</Text>
</View>
)}
</View>
<EditProfileModal
visible={editProfileVisible}
initialName={userProfile.name}
initialBio={userProfile.bio || ''}
onClose={() => setEditProfileVisible(false)}
onUpdated={handleProfileUpdated}
/>
<ChangeLocationModal
visible={changeLocationVisible}
initialLatitude={userProfile.locationLatitude}
initialLongitude={userProfile.locationLongitude}
onClose={() => setChangeLocationVisible(false)}
onUpdated={handleLocationUpdated}
/>
</ScrollView>
</SafeAreaProvider>
);
}
return content;
};
export default MyProfileScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: COLORS.background,
},
centerContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
padding: 20,
},
loadingText: {
fontSize: 16,
color: COLORS.textDark,
marginTop: 10,
},
errorText: {
fontSize: 16,
color: COLORS.textDark,
marginBottom: 20,
textAlign: 'center',
},
retryButton: {
backgroundColor: COLORS.primary,
paddingVertical: 10,
paddingHorizontal: 20,
borderRadius: 8,
},
retryButtonText: {
color: '#fff',
fontSize: 16,
fontWeight: '600',
},
headerContainer: {
paddingHorizontal: 20,
paddingVertical: 20,
borderBottomLeftRadius: 20,
borderBottomRightRadius: 20,
marginBottom: 10,
},
headerTopRow: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
},
headerTitle: {
fontSize: 24,
fontWeight: '700',
color: COLORS.textLight,
},
headerActionButton: {
padding: 8,
},
profileInfoContainer: {
alignItems: 'center',
marginTop: 15,
marginHorizontal: 20,
},
profilePictureWrapper: {
position: 'relative',
marginBottom: 10,
},
profilePicture: {
width: (width - 100) / 2,
height: (width - 100) / 2,
borderRadius: (width - 100) / 4,
backgroundColor: '#eee',
borderWidth: 2,
borderColor: '#fff',
},
profilePlaceholder: {
width: (width - 100) / 2,
height: (width - 100) / 2,
borderRadius: (width - 100) / 4,
backgroundColor: '#eee',
alignItems: 'center',
justifyContent: 'center',
borderWidth: 2,
borderColor: '#fff',
},
cameraIconWrapper: {
position: 'absolute',
bottom: 0,
right: 10,
backgroundColor: COLORS.primary,
borderRadius: 16,
padding: 4,
},
bioText: {
fontSize: 14,
color: COLORS.textLight,
textAlign: 'center',
marginVertical: 10,
lineHeight: 20,
},
bioPlaceholder: {
fontSize: 14,
color: COLORS.textLight,
fontStyle: 'italic',
textAlign: 'center',
marginVertical: 10,
lineHeight: 20,
},
locationContainer: {
width: '100%',
alignItems: 'center',
marginTop: 15,
},
locationLabel: {
fontSize: 16,
fontWeight: '600',
color: COLORS.textLight,
marginBottom: 8,
},
mapContainer: {
width: '100%',
height: (width - 40) / 2,
borderRadius: 8,
overflow: 'hidden',
backgroundColor: '#ddd',
marginBottom: 10,
},
map: {
...StyleSheet.absoluteFillObject,
},
noLocationText: {
fontSize: 14,
color: COLORS.textLight,
marginBottom: 10,
},
locationButton: {
flexDirection: 'row',
alignItems: 'center',
paddingHorizontal: 10,
paddingVertical: 6,
borderWidth: 1,
borderColor: COLORS.primary,
borderRadius: 8,
backgroundColor: '#fff',
marginTop: 10,
},
locationButtonText: {
color: COLORS.primary,
fontSize: 14,
marginLeft: 5,
fontWeight: '600',
},
plantsSectionWrapper: {
paddingHorizontal: 10,
paddingTop: 10,
},
plantsSectionHeader: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginBottom: 10,
paddingHorizontal: 10,
},
plantsSectionTitle: {
fontSize: 20,
fontWeight: '700',
color: COLORS.textDark,
},
addPlantButton: {
flexDirection: 'row',
alignItems: 'center',
},
addPlantButtonText: {
fontSize: 14,
color: COLORS.primary,
marginLeft: 5,
fontWeight: '600',
},
viewToggleContainer: {
flexDirection: 'row',
alignSelf: 'center',
borderColor: COLORS.border,
borderWidth: 1,
borderRadius: 20,
overflow: 'hidden',
marginBottom: 12,
},
viewToggleOption: {
paddingVertical: 8,
paddingHorizontal: 20,
backgroundColor: '#fff',
},
viewToggleOptionActive: {
backgroundColor: COLORS.primary,
},
viewToggleText: {
fontSize: 14,
color: COLORS.textDark,
fontWeight: '600',
},
viewToggleTextActive: {
color: '#fff',
},
thumbViewContainer: {
flexDirection: 'row',
flexWrap: 'wrap',
justifyContent: 'space-between',
},
plantCardThumbnail: {
width: (width - 50) / 3,
backgroundColor: COLORS.cardBg,
borderRadius: 8,
marginBottom: 15,
overflow: 'hidden',
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
},
android: {
elevation: 3,
},
}),
},
thumbImage: {
width: '100%',
aspectRatio: 3 / 4,
},
plantPlaceholder: {
width: '100%',
height: 120,
backgroundColor: '#eee',
justifyContent: 'center',
alignItems: 'center',
},
thumbTextWrapper: {
padding: 8,
alignItems: 'center',
},
thumbPlantName: {
fontSize: 14,
fontWeight: '600',
color: COLORS.textDark,
},
fullViewContainer: {
width: '100%',
},
plantCardFull: {
marginBottom: 15,
width: '100%',
borderRadius: 8,
overflow: 'hidden',
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.12,
shadowRadius: 5,
shadowOffset: { width: 0, height: 3 },
},
android: {
elevation: 3,
},
}),
},
fullImageContainer: {
width: '100%',
position: 'relative',
},
fullImage: {
width: '100%',
aspectRatio: 3 / 4,
},
fullImageOverlay: {
...StyleSheet.absoluteFillObject,
justifyContent: 'flex-end',
},
overlayContent: {
padding: 10,
paddingTop: 100,
},
fullPlantName: {
fontSize: 18,
fontWeight: '700',
color: '#fff',
marginBottom: 6,
},
tagRow: {
flexDirection: 'row',
flexWrap: 'wrap',
marginBottom: 6,
},
tag: {
backgroundColor: COLORS.primary,
borderRadius: 12,
paddingHorizontal: 8,
paddingVertical: 4,
marginRight: 6,
marginBottom: 6,
},
tagText: {
color: '#fff',
fontSize: 12,
fontWeight: '600',
},
fullDescription: {
color: '#fff',
fontSize: 14,
fontWeight: '400',
},
noPlantsContainer: {
justifyContent: 'center',
alignItems: 'center',
padding: 20,
},
noPlantsText: {
fontSize: 16,
color: '#555',
textAlign: 'center',
},
});
// File: app\features\main\screens\SettingsScreen.tsx
View,
Text,
StyleSheet,
TouchableOpacity,
Switch,
ScrollView,
Alert,
ActivityIndicator,
TextInput,
} from 'react-native';
const COLORS = {
primary: '#1EAE98',
secondary: '#5EE2C6',
background: '#F2F2F2',
textLight: '#FFFFFF',
textDark: '#333333',
accent: '#FF6F61',
};
const SettingsScreen: React.FC = () => {
const { t, i18n } = useTranslation();
const navigation = useNavigation();
const {
data: userProfile,
isLoading: userLoading,
refetch: refetchUserProfile,
} = useUserProfile();
const {
searchRadius,
setSearchRadius,
isLoading: srLoading,
isError: srError,
} = useSearchRadius();
const [currentLang, setCurrentLang] = useState(i18n.language);
const [pushNotificationsEnabled, setPushNotificationsEnabled] = useState<boolean>(true);
const [darkModeEnabled, setDarkModeEnabled] = useState<boolean>(false);
const [newEmail, setNewEmail] = useState<string>('');
const [newPassword, setNewPassword] = useState<string>('');
const [isUpdatingEmail, setIsUpdatingEmail] = useState<boolean>(false);
const [isUpdatingPassword, setIsUpdatingPassword] = useState<boolean>(false);
const [saving, setSaving] = useState<boolean>(false);
const handleLanguageChange = async (lang: string) => {
await i18n.changeLanguage(lang);
await storage.saveLanguage(lang);
setCurrentLang(lang);
};
const handleChangeEmail = async () => {
if (!newEmail.trim()) {
Alert.alert('Validation Error', t('Please enter a valid email.'));
return;
}
setSaving(true);
try {
await userService.updateProfile({ email: newEmail });
Alert.alert(t('Email changed successfully!'));
setNewEmail('');
refetchUserProfile();
} catch (err) {
console.error('Failed to change email:', err);
Alert.alert(t('Error'), t('Could not change email.'));
} finally {
setSaving(false);
setIsUpdatingEmail(false);
}
};
const handleChangePassword = async () => {
if (!newPassword.trim()) {
Alert.alert('Validation Error', t('Please enter a valid password.'));
return;
}
setSaving(true);
try {
await userService.updateProfile({ password: newPassword });
Alert.alert(t('Password changed successfully!'));
setNewPassword('');
refetchUserProfile();
} catch (err) {
console.error('Failed to change password:', err);
Alert.alert(t('Error'), t('Could not change password.'));
} finally {
setSaving(false);
setIsUpdatingPassword(false);
}
};
const handleLogout = async () => {
Alert.alert(
t('Logout'),
t('Are you sure you want to log out?'),
[
{ text: t('Cancel'), style: 'cancel' },
{
text: t('Yes'),
style: 'destructive',
onPress: async () => store.dispatch(logout())
},
]
);
};
const handleDeleteAccount = async () => {
Alert.alert(
t('Delete Account'),
t('This action cannot be undone. Are you sure?'),
[
{ text: t('Cancel'), style: 'cancel' },
{
text: t('Yes, Delete'),
style: 'destructive',
onPress: async () => {
try {
navigation.reset({
index: 0,
routes: [{ name: 'AuthNavigator' as never }],
});
} catch (err) {
console.error('Failed to delete account:', err);
Alert.alert(t('Error'), t('Could not delete account.'));
}
},
},
]
);
};
const handleSaveNotificationSettings = async (value: boolean) => {
setPushNotificationsEnabled(value);
};
const handleSaveDarkMode = async (value: boolean) => {
setDarkModeEnabled(value);
};
const handleSearchRadiusChange = async (val: number) => {
setSearchRadius(val);
};
if (userLoading || srLoading) {
return (
<View style={styles.centered}>
<ActivityIndicator size="large" color={COLORS.primary} />
</View>
);
}
return (
<SafeAreaProvider style={styles.safeArea}>
<LinearGradient
colors={[COLORS.primary, COLORS.secondary]}
style={styles.gradientHeader}
>
<View style={styles.headerRow}>
<Text style={styles.headerTitle}>{t('Settings')}</Text>
<MaterialIcons name="settings" size={24} color="#fff" />
</View>
</LinearGradient>
<ScrollView contentContainerStyle={styles.scrollContent}>
{}
<View style={styles.section}>
<Text style={styles.sectionTitle}>{t('Account')}</Text>
{}
<Text style={styles.label}>{t('Email')}:</Text>
<Text style={styles.value}>
{userProfile?.email || t('No email found')}
</Text>
{isUpdatingEmail ? (
<View style={styles.changeContainer}>
<TextInput
style={styles.input}
placeholder={t('New email')}
onChangeText={setNewEmail}
value={newEmail}
keyboardType="email-address"
autoCapitalize="none"
/>
<View style={styles.buttonRow}>
<TouchableOpacity
style={[styles.smallButton, styles.cancelBtn]}
onPress={() => {
setIsUpdatingEmail(false);
setNewEmail('');
}}
>
<Text style={styles.smallButtonText}>{t('Cancel')}</Text>
</TouchableOpacity>
<TouchableOpacity
style={[styles.smallButton, styles.confirmBtn]}
onPress={handleChangeEmail}
disabled={saving}
>
{saving ? (
<ActivityIndicator size="small" color="#fff" />
) : (
<Text style={styles.smallButtonText}>{t('Save')}</Text>
)}
</TouchableOpacity>
</View>
</View>
) : (
<TouchableOpacity
style={styles.changeButton}
onPress={() => setIsUpdatingEmail(true)}
>
<Text style={styles.changeButtonText}>{t('Change email')}</Text>
</TouchableOpacity>
)}
{}
{isUpdatingPassword ? (
<>
<Text style={[styles.label, { marginTop: 10 }]}>
{t('New Password')}:
</Text>
<View style={styles.changeContainer}>
<TextInput
style={styles.input}
placeholder={t('Enter new password')}
onChangeText={setNewPassword}
value={newPassword}
secureTextEntry
autoCapitalize="none"
/>
<View style={styles.buttonRow}>
<TouchableOpacity
style={[styles.smallButton, styles.cancelBtn]}
onPress={() => {
setIsUpdatingPassword(false);
setNewPassword('');
}}
>
<Text style={styles.smallButtonText}>{t('Cancel')}</Text>
</TouchableOpacity>
<TouchableOpacity
style={[styles.smallButton, styles.confirmBtn]}
onPress={handleChangePassword}
disabled={saving}
>
{saving ? (
<ActivityIndicator size="small" color="#fff" />
) : (
<Text style={styles.smallButtonText}>{t('Save')}</Text>
)}
</TouchableOpacity>
</View>
</View>
</>
) : (
<TouchableOpacity
style={styles.changeButton}
onPress={() => setIsUpdatingPassword(true)}
>
<Text style={styles.changeButtonText}>{t('Change password')}</Text>
</TouchableOpacity>
)}
{}
<TouchableOpacity
style={styles.logoutButton}
onPress={handleLogout}
>
<Ionicons name="log-out-outline" size={18} color="#fff" />
<Text style={styles.logoutButtonText}>{t('Log Out')}</Text>
</TouchableOpacity>
{}
<TouchableOpacity
style={styles.deleteButton}
onPress={handleDeleteAccount}
>
<Ionicons name="trash-outline" size={18} color="#fff" />
<Text style={styles.deleteButtonText}>{t('Delete Account')}</Text>
</TouchableOpacity>
</View>
{}
<View style={styles.section}>
<Text style={styles.sectionTitle}>{t('Language')}</Text>
<Text style={styles.label}>
{t('Selected Language')}: {currentLang.toUpperCase()}
</Text>
<View style={styles.langButtons}>
<TouchableOpacity
onPress={() => handleLanguageChange('en')}
style={[
styles.langButton,
currentLang === 'en' && styles.langButtonSelected,
]}
>
<Text
style={[
styles.langButtonText,
currentLang === 'en' && styles.langButtonTextSelected,
]}
>
English
</Text>
</TouchableOpacity>
<TouchableOpacity
onPress={() => handleLanguageChange('fr')}
style={[
styles.langButton,
currentLang === 'fr' && styles.langButtonSelected,
]}
>
<Text
style={[
styles.langButtonText,
currentLang === 'fr' && styles.langButtonTextSelected,
]}
>
Français
</Text>
</TouchableOpacity>
</View>
</View>
{}
<View style={styles.section}>
<Text style={styles.sectionTitle}>{t('Notifications')}</Text>
<View style={styles.toggleRow}>
<Text style={styles.toggleLabel}>{t('Push Notifications')}</Text>
<Switch
value={pushNotificationsEnabled}
onValueChange={(val) => {
setPushNotificationsEnabled(val);
handleSaveNotificationSettings(val);
}}
thumbColor={pushNotificationsEnabled ? COLORS.primary : '#ccc'}
trackColor={{ true: COLORS.primary, false: '#ddd' }}
/>
</View>
{}
</View>
{}
<View style={styles.section}>
<Text style={styles.sectionTitle}>{t('Appearance')}</Text>
<View style={styles.toggleRow}>
<Text style={styles.toggleLabel}>{t('Dark Mode')}</Text>
<Switch
value={darkModeEnabled}
onValueChange={(val) => {
setDarkModeEnabled(val);
handleSaveDarkMode(val);
}}
thumbColor={darkModeEnabled ? COLORS.primary : '#ccc'}
trackColor={{ true: COLORS.primary, false: '#ddd' }}
/>
</View>
</View>
{}
<View style={styles.section}>
<Text style={styles.sectionTitle}>{t('Location & Search')}</Text>
<TouchableOpacity
style={styles.changeButton}
onPress={() => {
navigation.navigate('ChangeLocationModal' as never);
}}
>
<Text style={styles.changeButtonText}>
{t('Change Approximate Location')}
</Text>
</TouchableOpacity>
<View style={{ marginTop: 10 }}>
<Text style={styles.label}>{t('Search Radius')} (km)</Text>
<Slider
style={{ width: '100%', height: 40 }}
minimumValue={1}
maximumValue={100}
step={1}
value={searchRadius}
minimumTrackTintColor={COLORS.primary}
maximumTrackTintColor="#ccc"
onSlidingComplete={handleSearchRadiusChange}
/>
<Text style={styles.value}>
{searchRadius} {t('km')}
</Text>
</View>
</View>
{}
{}
{}
<View style={{ height: 40 }} />
</ScrollView>
</SafeAreaProvider>
);
};
export default SettingsScreen;
const styles = StyleSheet.create({
safeArea: {
flex: 1,
backgroundColor: COLORS.background,
},
gradientHeader: {
paddingHorizontal: 20,
paddingVertical: 16,
borderBottomLeftRadius: 20,
borderBottomRightRadius: 20,
marginBottom: 10,
},
headerRow: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
},
headerTitle: {
fontSize: 24,
fontWeight: '700',
color: '#fff',
},
scrollContent: {
paddingBottom: 40,
paddingHorizontal: 20,
},
section: {
backgroundColor: '#fff',
borderRadius: 12,
padding: 16,
marginBottom: 12,
},
sectionTitle: {
fontSize: 18,
color: COLORS.textDark,
fontWeight: '600',
marginBottom: 10,
},
label: {
fontSize: 14,
color: COLORS.textDark,
fontWeight: '600',
marginBottom: 4,
},
value: {
fontSize: 14,
color: '#555',
marginBottom: 6,
},
langButtons: {
flexDirection: 'row',
marginTop: 8,
},
langButton: {
paddingVertical: 8,
paddingHorizontal: 12,
borderWidth: 1,
borderColor: COLORS.primary,
borderRadius: 20,
marginRight: 10,
},
langButtonSelected: {
backgroundColor: COLORS.primary,
},
langButtonText: {
fontSize: 14,
color: COLORS.primary,
},
langButtonTextSelected: {
color: '#fff',
fontWeight: '600',
},
toggleRow: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginVertical: 8,
},
toggleLabel: {
fontSize: 14,
color: COLORS.textDark,
},
changeButton: {
borderWidth: 1,
borderColor: COLORS.primary,
borderRadius: 8,
paddingVertical: 8,
paddingHorizontal: 12,
alignSelf: 'flex-start',
marginTop: 6,
},
changeButtonText: {
color: COLORS.primary,
fontSize: 14,
fontWeight: '600',
},
changeContainer: {
marginVertical: 8,
},
input: {
borderWidth: 1,
borderColor: '#ccc',
borderRadius: 8,
paddingHorizontal: 10,
paddingVertical: 6,
marginBottom: 6,
fontSize: 14,
},
buttonRow: {
flexDirection: 'row',
justifyContent: 'flex-end',
},
smallButton: {
borderRadius: 8,
paddingVertical: 8,
paddingHorizontal: 12,
marginLeft: 10,
},
cancelBtn: {
borderWidth: 1,
borderColor: COLORS.primary,
},
confirmBtn: {
backgroundColor: COLORS.primary,
},
smallButtonText: {
fontSize: 14,
fontWeight: '600',
color: '#fff',
},
logoutButton: {
flexDirection: 'row',
alignItems: 'center',
backgroundColor: COLORS.primary,
borderRadius: 8,
paddingVertical: 8,
paddingHorizontal: 12,
marginTop: 12,
},
logoutButtonText: {
marginLeft: 6,
fontSize: 14,
color: '#fff',
fontWeight: '600',
},
deleteButton: {
flexDirection: 'row',
alignItems: 'center',
backgroundColor: COLORS.accent,
borderRadius: 8,
paddingVertical: 8,
paddingHorizontal: 12,
marginTop: 12,
},
deleteButtonText: {
marginLeft: 6,
fontSize: 14,
color: '#fff',
fontWeight: '600',
},
centered: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
},
});
// File: app\features\main\screens\SetUserPreferencesScreen.tsx
View,
Text,
StyleSheet,
TouchableOpacity,
ScrollView,
ActivityIndicator,
Platform,
} from 'react-native';
PlantStage,
PlantCategory,
WateringNeed,
LightRequirement,
Size,
IndoorOutdoor,
PropagationEase,
PetFriendly,
Extras,
} from '../../../types/enums';
const MultiSelectTagGroup = <T extends string>({
values,
selectedValues,
onToggle,
}: {
values: T[];
selectedValues: T[];
onToggle: (val: T) => void;
}) => {
return (
<View style={styles.tagGroupContainer}>
{values.map((val) => {
const isSelected = selectedValues.includes(val);
return (
<TouchableOpacity
key={String(val)}
style={[
styles.singleTag,
isSelected && styles.singleTagSelected,
]}
onPress={() => onToggle(val)}
>
<Text
style={[
styles.singleTagText,
isSelected && styles.singleTagTextSelected,
]}
>
{val}
</Text>
</TouchableOpacity>
);
})}
</View>
);
};
const SetUserPreferencesScreen: React.FC = () => {
const navigation = useNavigation();
const {
data: preferences,
isLoading,
isError,
updatePreferences,
isUpdating,
} = useUserPreferences();
const [selectedStages, setSelectedStages] = useState<PlantStage[]>([]);
const [selectedCategories, setSelectedCategories] = useState<PlantCategory[]>([]);
const [selectedWatering, setSelectedWatering] = useState<WateringNeed[]>([]);
const [selectedLightReq, setSelectedLightReq] = useState<LightRequirement[]>([]);
const [selectedSize, setSelectedSize] = useState<Size[]>([]);
const [selectedIndoorOutdoor, setSelectedIndoorOutdoor] = useState<IndoorOutdoor[]>([]);
const [selectedPropagationEase, setSelectedPropagationEase] = useState<PropagationEase[]>([]);
const [selectedPetFriendly, setSelectedPetFriendly] = useState<PetFriendly[]>([]);
const [selectedExtras, setSelectedExtras] = useState<Extras[]>([]);
const [error, setError] = useState<string | null>(null);
useEffect(() => {
if (preferences) {
setSelectedStages(preferences.preferedPlantStage || []);
setSelectedCategories(preferences.preferedPlantCategory || []);
setSelectedWatering(preferences.preferedWateringNeed || []);
setSelectedLightReq(preferences.preferedLightRequirement || []);
setSelectedSize(preferences.preferedSize || []);
setSelectedIndoorOutdoor(preferences.preferedIndoorOutdoor || []);
setSelectedPropagationEase(preferences.preferedPropagationEase || []);
setSelectedPetFriendly(preferences.preferedPetFriendly || []);
setSelectedExtras(preferences.preferedExtras || []);
}
}, [preferences]);
const handleToggle = <T extends string>(
value: T,
selectedList: T[],
setList: React.Dispatch<React.SetStateAction<T[]>>
) => {
if (selectedList.includes(value)) {
setList(selectedList.filter((v) => v !== value));
} else {
setList([...selectedList, value]);
}
};
const handleCancel = () => {
navigation.goBack();
};
const handleSave = async () => {
if (!preferences) return;
setError(null);
const updated: UserPreferencesRequest = {
...preferences,
preferedPlantStage: selectedStages,
preferedPlantCategory: selectedCategories,
preferedWateringNeed: selectedWatering,
preferedLightRequirement: selectedLightReq,
preferedSize: selectedSize,
preferedIndoorOutdoor: selectedIndoorOutdoor,
preferedPropagationEase: selectedPropagationEase,
preferedPetFriendly: selectedPetFriendly,
preferedExtras: selectedExtras,
};
try {
await updatePreferences(updated);
navigation.goBack();
} catch (err) {
console.error('Error updating preferences:', err);
setError('Could not update preferences.');
}
};
if (isLoading) {
return (
<View style={styles.center}>
<Text>Loading preferences...</Text>
</View>
);
}
if (isError || !preferences) {
return (
<View style={styles.center}>
<Text>Error loading preferences</Text>
</View>
);
}
return (
<View style={styles.container}>
{}
<LinearGradient
colors={[LOCAL_COLORS.primary, LOCAL_COLORS.secondary]}
style={styles.gradientBackground}
>
{}
<View style={styles.headerRow}>
<Text style={styles.headerTitle}>User Preferences</Text>
<MaterialIcons name="settings" size={24} color="#fff" />
</View>
<ScrollView
contentContainerStyle={styles.scrollContent}
showsVerticalScrollIndicator={false}
>
<View style={styles.formContainer}>
{}
{error && <Text style={styles.errorText}>{error}</Text>}
{}
{}
<Text style={styles.label}>Preferred Plant Stages:</Text>
<MultiSelectTagGroup
values={Object.values(PlantStage)}
selectedValues={selectedStages}
onToggle={(val) =>
handleToggle(val, selectedStages, setSelectedStages)
}
/>
{}
<Text style={styles.label}>Preferred Categories:</Text>
<MultiSelectTagGroup
values={Object.values(PlantCategory)}
selectedValues={selectedCategories}
onToggle={(val) =>
handleToggle(val, selectedCategories, setSelectedCategories)
}
/>
{}
<Text style={styles.label}>Watering Need:</Text>
<MultiSelectTagGroup
values={Object.values(WateringNeed)}
selectedValues={selectedWatering}
onToggle={(val) =>
handleToggle(val, selectedWatering, setSelectedWatering)
}
/>
{}
<Text style={styles.label}>Light Requirement:</Text>
<MultiSelectTagGroup
values={Object.values(LightRequirement)}
selectedValues={selectedLightReq}
onToggle={(val) =>
handleToggle(val, selectedLightReq, setSelectedLightReq)
}
/>
{}
<Text style={styles.label}>Size:</Text>
<MultiSelectTagGroup
values={Object.values(Size)}
selectedValues={selectedSize}
onToggle={(val) =>
handleToggle(val, selectedSize, setSelectedSize)
}
/>
{}
<Text style={styles.label}>Indoor/Outdoor:</Text>
<MultiSelectTagGroup
values={Object.values(IndoorOutdoor)}
selectedValues={selectedIndoorOutdoor}
onToggle={(val) =>
handleToggle(val, selectedIndoorOutdoor, setSelectedIndoorOutdoor)
}
/>
{}
<Text style={styles.label}>Propagation Ease:</Text>
<MultiSelectTagGroup
values={Object.values(PropagationEase)}
selectedValues={selectedPropagationEase}
onToggle={(val) =>
handleToggle(val, selectedPropagationEase, setSelectedPropagationEase)
}
/>
{}
<Text style={styles.label}>Pet Friendly:</Text>
<MultiSelectTagGroup
values={Object.values(PetFriendly)}
selectedValues={selectedPetFriendly}
onToggle={(val) =>
handleToggle(val, selectedPetFriendly, setSelectedPetFriendly)
}
/>
{}
<Text style={styles.label}>Extras:</Text>
<MultiSelectTagGroup
values={Object.values(Extras)}
selectedValues={selectedExtras}
onToggle={(val) =>
handleToggle(val, selectedExtras, setSelectedExtras)
}
/>
{}
{isUpdating && (
<ActivityIndicator
size="small"
color={LOCAL_COLORS.primary}
style={{ marginVertical: 10 }}
/>
)}
{}
<View style={styles.actions}>
<TouchableOpacity style={styles.saveButton} onPress={handleSave} disabled={isUpdating}>
<Text style={styles.saveButtonText}>
{isUpdating ? 'Saving...' : 'Save'}
</Text>
</TouchableOpacity>
<TouchableOpacity
style={styles.cancelButton}
onPress={handleCancel}
>
<Text style={styles.cancelButtonText}>Cancel</Text>
</TouchableOpacity>
</View>
</View>
</ScrollView>
</LinearGradient>
</View>
);
};
export default SetUserPreferencesScreen;
const LOCAL_COLORS = {
primary: '#1EAE98',
secondary: '#5EE2C6',
};
const styles = StyleSheet.create({
container: {
flex: 1,
},
gradientBackground: {
flex: 1,
},
scrollContent: {
paddingTop: 0,
paddingBottom: 30,
},
headerRow: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
marginHorizontal: 20,
marginBottom: 10,
},
headerTitle: {
fontSize: 24,
fontWeight: 'bold',
color: '#fff',
},
formContainer: {
backgroundColor: '#fff',
marginHorizontal: 20,
borderRadius: 12,
padding: 16,
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.1,
shadowRadius: 5,
shadowOffset: { width: 0, height: 4 },
},
android: {
elevation: 3,
},
}),
},
label: {
fontSize: 14,
fontWeight: '600',
color: '#333',
marginTop: 12,
marginBottom: 6,
},
errorText: {
color: '#FF6F61',
marginBottom: 10,
fontWeight: '600',
},
tagGroupContainer: {
flexDirection: 'row',
flexWrap: 'wrap',
marginBottom: 6,
},
singleTag: {
borderWidth: 1,
borderColor: LOCAL_COLORS.primary,
borderRadius: 20,
paddingVertical: 6,
paddingHorizontal: 12,
marginRight: 8,
marginBottom: 8,
},
singleTagSelected: {
backgroundColor: LOCAL_COLORS.primary,
},
singleTagText: {
fontSize: 12,
color: LOCAL_COLORS.primary,
fontWeight: '600',
},
singleTagTextSelected: {
color: '#fff',
},
actions: {
flexDirection: 'column',
justifyContent: 'flex-end',
marginTop: 16,
},
cancelButton: {
borderWidth: 1,
borderColor: LOCAL_COLORS.primary,
borderRadius: 8,
paddingVertical: 10,
paddingHorizontal: 16,
margin: 10,
marginTop: 0,
},
cancelButtonText: {
fontSize: 14,
color: LOCAL_COLORS.primary,
fontWeight: '600',
textAlign: 'center',
},
saveButton: {
backgroundColor: LOCAL_COLORS.primary,
borderRadius: 8,
paddingVertical: 10,
paddingHorizontal: 16,
margin: 10,
},
saveButtonText: {
fontSize: 14,
color: '#fff',
fontWeight: '600',
textAlign: 'center',
},
center: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
},
});
// File: app\features\main\screens\SwipeScreen.tsx
StyleSheet,
View,
Text,
TouchableOpacity,
ActivityIndicator,
Alert,
SafeAreaView,
FlatList,
Dimensions,
Platform,
} from 'react-native';
const { width } = Dimensions.get('window');
const COLORS = {
primary: '#1EAE98',
primaryLight: '#5EE2C6',
accent: '#FF6B6B',
accentLight: '#FF9F9F',
background: '#f8f8f8',
textDark: '#333',
textLight: '#fff',
border: '#ddd',
};
interface SwipeScreenProps {}
const SwipeScreen: React.FC<SwipeScreenProps> = () => {
const navigation = useNavigation();
const {
data: likablePlants,
isLoading: loadingPlants,
isError: errorPlants,
refetch: refetchLikablePlants,
} = useLikablePlants();
const { data: userProfile } = useUserProfile();
const {
data: userPreferences,
updatePreferences,
isUpdating: updatingPrefs,
} = useUserPreferences();
const {
data: myPlants,
isLoading: loadingMyPlants,
isError: errorMyPlants,
refetch: refetchMyPlants,
} = useMyPlants();
const [plantStack, setPlantStack] = useState<PlantResponse[]>([]);
const [showSelectModal, setShowSelectModal] = useState(false);
const [plantToLike, setPlantToLike] = useState<PlantResponse | null>(null);
useEffect(() => {
if (likablePlants) {
log.debug('Likable plants fetched and set:', likablePlants);
setPlantStack(likablePlants);
}
}, [likablePlants]);
const handleFilterPress = useCallback(() => {
navigation.navigate('SetUserPreferences' as never);
}, [navigation]);
const handleRemoveSinglePreference = useCallback(
async (tagKey: string, valueToRemove: string) => {
if (!userPreferences) return;
const updatedPrefs = { ...userPreferences };
switch (tagKey) {
case 'Stage':
updatedPrefs.preferedPlantStage = userPreferences.preferedPlantStage.filter(
(val) => val !== valueToRemove
);
break;
case 'Category':
updatedPrefs.preferedPlantCategory = userPreferences.preferedPlantCategory.filter(
(val) => val !== valueToRemove
);
break;
case 'Light':
updatedPrefs.preferedLightRequirement = userPreferences.preferedLightRequirement.filter(
(val) => val !== valueToRemove
);
break;
case 'Water':
updatedPrefs.preferedWateringNeed = userPreferences.preferedWateringNeed.filter(
(val) => val !== valueToRemove
);
break;
case 'Size':
updatedPrefs.preferedSize = userPreferences.preferedSize.filter(
(val) => val !== valueToRemove
);
break;
case 'IndoorOutdoor':
updatedPrefs.preferedIndoorOutdoor = userPreferences.preferedIndoorOutdoor.filter(
(val) => val !== valueToRemove
);
break;
case 'PropagationEase':
updatedPrefs.preferedPropagationEase = userPreferences.preferedPropagationEase.filter(
(val) => val !== valueToRemove
);
break;
case 'PetFriendly':
updatedPrefs.preferedPetFriendly = userPreferences.preferedPetFriendly.filter(
(val) => val !== valueToRemove
);
break;
case 'Extras':
updatedPrefs.preferedExtras = userPreferences.preferedExtras.filter(
(val) => val !== valueToRemove
);
break;
default:
break;
}
try {
await updatePreferences(updatedPrefs);
} catch (err) {
Alert.alert('Error', 'Could not remove preference.');
}
},
[userPreferences, updatePreferences]
);
const handleDislike = () => {
if (!myPlants || plantStack.length === 0) return;
const topCard = plantStack[0];
const requests: SwipeRequest[] = myPlants.map((myPlant) => ({
swiperPlantId: myPlant.plantId,
swipedPlantId: topCard.plantId,
isLike: false,
}));
swipeService
.sendSwipes(requests)
.then(() => {
setPlantStack((prevStack) => prevStack.slice(1));
})
.catch(() => {
Alert.alert('Error', 'Failed to send swipes.');
});
};
const handleLike = () => {
if (!myPlants || plantStack.length === 0) return;
const topCard = plantStack[0];
setPlantToLike(topCard);
setShowSelectModal(true);
};
const handleSelectConfirm = (selectedMyPlantIds: number[]) => {
if (!plantToLike || !myPlants) return;
const requests: SwipeRequest[] = myPlants.map((mp) => ({
swiperPlantId: mp.plantId,
swipedPlantId: plantToLike.plantId,
isLike: selectedMyPlantIds.includes(mp.plantId),
}));
swipeService
.sendSwipes(requests)
.then(() => {
setShowSelectModal(false);
setPlantToLike(null);
setPlantStack((prevStack) => prevStack.slice(1));
})
.catch(() => {
Alert.alert('Error', 'Failed to send swipes.');
});
};
const handleSelectCancel = () => {
setShowSelectModal(false);
setPlantToLike(null);
};
const handlePassPress = () => {
handleDislike();
};
const handleLikePress = () => {
handleLike();
};
const renderHeader = () => {
const prefTags: Array<{ key: string; value: string }> = [];
if (userPreferences) {
userPreferences.preferedPlantStage?.forEach((val) =>
prefTags.push({ key: 'Stage', value: val })
);
userPreferences.preferedPlantCategory?.forEach((val) =>
prefTags.push({ key: 'Category', value: val })
);
userPreferences.preferedLightRequirement?.forEach((val) =>
prefTags.push({ key: 'Light', value: val })
);
userPreferences.preferedWateringNeed?.forEach((val) =>
prefTags.push({ key: 'Water', value: val })
);
userPreferences.preferedSize?.forEach((val) =>
prefTags.push({ key: 'Size', value: val })
);
userPreferences.preferedIndoorOutdoor?.forEach((val) =>
prefTags.push({ key: 'IndoorOutdoor', value: val })
);
userPreferences.preferedPropagationEase?.forEach((val) =>
prefTags.push({ key: 'PropagationEase', value: val })
);
userPreferences.preferedPetFriendly?.forEach((val) =>
prefTags.push({ key: 'PetFriendly', value: val })
);
userPreferences.preferedExtras?.forEach((val) =>
prefTags.push({ key: 'Extras', value: val })
);
}
return (
<LinearGradient
colors={[COLORS.primary, COLORS.primaryLight]}
style={styles.headerGradient}
>
<View style={styles.headerTopRow}>
<Text style={styles.headerTitle}>Explore</Text>
<TouchableOpacity
onPress={handleFilterPress}
style={styles.headerActionButton}
accessible
accessibilityLabel="Filter plants"
accessibilityHint="Opens filter options"
>
<Ionicons name="options" size={24} color={COLORS.textLight} />
</TouchableOpacity>
</View>
<View style={styles.filterContainer}>
<View style={styles.filterInfoContainer}>
{prefTags.length > 0 ? (
<Text style={styles.filterInfoTextColumn}>Filters:</Text>
) : (
<Text style={styles.noFilterText}>No filters applied</Text>
)}
</View>
{prefTags.length > 0 && (
<View style={styles.filterColumn}>
<FlatList
data={prefTags}
keyExtractor={(item, index) =>
`${item.key}-${item.value}-${index}`
}
horizontal
showsHorizontalScrollIndicator={false}
renderItem={({ item }) => (
<View style={styles.tagChip}>
<Text style={styles.tagChipText}>{item.value}</Text>
<TouchableOpacity
style={styles.removeTagButton}
onPress={() =>
handleRemoveSinglePreference(item.key, item.value)
}
>
<Ionicons name="close-circle" size={16} color="#fff" />
</TouchableOpacity>
</View>
)}
/>
</View>
)}
</View>
</LinearGradient>
);
};
const renderCardStack = () => {
if (loadingPlants || loadingMyPlants) {
return (
<View style={styles.loaderContainer}>
<ActivityIndicator size="large" color={COLORS.primary} />
<Text style={styles.loaderText}>Loading plants...</Text>
</View>
);
}
if (errorPlants || errorMyPlants) {
return (
<View style={styles.noPlantsContainer}>
<Text style={styles.noPlantsText}>
Failed to load plants or your gallery.
</Text>
<TouchableOpacity
style={styles.reloadButton}
onPress={() => {
refetchLikablePlants();
refetchMyPlants();
}}
>
<Text style={styles.reloadButtonText}>Try Again</Text>
</TouchableOpacity>
</View>
);
}
if (!plantStack || plantStack.length === 0) {
return (
<View style={styles.noPlantsContainer}>
<Text style={styles.noPlantsText}>
No more plants to show in your area.
</Text>
<TouchableOpacity
style={styles.reloadButton}
onPress={() => refetchLikablePlants()}
>
<Text style={styles.reloadButtonText}>Reload</Text>
</TouchableOpacity>
</View>
);
}
const visibleCards = plantStack.slice(0, 3);
return (
<View style={styles.deckContainer}>
{visibleCards.map((plant, index) => {
const isTopCard = index === 0;
const offset = (visibleCards.length - 1 - index) * 5;
return (
<View
key={plant.plantId}
style={[styles.cardWrapper, { top: -offset, right: offset }]}
>
<SwipeableCard
plant={plant}
onSwipeLeft={isTopCard ? handleDislike : undefined}
onSwipeRight={isTopCard ? handleLike : undefined}
/>
</View>
);
})}
</View>
);
};
return (
<SafeAreaView style={styles.container}>
{renderHeader()}
{renderCardStack()}
{}
{plantStack && plantStack.length > 0 && (
<View style={styles.bottomActionContainer}>
<TouchableOpacity
onPress={handlePassPress}
style={styles.actionButtonWrapper}
accessibilityRole="button"
accessibilityLabel="Pass on this plant"
accessibilityHint="Dislike and show next plant"
>
<LinearGradient
colors={[COLORS.accent, COLORS.accentLight]}
style={styles.actionButton}
>
<MaterialIcons name="close" size={32} color={COLORS.textLight} />
</LinearGradient>
</TouchableOpacity>
<View style={styles.divider} />
<TouchableOpacity
onPress={handleLikePress}
style={styles.actionButtonWrapper}
accessibilityRole="button"
accessibilityLabel="Like this plant"
accessibilityHint="Show interest in this plant"
>
<LinearGradient
colors={[COLORS.primary, COLORS.primaryLight]}
style={styles.actionButton}
>
<MaterialIcons
name="favorite"
size={32}
color={COLORS.textLight}
/>
</LinearGradient>
</TouchableOpacity>
</View>
)}
{}
<SelectPlantsModal
visible={showSelectModal}
onConfirm={handleSelectConfirm}
onClose={handleSelectCancel}
/>
</SafeAreaView>
);
};
export default SwipeScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: COLORS.background,
},
loaderContainer: {
marginTop: 40,
alignItems: 'center',
},
loaderText: {
fontSize: 16,
marginTop: 10,
color: COLORS.textDark,
},
noPlantsContainer: {
marginTop: 40,
alignItems: 'center',
paddingHorizontal: 20,
},
noPlantsText: {
fontSize: 16,
color: COLORS.textDark,
marginBottom: 10,
textAlign: 'center',
},
reloadButton: {
backgroundColor: COLORS.primary,
paddingVertical: 8,
paddingHorizontal: 16,
borderRadius: 8,
},
reloadButtonText: {
color: '#fff',
fontWeight: '600',
},
headerGradient: {
paddingHorizontal: 16,
paddingTop: 15,
paddingBottom: 20,
borderBottomLeftRadius: 20,
borderBottomRightRadius: 20,
marginBottom: 10,
},
headerTopRow: {
flexDirection: 'row',
justifyContent: 'space-between',
alignItems: 'center',
},
headerTitle: {
fontSize: 26,
fontWeight: '700',
color: COLORS.textLight,
},
headerActionButton: {
padding: 6,
},
filterContainer: {
flexDirection: 'row',
},
filterInfoContainer: {
marginTop: 10,
},
filterInfoTextColumn: {
color: COLORS.textLight,
fontSize: 14,
alignItems: 'center',
},
noFilterText: {
color: COLORS.textLight,
fontSize: 14,
},
filterColumn: {
marginLeft: 5,
flexDirection: 'row',
flex: 1,
alignItems: 'center',
},
tagChip: {
flexDirection: 'row',
backgroundColor: COLORS.accent,
paddingVertical: 2,
paddingHorizontal: 8,
borderRadius: 16,
marginRight: 8,
marginTop: 10,
alignItems: 'center',
},
tagChipText: {
color: '#fff',
marginRight: 4,
fontSize: 12,
fontWeight: '600',
},
removeTagButton: {
paddingLeft: 2,
},
deckContainer: {
marginTop: 15,
flex: 1,
justifyContent: 'flex-start',
alignItems: 'center',
},
cardWrapper: {
width: width * 0.9,
},
bottomActionContainer: {
position: 'relative',
backgroundColor: COLORS.textLight,
borderRadius: 20,
paddingHorizontal: 60,
paddingTop: 20,
paddingBottom: 20,
margin: 20,
marginHorizontal: 40,
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.15,
shadowRadius: 10,
shadowOffset: { width: 0, height: -4 },
},
android: {
elevation: 10,
},
}),
alignItems: 'center',
justifyContent: 'space-between',
flexDirection: 'row',
},
divider: {
width: 1,
height: '150%',
backgroundColor: COLORS.border,
},
actionButtonWrapper: {
alignItems: 'center',
justifyContent: 'center',
},
actionButton: {
width: 50,
height: 50,
borderRadius: 25,
alignItems: 'center',
justifyContent: 'center',
...Platform.select({
ios: {
shadowColor: '#000',
shadowOpacity: 0.25,
shadowRadius: 6,
shadowOffset: { width: 0, height: 3 },
},
android: {
elevation: 6,
},
}),
},
});
// File: app\features\main\store\matchesSlice.ts

// File: app\features\main\store\plantsSlice.ts

// File: app\features\main\store\userPreferencesSlice.ts
interface UserPreferencesState {
data: UserPreferencesResponse | null;
status: 'idle' | 'loading' | 'error';
error: string | null;
}
const initialState: UserPreferencesState = {
data: null,
status: 'idle',
error: null,
};
export const fetchUserPreferencesThunk = createAsyncThunk<UserPreferencesResponse, void, { rejectValue: string }>(
'userPreferences/fetch',
async (_, { rejectWithValue }) => {
try {
const preferences = await userPreferencesService.getPreferences();
return preferences;
} catch (error: any) {
return rejectWithValue(error.response?.data?.message || 'Failed to fetch user preferences');
}
}
);
export const updateUserPreferencesThunk = createAsyncThunk<UserPreferencesResponse, UserPreferencesRequest, { rejectValue: string }>(
'userPreferences/update',
async (data, { rejectWithValue }) => {
try {
const updated = await userPreferencesService.updatePreferences(data);
return updated;
} catch (error: any) {
return rejectWithValue(error.response?.data?.message || 'Failed to update user preferences');
}
}
);
export const userPreferencesSlice = createSlice({
name: 'userPreferences',
initialState,
reducers: {
clearUserPreferences(state) {
state.data = null;
state.status = 'idle';
state.error = null;
}
},
extraReducers: (builder) => {
builder
.addCase(fetchUserPreferencesThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(fetchUserPreferencesThunk.fulfilled, (state, action: PayloadAction<UserPreferencesResponse>) => {
state.status = 'idle';
state.data = action.payload;
})
.addCase(fetchUserPreferencesThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload as string;
})
.addCase(updateUserPreferencesThunk.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(updateUserPreferencesThunk.fulfilled, (state, action: PayloadAction<UserPreferencesResponse>) => {
state.status = 'idle';
state.data = action.payload;
})
.addCase(updateUserPreferencesThunk.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload as string;
});
}
});
export const { clearUserPreferences } = userPreferencesSlice.actions;
export const selectUserPreferences = (state: RootState) => state.userPreferences.data;
export const selectUserPreferencesStatus = (state: RootState) => state.userPreferences.status;
export const selectUserPreferencesError = (state: RootState) => state.userPreferences.error;
export default userPreferencesSlice.reducer;
// File: app\features\main\store\userSlice.ts
export const fetchUserProfile = createAsyncThunk<
UserResponse,
number,
{ rejectValue: string }
>(
'user/fetchUserProfile',
async (userId, { rejectWithValue }) => {
try {
const response = await api.get<UserResponse>(`/users/${userId}`);
return response.data;
} catch (error: any) {
return rejectWithValue(error.response?.data?.message || 'Failed to fetch user profile');
}
}
);
interface UserState {
profile: UserResponse | null;
status: 'idle' | 'loading' | 'error';
error: string | null;
}
const initialState: UserState = {
profile: null,
status: 'idle',
error: null
};
export const userSlice = createSlice({
name: 'user',
initialState,
reducers: {
clearUserProfile(state) {
state.profile = null;
state.status = 'idle';
state.error = null;
}
},
extraReducers: (builder) => {
builder
.addCase(fetchUserProfile.pending, (state) => {
state.status = 'loading';
state.error = null;
})
.addCase(fetchUserProfile.fulfilled, (state, action: PayloadAction<UserResponse>) => {
state.status = 'idle';
state.profile = action.payload;
})
.addCase(fetchUserProfile.rejected, (state, action) => {
state.status = 'error';
state.error = action.payload as string;
});
}
});
export const { clearUserProfile } = userSlice.actions;
// File: app\features\main\types\mainTypes.ts

// File: app\features\onboarding\screens\OnboardingBioScreen.tsx
const OnboardingBioScreen: React.FC = () => {
const { t } = useTranslation();
const navigation = useNavigation();
const { data: userProfile } = useUserProfile();
const [bio, setBio] = useState(userProfile?.bio ?? '');
const handleSkip = () => {
navigation.navigate('OnboardingLocation' as never);
};
const handleSubmitBio = async () => {
if (!bio) {
}
try {
await userService.updateMe({ name: userProfile?.name ?? '', bio });
log.debug('Bio updated successfully');
navigation.navigate('OnboardingLocation' as never);
} catch (error) {
Alert.alert('Error', 'Failed to update bio, please try again later.');
log.error('OnboardingBioScreen handleSubmitBio error:', error);
}
};
return (
<View style={styles.container}>
<Text style={styles.title}>{t('onboarding_bio_title') }</Text>
<Text style={styles.subtitle}>
{t('onboarding_bio_subtitle') }
</Text>
<TextInput
style={styles.textInput}
value={bio}
onChangeText={setBio}
placeholder={t('onboarding_bio_placeholder') }
multiline
/>
<View style={styles.buttonContainer}>
<TouchableOpacity onPress={handleSkip} style={[styles.button, styles.skipButton]}>
<Text style={styles.buttonText}>{t('onboarding_bio_skip_button') }</Text>
</TouchableOpacity>
<TouchableOpacity onPress={handleSubmitBio} style={[styles.button, styles.submitButton]}>
<Text style={styles.buttonText}>{t('onboarding_bio_submit_button') }</Text>
</TouchableOpacity>
</View>
<Text style={styles.note}>
{t('onboarding_bio_note') }
</Text>
</View>
);
};
export default OnboardingBioScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: '#fff',
padding: 20,
justifyContent: 'flex-start',
},
title: {
fontSize: 24,
fontWeight: '700',
marginBottom: 10,
color: '#333',
},
subtitle: {
fontSize: 16,
marginBottom: 20,
color: '#555',
},
textInput: {
borderWidth: 1,
borderColor: '#ccc',
borderRadius: 8,
padding: 10,
fontSize: 14,
minHeight: 80,
marginBottom: 20,
textAlignVertical: 'top',
backgroundColor: '#fafafa',
},
buttonContainer: {
flexDirection: 'row',
justifyContent: 'space-between',
marginBottom: 10,
},
button: {
flex: 0.45,
paddingVertical: 12,
borderRadius: 8,
alignItems: 'center',
justifyContent: 'center',
},
skipButton: {
backgroundColor: '#ccc',
},
submitButton: {
backgroundColor: '#1EAE98',
},
buttonText: {
color: '#fff',
fontWeight: '600',
fontSize: 16,
},
note: {
marginTop: 20,
fontSize: 14,
color: '#777',
textAlign: 'center',
},
});
// File: app\features\onboarding\screens\OnboardingLocationScreen.tsx
const { width, height } = Dimensions.get('window');
const OnboardingLocationScreen: React.FC = () => {
const queryClient = useQueryClient();
const [region, setRegion] = useState({
latitude: 37.78825,
longitude: -122.4324,
latitudeDelta: 0.0922,
longitudeDelta: 0.0421,
});
const [selectedLocation, setSelectedLocation] = useState<{
latitude: number;
longitude: number;
} | null>(null);
const handleMapPress = (e: MapPressEvent) => {
const { latitude, longitude } = e.nativeEvent.coordinate;
setSelectedLocation({ latitude, longitude });
setRegion((prev) => ({
...prev,
latitude,
longitude,
}));
};
const handleConfirmLocation = async () => {
if (!selectedLocation) {
Alert.alert('No location selected', 'Please tap on the map to select your approximate location');
return;
}
try {
await userService.updateLocation({
latitude: selectedLocation.latitude,
longitude: selectedLocation.longitude,
});
queryClient.invalidateQueries('userProfile');
} catch (error) {
Alert.alert('Error', 'Failed to update location. Please try again.');
}
};
return (
<View style={styles.container}>
<Text style={styles.title}>Set Your Location</Text>
<Text style={styles.subtitle}>
Tap on the map to drop a pin at your approximate location.
</Text>
<MapView
style={styles.map}
initialRegion={region}
onPress={handleMapPress}
>
{selectedLocation && (
<Marker coordinate={selectedLocation} />
)}
</MapView>
<TouchableOpacity onPress={handleConfirmLocation} style={styles.confirmButton}>
<Text style={styles.confirmButtonText}>Confirm & Continue</Text>
</TouchableOpacity>
</View>
);
};
export default OnboardingLocationScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
justifyContent: 'flex-start',
paddingTop: 50,
backgroundColor: '#fff',
},
title: {
fontSize: 20,
fontWeight: '700',
marginHorizontal: 20,
marginBottom: 8,
},
subtitle: {
fontSize: 14,
marginHorizontal: 20,
marginBottom: 16,
color: '#555',
},
map: {
width: width,
height: height * 0.55,
},
confirmButton: {
backgroundColor: '#1EAE98',
padding: 16,
margin: 20,
borderRadius: 8,
},
confirmButtonText: {
color: '#fff',
fontWeight: '600',
textAlign: 'center',
},
});
// File: app\features\onboarding\screens\OnboardingWelcomeScreen.tsx
const OnboardingWelcomeScreen: React.FC = () => {
const navigation = useNavigation();
const handleNextPress = () => {
navigation.navigate('OnboardingBio' as never);
};
return (
<View style={styles.container}>
<Text style={styles.title}>Welcome to Cuttr!</Text>
<Text style={styles.subtitle}>
Here’s a quick intro to how you can swap plants safely and easily.
</Text>
{}
<TouchableOpacity onPress={handleNextPress} style={styles.button}>
<Text style={styles.buttonText}>Next: Choose Location</Text>
</TouchableOpacity>
</View>
);
};
export default OnboardingWelcomeScreen;
const styles = StyleSheet.create({
container: {
flex: 1,
padding: 20,
justifyContent: 'center',
},
title: {
fontSize: 28,
fontWeight: '700',
marginBottom: 10,
},
subtitle: {
fontSize: 16,
marginBottom: 40,
},
button: {
backgroundColor: '#1EAE98',
padding: 14,
borderRadius: 8,
},
buttonText: {
color: '#fff',
fontWeight: '600',
textAlign: 'center',
},
});
// File: app\hooks\useAuthToken.ts

// File: app\hooks\useAxiosErrorHandler.ts

// File: app\hooks\useNetworkStatus.ts

// File: app\i18n\index.ts
export async function initI18n() {
await i18n
.use(initReactI18next)
.init({
fallbackLng: 'en',
lng: Localization.locale,
resources: {
en: { translation: en },
fr: { translation: fr },
},
interpolation: {
escapeValue: false,
},
});
return i18n;
}
// File: app\i18n\locales\en.json
{
"welcome_back": "Welcome Back",
"create_account": "Create Account",
"login": "Login",
"register": "Register",
"email": "Email",
"password": "Password",
"name": "Name",
"no_account_register": "Don’t have an account? Register",
"have_account_login": "Already have an account? Login",
"profile_title": "Profile",
"profile_loading_message": "Loading your profile...",
"profile_error_message": "Failed to load your profile.",
"profile_retry_button": "Try Again",
"profile_name_label": "Name",
"profile_bio_label": "Bio",
"profile_location_label": "Location",
"profile_no_location": "No location set",
"profile_edit_button": "Edit Profile",
"profile_change_location_button": "Change Location",
"profile_add_plant_button": "Add Plant",
"profile_my_plants_section": "'s Plants",
"profile_no_plants_message": "You have no plants yet. Add one to get started!",
"edit_profile_title": "Edit Profile",
"edit_profile_name_label": "Name",
"edit_profile_bio_label": "Bio",
"edit_profile_confirm_button": "Confirm",
"edit_profile_cancel_button": "Cancel",
"edit_profile_error_message": "Failed to update profile.",
"change_location_title": "Change Location",
"change_location_instructions": "Tap on the map to select your location.",
"change_location_confirm_button": "Confirm",
"change_location_cancel_button": "Cancel",
"change_location_error_message": "Failed to update location.",
"add_plant_title": "Add a New Plant",
"add_plant_species_name_label": "Species Name",
"add_plant_description_label": "Description",
"add_plant_stage_label": "Stage",
"add_plant_category_label": "Category",
"add_plant_watering_label": "Watering Need",
"add_plant_light_label": "Light Requirement",
"add_plant_size_label": "Size",
"add_plant_indoor_outdoor_label": "Indoor/Outdoor",
"add_plant_propagation_ease_label": "Propagation Ease",
"add_plant_pet_friendly_label": "Pet Friendly",
"add_plant_extras_label": "Extras",
"add_plant_select_image_button": "Select Image",
"add_plant_select_image_title": "Select Image",
"add_plant_save_button": "Save",
"add_plant_cancel_button": "Cancel",
"add_plant_error_message": "Failed to add plant.",
"add_plant_no_image_selected": "No image selected.",
"onboarding_bio_title": "Tell Us About Yourself",
"onboarding_bio_subtitle": "Add a brief bio so others can know more about you.",
"onboarding_bio_placeholder": "Your bio here...",
"onboarding_bio_skip_button": "Skip",
"onboarding_bio_submit_button": "Save & Continue",
"onboarding_bio_note": "You can always add or edit your bio later from your profile.",
"add_plant_size_question": "Size",
"add_plant_indoor_outdoor_question": "Indoor/Outdoor",
"add_plant_propagation_ease_question": "Propagation Ease",
"add_plant_pet_friendly_question": "Pet Friendly",
"add_plant_extras_question": "Extras",
"plant_stage_seedling": "Seed(ling)",
"plant_stage_cutting": "Cutting",
"plant_stage_mature": "Mature",
"plant_category_succulent": "Succulent",
"plant_category_cactus": "Cactus",
"plant_category_fern": "Fern",
"plant_category_orchid": "Orchid",
"plant_category_herb": "Herb",
"plant_category_palm": "Palm",
"plant_category_leafy_houseplant": "Leafy Houseplant",
"plant_category_aquatic_plant": "Aquatic Plant",
"plant_category_climbing_plant": "Climbing Plant",
"plant_category_tree": "Tree",
"plant_category_other": "Other",
"watering_need_very_low_water": "Very Low Water",
"watering_need_low_water": "Low Water",
"watering_need_moderate_water": "Moderate Water",
"watering_need_high_water": "High Water",
"watering_need_very_high_water": "Very High Water",
"light_requirement_full_sun": "Full Sun",
"light_requirement_partial_sun": "Partial Sun",
"light_requirement_bright_indirect_light": "Bright Indirect Light",
"light_requirement_low_light": "Low Light",
"size_small_size": "Small Size",
"size_medium_size": "Medium Size",
"size_large_size": "Large Size",
"indoor_outdoor_indoor": "Indoor",
"indoor_outdoor_outdoor": "Outdoor",
"indoor_outdoor_indoor_and_outdoor": "Indoor and Outdoor",
"propagation_ease_easy_propagation": "Easy Propagation",
"propagation_ease_moderate_propagation": "Moderate Propagation",
"propagation_ease_difficult_propagation": "Difficult Propagation",
"pet_friendly_pet_friendly": "Pet Friendly",
"pet_friendly_not_pet_friendly": "Not Pet Friendly",
"extras_fragrant": "Fragrant",
"extras_edible": "Edible",
"extras_medicinal": "Medicinal",
"extras_air_purifying": "Air Purifying",
"extras_decorative": "Decorative",
"extras_flowering": "Flowering",
"extras_tropical_vibe": "Tropical Vibe",
"extras_foliage_heavy": "Foliage Heavy",
"extras_drought_tolerant": "Drought Tolerant",
"extras_humidity_loving": "Humidity Loving",
"extras_low_maintenance": "Low Maintenance",
"extras_winter_hardy": "Winter Hardy",
"extras_beginner_friendly": "Beginner Friendly",
"extras_fruiting": "Fruiting",
"extras_pollinator_friendly": "Pollinator Friendly",
"extras_fast_growing": "Fast Growing",
"extras_variegated_foliage": "Variegated Foliage",
"extras_climbing": "Climbing",
"extras_ground_cover": "Ground Cover",
"extras_rare": "Rare",
"connections_loading": "Loading your connections...",
"connections_error": "Unable to load connections. Please try again.",
"connections_retry_button": "Retry",
"connections_none_title": "No Connections Yet",
"connections_none_message": "It looks like you haven't matched with anyone so far.",
"connections_none_action": "Find Plants",
"connections_matches_label": "{{count}} Matches",
"connections_title": "Connections"
}
// File: app\i18n\locales\fr.json
{
"welcome_back": "Bon Retour",
"create_account": "Créer un Compte",
"login": "Connexion",
"register": "S'inscrire",
"email": "E-mail",
"password": "Mot de Passe",
"name": "Nom",
"no_account_register": "Vous n'avez pas de compte ? Inscrivez-vous",
"have_account_login": "Vous avez déjà un compte ? Connectez-vous",
"profile_title": "Mon Profil",
"profile_loading_message": "Chargement de votre profil...",
"profile_error_message": "Impossible de charger votre profil.",
"profile_retry_button": "Réessayer",
"profile_name_label": "Nom",
"profile_bio_label": "Bio",
"profile_location_label": "Localisation",
"profile_no_location": "Aucune localisation définie",
"profile_edit_button": "Modifier le Profil",
"profile_change_location_button": "Changer la Localisation",
"profile_add_plant_button": "Ajouter une Plante",
"profile_my_plants_section": "Mes Plantes",
"profile_no_plants_message": "Vous n'avez pas encore de plantes. Ajoutez-en une pour commencer !",
"edit_profile_title": "Modifier le Profil",
"edit_profile_name_label": "Nom",
"edit_profile_bio_label": "Bio",
"edit_profile_confirm_button": "Confirmer",
"edit_profile_cancel_button": "Annuler",
"edit_profile_error_message": "Impossible de mettre à jour le profil.",
"change_location_title": "Changer de Localisation",
"change_location_instructions": "Appuyez sur la carte pour sélectionner votre localisation.",
"change_location_confirm_button": "Confirmer",
"change_location_cancel_button": "Annuler",
"change_location_error_message": "Impossible de mettre à jour la localisation.",
"add_plant_title": "Ajouter une Nouvelle Plante",
"add_plant_species_name_label": "Nom de l'Espèce",
"add_plant_description_label": "Description",
"add_plant_stage_label": "Stade",
"add_plant_category_label": "Catégorie",
"add_plant_watering_label": "Besoins en Arrosage",
"add_plant_light_label": "Besoin en Lumière",
"add_plant_size_label": "Taille",
"add_plant_indoor_outdoor_label": "Intérieur/Extérieur",
"add_plant_propagation_ease_label": "Facilité de Propagation",
"add_plant_pet_friendly_label": "Adapté aux Animaux",
"add_plant_extras_label": "Extras",
"add_plant_select_image_button": "Sélectionner une Image",
"add_plant_save_button": "Enregistrer",
"add_plant_cancel_button": "Annuler",
"add_plant_error_message": "Impossible d'ajouter la plante.",
"add_plant_no_image_selected": "Aucune image sélectionnée."
}
// File: app\navigation\AppNavigator.tsx
const AppNavigator = () => {
const dispatch = useDispatch();
const { accessToken } = useSelector((state: RootState) => state.auth);
const { refreshToken } = useSelector((state: RootState) => state.auth);
const [initializing, setInitializing] = useState(true);
const { data: userProfile, isLoading: userProfileLoading } = useUserProfile();
useEffect(() => {
const initializeAuth = async () => {
const storedAccessToken = await storage.getAccessToken();
const storedRefreshToken = await storage.getRefreshToken();
if (storedAccessToken && storedRefreshToken) {
dispatch(setInitialTokens({
accessToken: storedAccessToken,
refreshToken: storedRefreshToken,
userId: null,
email: null,
}));
try {
const profile = await userService.getCurrentUserProfile();
dispatch(setInitialTokens({
accessToken: store.getState().auth.accessToken,
refreshToken: store.getState().auth.refreshToken,
userId: profile.userId,
email: profile.email,
}));
} catch (err) {
dispatch(logout());
}
}
setInitializing(false);
};
initializeAuth();
}, [dispatch]);
if (initializing) {
return (
<View style={styles.loadingContainer}>
<ActivityIndicator size="large" color="#1EAE98" />
</View>
);
}
if (!accessToken) {
return <AuthNavigator />;
}
if (userProfileLoading) {
return (
<View style={styles.loadingContainer}>
<ActivityIndicator size="large" color="#1EAE98" />
</View>
);
}
if (!userProfile?.locationLatitude || !userProfile?.locationLongitude) {
return <OnboardingNavigator />;
}
return <MainNavigator />;
};
export default AppNavigator;
const styles = StyleSheet.create({
loadingContainer: {
flex: 1,
alignItems: 'center',
justifyContent: 'center',
},
});
// File: app\navigation\AuthNavigator.tsx
const Stack = createNativeStackNavigator();
const AuthNavigator = () => {
return (
<Stack.Navigator>
<Stack.Screen name="Login" component={LoginScreen} options={{ headerShown: false }} />
<Stack.Screen name="Register" component={RegisterScreen} options={{ headerShown: false }} />
</Stack.Navigator>
);
};
export default AuthNavigator;
// File: app\navigation\MainNavigator.tsx
const Tab = createBottomTabNavigator();
const icons: Record<string, number> = {
Swipe: require('../../assets/images/swiping.png'),
Profile: require('../../assets/images/profile.png'),
Settings: require('../../assets/images/settings.png'),
};
const MainNavigator = () => {
return (
<Tab.Navigator
screenOptions={({ route }) => ({
headerShown: false,
tabBarIcon: ({ focused, color, size }) => {
const iconSource = icons[route.name];
return (
<Image
source={iconSource}
style={[
styles.icon,
{ tintColor: focused ? '#673ab7' : '#222' },
{ width: size, height: size },
]}
/>
);
},
tabBarActiveTintColor: '#673ab7',
tabBarInactiveTintColor: 'gray',
})}
>
<Tab.Screen name="Swipe" component={SwipeStackNavigator}/>
<Tab.Screen name="Profile" component={ProfileStackNavigator}/>
<Tab.Screen name="Connections" component={ConnectionsScreen}/>
<Tab.Screen name="Settings" component={SettingsScreen}/>
</Tab.Navigator>
);
};
export default MainNavigator;
const styles = StyleSheet.create({
icon: {
width: 24,
height: 24,
},
});
// File: app\navigation\NavigationTypes.ts

// File: app\navigation\OnboardingNavigator.tsx
const Stack = createNativeStackNavigator();
const OnboardingNavigator = () => {
return (
<Stack.Navigator screenOptions={{ headerShown: false }}>
{}
<Stack.Screen name="OnboardingWelcome" component={OnboardingWelcomeScreen} />
<Stack.Screen name="OnboardingBio" component={OnboardingBioScreen} />
{}
<Stack.Screen name="OnboardingLocation" component={OnboardingLocationScreen} />
</Stack.Navigator>
);
};
export default OnboardingNavigator;
// File: app\navigation\ProfileStackNavigator.tsx
export type ProfileStackParamList = {
ProfileHome: undefined;
AddPlant: undefined;
};
const Stack = createNativeStackNavigator<ProfileStackParamList>();
const ProfileStackNavigator = () => {
return (
<Stack.Navigator screenOptions={{ headerShown: false }}>
<Stack.Screen name="ProfileHome" component={MyProfileScreen} />
<Stack.Screen name="AddPlant" component={AddPlantScreen} />
</Stack.Navigator>
);
};
export default ProfileStackNavigator;
// File: app\navigation\SwipeStackNavigator.tsx
export type SwipeStackParamList = {
SwipeHome: undefined;
SetUserPreferences: undefined;
};
const Stack = createNativeStackNavigator<SwipeStackParamList>();
const SwipeStackNavigator = () => {
return (
<Stack.Navigator screenOptions={{ headerShown: false }}>
<Stack.Screen name="SwipeHome" component={SwipeScreen} />
<Stack.Screen name="SetUserPreferences" component={SetUserPreferencesScreen} />
</Stack.Navigator>
);
};
export default SwipeStackNavigator;
// File: app\store\hooks.ts
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
// File: app\store\index.ts
export const store = configureStore({
reducer: {
auth: authSlice.reducer,
user: userSlice.reducer,
userPreferences: userPreferencesSlice.reducer,
globalError: globalErrorSlice.reducer,
},
middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(loggingMiddleware),
});
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
// File: app\store\rootReducer.ts

// File: app\store\middlewares\loggingMiddleware.ts
export const loggingMiddleware: Middleware = (storeAPI) => (next) => (action: any) => {
if (__DEV__) {
log.debug("Redux Action Dispatched", { type: action.type, payload: action.payload });
}
const result = next(action);
return result;
};
// File: app\store\middlewares\tokenRefreshMiddleware.ts

// File: app\store\slices\globalErrorSlice.ts
interface GlobalErrorState {
message: string | null;
}
const initialState: GlobalErrorState = {
message: null,
};
export const globalErrorSlice = createSlice({
name: 'globalError',
initialState,
reducers: {
setGlobalError(state, action: PayloadAction<string>) {
state.message = action.payload;
},
clearGlobalError(state) {
state.message = null;
},
},
});
export const { setGlobalError, clearGlobalError } = globalErrorSlice.actions;
// File: app\theme\colors.ts
const COLORS = {
primary: '#1EAE98',
accent: '#FF6F61',
background: '#F2F2F2',
textDark: '#2F4F4F',
textLight: '#FFFFFF',
cardBg: '#FFFFFF',
border: '#ddd',
};
export default COLORS;
// File: app\theme\index.ts

// File: app\theme\spacing.ts

// File: app\theme\typography.ts

// File: app\types\apiTypes.ts
export interface RefreshTokenRequest {
refreshToken: string;
}
export interface MessageRequest {
matchId: number;
messageText: string;
}
export interface PlantCreateRequest {
plantDetails: PlantRequest;
image: File;
}
export interface PlantRequest {
speciesName: string;
description: string | null;
plantStage: PlantStage;
plantCategory: PlantCategory | null;
wateringNeed: WateringNeed | null;
lightRequirement: LightRequirement | null;
size: Size | null;
indoorOutdoor: IndoorOutdoor | null;
propagationEase: PropagationEase | null;
petFriendly: PetFriendly | null;
extras: Extras[];
}
export interface PlantUpdateRequest {
speciesName: string;
careRequirements: string;
description: string;
category: string;
}
export interface ReportRequest {
reportedUserId: number;
reason: string;
comments: string;
}
export interface SwipeRequest {
swiperPlantId: number;
swipedPlantId: number;
isLike: boolean;
}
export interface UpdateLocationRequest {
latitude: number;
longitude: number;
}
export interface UserLoginRequest {
email: string;
password: string;
}
export interface UserPreferencesRequest {
searchRadius: number;
preferedPlantStage: PlantStage[];
preferedPlantCategory: PlantCategory[];
preferedWateringNeed: WateringNeed[];
preferedLightRequirement: LightRequirement[];
preferedSize: Size[];
preferedIndoorOutdoor: IndoorOutdoor[];
preferedPropagationEase: PropagationEase[];
preferedPetFriendly: PetFriendly[];
preferedExtras: Extras[];
}
export interface UserProfileImageUpdateRequest {
image: File;
}
export interface UserRegistrationRequest {
email: string;
password: string;
name: string;
}
export interface UserUpdateRequest {
name: string;
bio: string;
}
export interface AuthTokenResponse {
accessToken: string;
refreshToken: string;
tokenType: string;
expiresIn: number;
}
export interface MatchResponse {
matchId: number;
plant1: PlantResponse;
plant2: PlantResponse;
user1: UserResponse;
user2: UserResponse;
isClosed: boolean;
}
export interface MessageResponse {
messageId: number;
matchId: number;
senderUserId: number;
messageText: string;
sentAt: Date;
isRead: boolean;
}
export interface PlantResponse {
plantId: number;
userId: number;
speciesName: string;
description: string;
plantStage: PlantStage;
plantCategory: PlantCategory;
wateringNeed: WateringNeed;
lightRequirement: LightRequirement;
size?: Size;
indoorOutdoor?: IndoorOutdoor;
propagationEase?: PropagationEase;
petFriendly?: PetFriendly;
extras?: Extras[];
imageUrl: string;
}
export interface ReportResponse {
reportId: number;
reporterUserId: number;
reportedUserId: number;
reason: string;
comments: string;
createdAt: Date;
isResolved: boolean;
}
export interface SwipeResponse {
isMatch: boolean;
match: MatchResponse;
}
export interface UserLoginResponse {
userId: number;
email: string;
tokens: AuthTokenResponse;
}
export interface UserPreferencesResponse {
userId: number;
searchRadius: number;
preferedPlantStage: PlantStage[];
preferedPlantCategory: PlantCategory[];
preferedWateringNeed: WateringNeed[];
preferedLightRequirement: LightRequirement[];
preferedSize: Size[];
preferedIndoorOutdoor: IndoorOutdoor[];
preferedPropagationEase: PropagationEase[];
preferedPetFriendly: PetFriendly[];
preferedExtras: Extras[];
}
export interface UserResponse {
userId: number;
email: string;
name: string;
profilePictureUrl: string;
bio: string;
locationLatitude?: number;
locationLongitude?: number;
}
// File: app\types\enums.ts
export enum PlantStage {
Seedling = "Seedling",
Cutting = "Cutting",
Mature = "Mature",
}
export enum PlantCategory {
Succulent = "Succulent",
Cactus = "Cactus",
Fern = "Fern",
Orchid = "Orchid",
Herb = "Herb",
Palm = "Palm",
LeafyHouseplant = "LeafyHouseplant",
AquaticPlant = "AquaticPlant",
ClimbingPlant = "ClimbingPlant",
Tree = "Tree",
Other = "Other"
}
export enum WateringNeed {
VeryLowWater = "VeryLowWater",
LowWater = "LowWater",
ModerateWater = "ModerateWater",
HighWater = "HighWater",
VeryHighWater = "VeryHighWater"
}
export enum LightRequirement {
FullSun = "FullSun",
PartialSun = "PartialSun",
BrightIndirectLight = "BrightIndirectLight",
LowLight = "LowLight",
}
export enum Size {
SmallSize = "SmallSize",
MediumSize = "MediumSize",
LargeSize = "LargeSize"
}
export enum IndoorOutdoor {
Indoor = "Indoor",
Outdoor = "Outdoor",
IndoorAndOutdoor = "IndoorAndOutdoor"
}
export enum PropagationEase {
EasyPropagation = "EasyPropagation",
ModeratePropagation = "ModeratePropagation",
DifficultPropagation = "DifficultPropagation"
}
export enum PetFriendly {
PetFriendly = "PetFriendly",
NotPetFriendly = "NotPetFriendly",
}
export enum Extras {
Fragrant = "Fragrant",
Edible = "Edible",
Medicinal = "Medicinal",
AirPurifying = "AirPurifying",
Decorative = "Decorative",
Flowering = "Flowering",
TropicalVibe = "TropicalVibe",
FoliageHeavy = "FoliageHeavy",
DroughtTolerant = "DroughtTolerant",
HumidityLoving = "HumidityLoving",
LowMaintenance = "LowMaintenance",
WinterHardy = "WinterHardy",
BeginnerFriendly = "BeginnerFriendly",
Fruiting = "Fruiting",
PollinatorFriendly = "PollinatorFriendly",
FastGrowing = "FastGrowing",
VariegatedFoliage = "VariegatedFoliage",
Climbing = "Climbing",
GroundCover = "GroundCover",
Rare = "Rare"
}
// File: app\types\global.ts

// File: app\utils\formatting.ts

// File: app\utils\index.ts

// File: app\utils\logger.ts
const defaultConfig = {
severity: __DEV__ ? 'debug' : 'warn',
};
export const log = logger.createLogger(defaultConfig);
// File: app\utils\storage.ts
const ACCESS_TOKEN_KEY = "ACCESS_TOKEN_KEY";
const REFRESH_TOKEN_KEY = "REFRESH_TOKEN_KEY";
const LANGUAGE_KEY = "LANGUAGE_KEY";
export const storage = {
saveTokens: async (accessToken: string, refreshToken: string) => {
await SecureStore.setItemAsync(ACCESS_TOKEN_KEY, accessToken);
await SecureStore.setItemAsync(REFRESH_TOKEN_KEY, refreshToken);
},
getAccessToken: async () => SecureStore.getItemAsync(ACCESS_TOKEN_KEY),
getRefreshToken: async () => SecureStore.getItemAsync(REFRESH_TOKEN_KEY),
clearTokens: async () => {
await SecureStore.deleteItemAsync(ACCESS_TOKEN_KEY);
await SecureStore.deleteItemAsync(REFRESH_TOKEN_KEY);
},
saveLanguage: async (language: string) => {
await SecureStore.setItemAsync(LANGUAGE_KEY, language);
},
getLanguage: async () => SecureStore.getItemAsync(LANGUAGE_KEY),
};
// File: app\utils\validation.ts

// File: scripts\reset-project.js
#!/usr/bin/env node
const fs = require("fs");
const path = require("path");
const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const newDir = "app-example";
const newAppDir = "app";
const newDirPath = path.join(root, newDir);
const indexContent = `import { Text, View } from "react-native";
export default function Index() {
return (
<View
style={{
flex: 1,
justifyContent: "center",
alignItems: "center",
}}
>
<Text>Edit app/index.tsx to edit this screen.</Text>
</View>
);
}
`;
const layoutContent = `import { Stack } from "expo-router";
export default function RootLayout() {
return <Stack />;
}
`;
const moveDirectories = async () => {
try {
await fs.promises.mkdir(newDirPath, { recursive: true });
console.log(`📁 /${newDir} directory created.`);
for (const dir of oldDirs) {
const oldDirPath = path.join(root, dir);
const newDirPath = path.join(root, newDir, dir);
if (fs.existsSync(oldDirPath)) {
await fs.promises.rename(oldDirPath, newDirPath);
console.log(`➡️ /${dir} moved to /${newDir}/${dir}.`);
} else {
console.log(`➡️ /${dir} does not exist, skipping.`);
}
}
const newAppDirPath = path.join(root, newAppDir);
await fs.promises.mkdir(newAppDirPath, { recursive: true });
console.log("\n📁 New /app directory created.");
const indexPath = path.join(newAppDirPath, "index.tsx");
await fs.promises.writeFile(indexPath, indexContent);
console.log("📄 app/index.tsx created.");
const layoutPath = path.join(newAppDirPath, "_layout.tsx");
await fs.promises.writeFile(layoutPath, layoutContent);
console.log("📄 app/_layout.tsx created.");
console.log("\n✅ Project reset complete. Next steps:");
console.log(
"1. Run `npx expo start` to start a development server.\n2. Edit app/index.tsx to edit the main screen.\n3. Delete the /app-example directory when you're done referencing it."
);
} catch (error) {
console.error(`Error during script execution: ${error}`);
}
};
moveDirectories();