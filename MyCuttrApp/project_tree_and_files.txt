MyCuttrApp
├── .gitignore
├── Gather all files.py
├── README.md
├── all_mobile_app_files_combined_cleaned.txt
├── app
│   ├── ErrorBoundary.tsx
│   ├── api
│   │   ├── authService.ts
│   │   ├── axiosConfig.ts
│   │   ├── connectionService.ts
│   │   ├── matchService.ts
│   │   ├── messageService.ts
│   │   ├── plantService.ts
│   │   ├── reportService.ts
│   │   ├── swipeService.ts
│   │   ├── userPreferencesService.ts
│   │   └── userService.ts
│   ├── components
│   │   ├── common
│   │   │   └── TextInputField.tsx
│   │   ├── feedback
│   │   │   ├── ErrorMessage.tsx
│   │   │   ├── ErrorState.tsx
│   │   │   └── LoadingSpinner.tsx
│   │   ├── index.ts
│   │   └── layout
│   ├── context
│   │   └── AuthContext.tsx
│   ├── features
│   │   ├── auth
│   │   │   ├── hooks
│   │   │   │   └── useAuth.ts
│   │   │   ├── index.ts
│   │   │   ├── screens
│   │   │   │   ├── LoginScreen.tsx
│   │   │   │   └── RegisterScreen.tsx
│   │   │   ├── store
│   │   │   │   └── authSlice.ts
│   │   │   ├── styles
│   │   │   │   └── authStyles.ts
│   │   │   └── types
│   │   │       └── authTypes.ts
│   │   ├── main
│   │   │   ├── components
│   │   │   │   ├── ChatShelf.tsx
│   │   │   │   ├── CompletedTradeActions.tsx
│   │   │   │   ├── ConfirmCancelButtons.tsx
│   │   │   │   ├── MatchCard.tsx
│   │   │   │   ├── MessageBubble.tsx
│   │   │   │   ├── MultiSelectTagGroup.tsx
│   │   │   │   ├── PlantCardWithInfo.tsx
│   │   │   │   ├── PlantOverlay.tsx
│   │   │   │   ├── PlantThumbnail.tsx
│   │   │   │   ├── ProfileCard.tsx
│   │   │   │   ├── ProfileCardShelf.tsx
│   │   │   │   ├── ProfileLocationDisplay.tsx
│   │   │   │   ├── SwipeableCard.tsx
│   │   │   │   ├── TagGroup.tsx
│   │   │   │   ├── ToggleButton.tsx
│   │   │   │   └── TradeProposalComponent.tsx
│   │   │   ├── hooks
│   │   │   │   ├── useConnections.ts
│   │   │   │   ├── useMessages.ts
│   │   │   │   ├── useMyProfileHooks.ts
│   │   │   │   ├── useOtherProfile.ts
│   │   │   │   ├── usePlantHooks.ts
│   │   │   │   ├── usePreferences.ts
│   │   │   │   ├── useSearchRadius.ts
│   │   │   │   ├── useSwipe.ts
│   │   │   │   ├── useTradeProposalHooks.ts
│   │   │   │   └── useUserMatches.ts
│   │   │   ├── index.ts
│   │   │   ├── modals
│   │   │   │   ├── ChangeLocationModal.tsx
│   │   │   │   ├── EditProfileModal.tsx
│   │   │   │   ├── InfoModal.tsx
│   │   │   │   ├── ItsAMatchModal.tsx
│   │   │   │   └── SelectPlantsModal.tsx
│   │   │   ├── screens
│   │   │   │   ├── AddPlantScreen.tsx
│   │   │   │   ├── BrowseMatchesScreen.tsx
│   │   │   │   ├── ChatScreen.tsx
│   │   │   │   ├── ConnectionsScreen.tsx
│   │   │   │   ├── MakeTradeProposalScreen.tsx
│   │   │   │   ├── MyProfileScreen.tsx
│   │   │   │   ├── OtherProfileScreen.tsx
│   │   │   │   ├── SetUserPreferencesScreen.tsx
│   │   │   │   ├── SettingsScreen.tsx
│   │   │   │   ├── SwipeScreen.tsx
│   │   │   │   └── TradeProposalsScreen.tsx
│   │   │   ├── styles
│   │   │   │   ├── headerStyles.ts
│   │   │   │   └── profileCardStyles.ts
│   │   │   └── types
│   │   │       └── mainTypes.ts
│   │   └── onboarding
│   │       ├── screens
│   │       │   ├── OnboardingBioScreen.tsx
│   │       │   ├── OnboardingLocationScreen.tsx
│   │       │   └── OnboardingWelcomeScreen.tsx
│   │       └── store
│   ├── hooks
│   │   ├── useAuthToken.ts
│   │   ├── useAxiosErrorHandler.ts
│   │   └── useNetworkStatus.ts
│   ├── i18n
│   │   ├── index.ts
│   │   └── locales
│   │       ├── en.json
│   │       └── fr.json
│   ├── index.tsx
│   ├── navigation
│   │   ├── AppNavigator.tsx
│   │   ├── AuthNavigator.tsx
│   │   ├── MainRootStackNavigator.tsx
│   │   ├── MainTabNavigator.tsx
│   │   └── OnboardingNavigator.tsx
│   ├── store
│   │   ├── hooks.ts
│   │   ├── index.ts
│   │   ├── middlewares
│   │   │   └── loggingMiddleware.ts
│   │   └── slices
│   │       └── globalErrorSlice.ts
│   ├── theme
│   │   ├── colors.ts
│   │   ├── index.ts
│   │   ├── spacing.ts
│   │   └── typography.ts
│   ├── types
│   │   ├── apiTypes.ts
│   │   ├── enums.ts
│   │   └── global.ts
│   └── utils
│       ├── formatting.ts
│       ├── index.ts
│       ├── logger.ts
│       ├── storage.ts
│       └── validation.ts
├── app.json
├── app_overview.py
├── babel.config.js
├── expo-env.d.ts
├── package.json
├── previous shelf with matches.txt
├── project_tree.txt
├── project_tree_and_files.txt
├── scripts
│   └── reset-project.js
├── treestrucutre.py
├── tsconfig.json
└── yarn.lock

========================================
Combined Mobile App Files:
========================================

// File: app.json
{
  "expo": {
    "name": "MyCuttrApp",
    "slug": "MyCuttrApp",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#00000000"
      }
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#00000000"
        }
      ],
      "expo-localization",
      "expo-font",
      "expo-secure-store",
      "expo-location"
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}


// File: babel.config.js
module.exports = function(api) {
    api.cache(true);
    return {
      presets: ['babel-preset-expo'],
      plugins: ['react-native-reanimated/plugin'], // Add this line
    };
  };
  

// File: expo-env.d.ts
/// <reference types="expo/types" />

// NOTE: This file should not be edited and should be in your git ignore

// File: package.json
{
  "name": "mycuttrapp",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@react-native-community/slider": "^4.5.5",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "@react-navigation/native-stack": "^7.2.0",
    "@react-navigation/stack": "^7.1.1",
    "@reduxjs/toolkit": "^2.5.0",
    "axios": "^1.7.9",
    "expo": "~52.0.26",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.4",
    "expo-font": "~13.0.3",
    "expo-haptics": "~14.0.1",
    "expo-image-manipulator": "~13.0.6",
    "expo-image-picker": "~16.0.4",
    "expo-linear-gradient": "~14.0.2",
    "expo-linking": "~7.0.4",
    "expo-localization": "~16.0.1",
    "expo-location": "^18.0.5",
    "expo-router": "~4.0.17",
    "expo-secure-store": "~14.0.1",
    "expo-splash-screen": "~0.29.21",
    "expo-status-bar": "~2.0.1",
    "expo-symbols": "~0.2.1",
    "expo-system-ui": "~4.0.7",
    "expo-web-browser": "~14.0.2",
    "i18next": "^24.2.0",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-i18next": "^15.2.0",
    "react-native": "0.76.6",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-logs": "^5.3.0",
    "react-native-maps": "1.18.0",
    "react-native-reanimated": "^3.16.6",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "15.8.0",
    "react-native-vector-icons": "^10.2.0",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5",
    "react-query": "^3.39.3",
    "react-redux": "^9.2.0"
  },
  "devDependencies": {
    "@babel/core": "^7.26.0",
    "@types/jest": "^29.5.12",
    "@types/react": "~18.3.12",
    "@types/react-redux": "^7.1.34",
    "@types/react-test-renderer": "^18.3.0",
    "jest": "^29.2.1",
    "jest-expo": "~52.0.3",
    "react-test-renderer": "18.3.1",
    "typescript": "^5.7.2"
  },
  "private": true
}


// File: tsconfig.json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}


// File: app\ErrorBoundary.tsx
// File: app/ErrorBoundary.tsx
import React from 'react';
import { View, Text } from 'react-native';
import { log } from './utils/logger';

interface ErrorBoundaryProps {
  children: React.ReactNode;
}

export class ErrorBoundary extends React.Component<ErrorBoundaryProps> {
  state = { hasError: false };

  static getDerivedStateFromError(error: Error) {
    return { hasError: true };
  }

  componentDidCatch(error: Error, info: any) {
    log.error("Uncaught error in component tree", { error, info });
    // If you use Sentry:
    // Sentry.captureException(error);
  }

  render() {
    if (this.state.hasError) {
      // Render fallback UI
      return (
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
          <Text>An unexpected error occurred.</Text>
        </View>
      );
    }
    return this.props.children;
  }
}


// File: app\index.tsx
import React, { useEffect, useState } from 'react';
import { ActivityIndicator, View } from 'react-native';
import { Provider } from 'react-redux';
import { QueryClient, QueryClientProvider } from 'react-query';
import { I18nextProvider } from 'react-i18next';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { ErrorBoundary } from './ErrorBoundary';
import { store } from './store';
import AppNavigator from './navigation/AppNavigator';
import { initI18n } from './i18n';
import { log } from './utils/logger';
import { StatusBar } from 'expo-status-bar';
import { SafeAreaProvider, SafeAreaView } from 'react-native-safe-area-context';
import { COLORS } from './theme/colors';

const queryClient = new QueryClient();

export default function App() {
  log.debug('App.tsx rendering...');

  const [i18nInstance, setI18nInstance] = useState<any>(null);

  useEffect(() => {
    const setupI18n = async () => {
      const i18n = await initI18n();   // now uses expo-localization under the hood
      setI18nInstance(i18n);
    };
    setupI18n();
  }, []);

  if (!i18nInstance) {
    // Still initializing i18n, show a loading indicator
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" />
      </View>
    );
  }

  return (
    <ErrorBoundary>
      <Provider store={store}>
        <QueryClientProvider client={queryClient}>
          {/* Provide the i18n instance to the app */}
          <I18nextProvider i18n={i18nInstance}>
            <GestureHandlerRootView>
                <StatusBar
                  style="dark"
                  backgroundColor={COLORS.primary} // allow content to appear behind status bar
                />
                <AppNavigator />
            </GestureHandlerRootView>
          </I18nextProvider>
        </QueryClientProvider>
      </Provider>
    </ErrorBoundary>
  );
}


// File: app\api\authService.ts
import api from './axiosConfig';
import { 
  UserLoginRequest, 
  UserLoginResponse, 
  RefreshTokenRequest, 
  AuthTokenResponse,
  UserRegistrationRequest
} from '../types/apiTypes';
import { log } from '../utils/logger';

export const authService = {
  login: async (data: UserLoginRequest): Promise<UserLoginResponse> => {
    const response = await api.post<UserLoginResponse>('/auth/login', data);
    return response.data;
  },
  refreshToken: async (data: RefreshTokenRequest): Promise<AuthTokenResponse> => {
    const response = await api.post<AuthTokenResponse>('/auth/refresh', data);
    return response.data;
  },
  register: async (data: UserRegistrationRequest): Promise<UserLoginResponse> => {
    const response = await api.post<UserLoginResponse>('/users/register', data);
    log.debug('response', response);
    return response.data;
  },
  logout: async (): Promise<void> => {
    await api.post('/auth/logout');
  },
};


// File: app\api\axiosConfig.ts
// File: app/api/axiosConfig.ts
import axios from "axios";
import { store } from "../store"; // your Redux store
import { refreshTokenThunk, logout } from "../features/auth/store/authSlice";
import { setGlobalError } from "../store/slices/globalErrorSlice";
import { RootState } from "../store"; // your root state type
import { AuthTokenResponse } from "../types/apiTypes";
import { log } from "../utils/logger";

let isRefreshing = false;
let pendingRequests: Array<(token: string) => void> = [];

const api = axios.create({
  baseURL: "http://192.168.137.1:5020/api",
  timeout: 10000,
});

// ────────────────────────────────────────────────────────────────────────────────
// REQUEST INTERCEPTOR
// ────────────────────────────────────────────────────────────────────────────────
api.interceptors.request.use(
  async (config) => {
    // Do not add an Authorization header for refresh requests
    if (config.url && config.url.includes("/auth/refresh")) {
      log.debug("API Request (refresh)", {
        baseUrl: api.defaults.baseURL,
        url: config.url,
        method: config.method,
        data: config.data,
        headers: config.headers,
      });
      return config;
    }
    log.debug("API Request (refresh)", {
      baseUrl: api.defaults.baseURL,
      url: config.url,
      method: config.method,
      data: config.data,
      headers: config.headers,
    });
    const state: RootState = store.getState();
    const token = state.auth.accessToken;
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    log.error("API Request Error", error);
    return Promise.reject(error);
  }
);

// ────────────────────────────────────────────────────────────────────────────────
// RESPONSE INTERCEPTOR
// ────────────────────────────────────────────────────────────────────────────────
api.interceptors.response.use(
  (response) => {
    log.debug("API Response", {
      url: response.config.url,
      status: response.status,
      data: response.data,
      headers: response.headers,
    });
    return response;
  },
  async (error) => {
    // If there's no response (network error), dispatch a global error
    if (!error.response) {
      store.dispatch(setGlobalError("Network Error: Unable to connect."));
      return Promise.reject(error);
    }

    const { status } = error.response;
    const originalRequest = error.config;

    // ─────────────────────────────────────────────────────────────
    // If the failing request is the refresh endpoint itself, then
    // do not attempt another refresh; immediately log out.
    // ─────────────────────────────────────────────────────────────
    if (
      originalRequest.url &&
      originalRequest.url.includes("/auth/refresh")
    ) {
      log.error(
        "Refresh endpoint failed. Forcing logout.",
        error.response.data
      );
      store.dispatch(logout());
      return Promise.reject(error);
    }

    // ─────────────────────────────────────────────────────────────
    // 1. Handle 401 Unauthorized for token refresh
    // ─────────────────────────────────────────────────────────────
    if (status === 401 && !originalRequest._retry) {
      if (!isRefreshing) {
        isRefreshing = true;
        originalRequest._retry = true;
        try {
          log.debug("Refreshing token...");
          const result = await store.dispatch(refreshTokenThunk());
          let newTokens: AuthTokenResponse | undefined;
          if (refreshTokenThunk.fulfilled.match(result)) {
            newTokens = result.payload;
            log.debug("New tokens:", newTokens);
          } else {
            log.error(
              "Token refresh failed:",
              result.payload || result.error.message
            );
          }
          isRefreshing = false;
          pendingRequests.forEach((cb) =>
            cb(newTokens?.accessToken || "")
          );
          pendingRequests = [];
          // Retry the original request with the new token.
          return api(originalRequest);
        } catch (refreshError) {
          log.error("Refresh token failed, logging out:", refreshError);
          isRefreshing = false;
          pendingRequests = [];
          store.dispatch(logout());
          return Promise.reject(refreshError);
        }
      }
      // If a refresh is already in progress, queue this request.
      return new Promise((resolve) => {
        pendingRequests.push((token: string) => {
          originalRequest.headers.Authorization = `Bearer ${token}`;
          resolve(api(originalRequest));
        });
      });
    }

    // ─────────────────────────────────────────────────────────────
    // 2. Other errors
    // ─────────────────────────────────────────────────────────────
    let errorMessage: string;
    if (typeof error.response.data === "string") {
      errorMessage = error.response.data;
    } else if (error.response.data?.message) {
      errorMessage = error.response.data.message;
    } else {
      errorMessage = "An error occurred. Please try again later.";
    }
    store.dispatch(setGlobalError(errorMessage));
    return Promise.reject(error);
  }
);

export default api;


// File: app\api\connectionService.ts
import api from "./axiosConfig";
import {
  ConnectionResponse,
  TradeProposalRequest,
  TradeProposalResponse,
  UpdateTradeProposalStatusRequest,
} from "../types/apiTypes";

export const connectionService = {

  getMyConnections: async (): Promise<ConnectionResponse[]> => {
    const response = await api.get<ConnectionResponse[]>("/connections/me");
    return response.data;
  },

  getConnectionById: async (connectionId: number): Promise<ConnectionResponse> => {
    const response = await api.get<ConnectionResponse>(`/connections/${connectionId}`);
    return response.data;
  },

  getTradeProposals: async (connectionId: number): Promise<TradeProposalResponse[]> => {
    const response = await api.get<TradeProposalResponse[]>(`/connections/${connectionId}/proposals`);
    return response.data;
  },

  createTradeProposal: async (
    connectionId: number,
    data: TradeProposalRequest
  ): Promise<TradeProposalResponse> => {
    const response = await api.post<TradeProposalResponse>(
      `/connections/${connectionId}/proposals`,
      data
    );
    return response.data;
  },

  updateTradeProposalStatus: async (
    connectionId: number,
    proposalId: number,
    data: UpdateTradeProposalStatusRequest
  ): Promise<void> => {
    await api.put(`/connections/${connectionId}/proposals/${proposalId}/status`, data);
  },

  confirmTradeProposalCompletion: async (
    connectionId: number,
    proposalId: number
  ): Promise<void> => {
    await api.put(`/connections/${connectionId}/proposals/${proposalId}/confirm-completion`);
  },
};


// File: app\api\matchService.ts
import api from './axiosConfig';
import { MatchResponse } from '../types/apiTypes';

export const matchService = {
  getMyMatchesForConnectionId: async (connectionId: number): Promise<MatchResponse[]> => {
    const response = await api.get<MatchResponse[]>(`/matches/connection/${connectionId}`);
    return response.data;
  },
};


// File: app\api\messageService.ts
import api from './axiosConfig';
import { MessageRequest, MessageResponse } from '../types/apiTypes';

export const messageService = {
  getMessagesForConnection: async (connectionId: number): Promise<MessageResponse[]> => {
    const response = await api.get<MessageResponse[]>(`/connections/${connectionId}/messages`);
    return response.data;
  },
  
  sendMessage: async (connectionId: number, data: MessageRequest): Promise<MessageResponse> => {
    const response = await api.post<MessageResponse>(`/connections/${connectionId}/messages/user/me`, data);
    return response.data;
  },
};


// File: app\api\plantService.ts
import api from "./axiosConfig";
import {
  PlantCreateRequest,
  PlantResponse,
  PlantRequest,
} from "../types/apiTypes";

export const plantService = {
  addMyPlant: async (data: PlantCreateRequest): Promise<PlantResponse> => {
    const formData = new FormData();

    // Use the prefix "PlantDetails." for fields of the nested PlantDetails object
    formData.append("Image", data.image); // Keep top-level if matching the property name in PlantCreateRequest
    formData.append("PlantDetails.SpeciesName", data.plantDetails.speciesName);
    formData.append(
      "PlantDetails.PlantStage",
      String(data.plantDetails.plantStage)
    );

    formData.append(
      "PlantDetails.Description",
      data.plantDetails.description ?? ""
    );
    formData.append(
      "PlantDetails.PlantCategory",
      data.plantDetails.plantCategory != null
        ? String(data.plantDetails.plantCategory)
        : ""
    );
    formData.append(
      "PlantDetails.WateringNeed",
      data.plantDetails.wateringNeed != null
        ? String(data.plantDetails.wateringNeed)
        : ""
    );
    formData.append(
      "PlantDetails.LightRequirement",
      data.plantDetails.lightRequirement != null
        ? String(data.plantDetails.lightRequirement)
        : ""
    );
    formData.append(
      "PlantDetails.Size",
      data.plantDetails.size != null ? String(data.plantDetails.size) : ""
    );
    formData.append(
      "PlantDetails.IndoorOutdoor",
      data.plantDetails.indoorOutdoor != null
        ? String(data.plantDetails.indoorOutdoor)
        : ""
    );
    formData.append(
      "PlantDetails.PropagationEase",
      data.plantDetails.propagationEase != null
        ? String(data.plantDetails.propagationEase)
        : ""
    );
    formData.append(
      "PlantDetails.PetFriendly",
      data.plantDetails.petFriendly != null
        ? String(data.plantDetails.petFriendly)
        : ""
    );

    if (data.plantDetails.extras && data.plantDetails.extras.length > 0) {
      data.plantDetails.extras.forEach((extra) => {
        // Append each extra with the same key using the dot notation prefix
        formData.append("PlantDetails.Extras", String(extra));
      });
    }

    const response = await api.post<PlantResponse>("/plants/me", formData, {
      headers: { "Content-Type": "multipart/form-data" },
    });

    return response.data;
  },

  getPlantById: async (plantId: number): Promise<PlantResponse> => {
    const response = await api.get<PlantResponse>(`/plants/${plantId}`);
    return response.data;
  },

  updateMyPlant: async (
    plantId: number,
    data: PlantRequest
  ): Promise<PlantResponse> => {
    // Here just sending JSON request body
    const response = await api.put<PlantResponse>(
      `/plants/me/${plantId}`,
      data
    );
    return response.data;
  },

  deleteMyPlant: async (plantId: number): Promise<void> => {
    await api.delete(`/plants/me/${plantId}`);
  },

  getUserPlants: async (userId: number): Promise<PlantResponse[]> => {
    const response = await api.get<PlantResponse[]>(`/plants/users/${userId}`);
    return response.data;
  },

  getMyPlants: async (): Promise<PlantResponse[]> => {
    const response = await api.get<PlantResponse[]>("/plants/users/me");
    return response.data;
  },

  getLikablePlants: async (): Promise<PlantResponse[]> => {
    const response = await api.get<PlantResponse[]>('/plants/likable');
    return response.data;
  },

  getPlantsLikedByMeFromUser: async (otherUserId: number): Promise<PlantResponse[]> => {
    const response = await api.get<PlantResponse[]>(`/plants/liked-by-me/from/${otherUserId}`);
    return response.data;
  },

  getPlantsLikedByUserFromMe: async (otherUserId: number): Promise<PlantResponse[]> => {
    const response = await api.get<PlantResponse[]>(`/plants/liked-by/${otherUserId}/from-me`);
    return response.data;
  },

  markPlantsAsTraded: async (plantIds: number[]): Promise<void> => {
    await api.post('/plants/mark-as-traded', plantIds);
  }
};


// File: app\api\reportService.ts
import api from './axiosConfig';
import { ReportRequest, ReportResponse } from '../types/apiTypes';

export const reportService = {
  createReport: async (data: ReportRequest): Promise<ReportResponse> => {
    const response = await api.post<ReportResponse>('/reports', data);
    return response.data;
  }
};


// File: app\api\swipeService.ts
import api from './axiosConfig';
import { SwipeRequest, SwipeResponse, PlantResponse } from '../types/apiTypes';

export const swipeService = {
  sendSwipes: async (swipes: SwipeRequest[]): Promise<SwipeResponse[]> => {
    const response = await api.post<SwipeResponse[]>('/swipes/me', swipes);
    return response.data;
  },
  
};


// File: app\api\userPreferencesService.ts
import api from './axiosConfig';
import { UserPreferencesResponse, UserPreferencesRequest } from '../types/apiTypes';

export const userPreferencesService = {
  getPreferences: async (): Promise<UserPreferencesResponse> => {
    const response = await api.get<UserPreferencesResponse>('/userpreferences');
    return response.data;
  },
  updatePreferences: async (data: UserPreferencesRequest): Promise<UserPreferencesResponse> => {
    const response = await api.post<UserPreferencesResponse>('/userpreferences', data);
    return response.data;
  }
};


// File: app\api\userService.ts
import api from './axiosConfig';
import { UserResponse, UserUpdateRequest, UserProfileImageUpdateRequest, UpdateLocationRequest } from '../types/apiTypes';

export const userService = {
  register: async (data: { Email: string; Password: string; Name: string }): Promise<UserResponse> => {
    const response = await api.post<UserResponse>('/users/register', data);
    return response.data;
  },
  getUser: async (userId: number): Promise<UserResponse> => {
    const response = await api.get<UserResponse>(`/users/${userId}`);
    return response.data;
  },
  updateMe: async (data: UserUpdateRequest): Promise<UserResponse> => {
    const response = await api.put<UserResponse>('/users/me', data);
    return response.data;
  },
  deleteMe: async (): Promise<void> => {
    await api.delete('/users/me');
  },
  updateProfilePicture: async (data: UserProfileImageUpdateRequest): Promise<UserResponse> => {
    const formData = new FormData();
    formData.append('Image', data.image);
    const response = await api.put<UserResponse>('/users/me/profile-picture', formData, {
      headers: { 'Content-Type': 'multipart/form-data' }
    });
    return response.data;
  },
  updateLocation: async (data: UpdateLocationRequest): Promise<void> => {
    await api.put('/users/me/location', data);
  },

  getCurrentUserProfile: async (): Promise<UserResponse> => {
    const response = await api.get<UserResponse>('/users/me');
    return response.data;
  },
};


// File: app\components\index.ts


// File: app\components\common\TextInputField.tsx
import React from 'react';
import { TextInput, View, StyleSheet } from 'react-native';

interface Props {
  value: string;
  onChangeText: (text: string) => void;
  placeholder?: string;
  secureTextEntry?: boolean;
}

const TextInputField: React.FC<Props> = ({ value, onChangeText, placeholder, secureTextEntry }) => {
  return (
    <View style={styles.container}>
      <TextInput 
        style={styles.input}
        value={value}
        onChangeText={onChangeText}
        placeholder={placeholder}
        secureTextEntry={secureTextEntry}
        placeholderTextColor="#999"
      />
    </View>
  );
};

export default TextInputField;

const styles = StyleSheet.create({
  container: {
    borderWidth:1,
    borderColor:'#ccc',
    borderRadius:8,
    marginTop:10,
  },
  input: {
    padding:12,
    fontSize:16,
  }
});


// File: app\components\feedback\ErrorMessage.tsx
import React from 'react';
import { Text, StyleSheet, View } from 'react-native';

interface Props {
  message: string | null;
}

const ErrorMessage: React.FC<Props> = ({ message }) => {
  if (!message) return null;
  return (
    <View style={styles.container}>
      <Text style={styles.text}>{message}</Text>
    </View>
  );
};

export default ErrorMessage;

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#FF6B6B',
    padding: 10,
    marginBottom:10,
    borderRadius:8
  },
  text: {
    color: '#fff',
    fontWeight:'500',
    textAlign:'center'
  }
});


// File: app\components\feedback\ErrorState.tsx


// File: app\components\feedback\LoadingSpinner.tsx


// File: app\context\AuthContext.tsx


// File: app\features\auth\index.ts


// File: app\features\auth\hooks\useAuth.ts


// File: app\features\auth\screens\LoginScreen.tsx
import React, { useState } from 'react';
import {
  View,
  Text,
  Image,
  KeyboardAvoidingView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  ScrollView,
  Platform,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { useTranslation } from 'react-i18next';
import { LinearGradient } from 'expo-linear-gradient';

import { useAppSelector, useAppDispatch } from '../../../store/hooks';
import { RootState } from '../../../store';
import { loginThunk } from '../store/authSlice';
import TextInputField from '../../../components/common/TextInputField';
import ErrorMessage from '../../../components/feedback/ErrorMessage';

import { COLORS } from '../../../theme/colors';
import { log } from '../../../utils/logger';
import { UserLoginRequest } from '../../../types/apiTypes';

// Import the shared auth styles
import { authStyles as styles } from '../styles/authStyles'; // <- Adjust path if needed

const LoginScreen = () => {
  const { t } = useTranslation();
  const dispatch = useAppDispatch();
  const navigation = useNavigation();
  const [loading, setLoading] = useState(false);

  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const { status, error } = useAppSelector((state: RootState) => state.auth);

  const handleLogin = async () => {
    if (!email.trim() || !password.trim()) {
      Alert.alert(t('error_title'), t('Please enter your email and password.'));
      return;
    }
    const userLoginRequest: UserLoginRequest = {
      email: email.trim(),
      password: password.trim(),
    };
    log.debug('Pressed login button, userLoginRequest:', userLoginRequest);
    await dispatch(loginThunk(userLoginRequest));
  };

  return (
    <LinearGradient
      colors={[COLORS.primary, COLORS.secondary]}
      style={styles.gradientBackground}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : undefined}
          style={styles.keyboardAvoid}
        >
          <View style={styles.logoContainer}>
            <Image
              source={require('../../../../assets/images/logo.png')}
              style={styles.logo}
            />
          </View>

          <View style={styles.cardContainer}>
            <Text style={styles.title}>{t('welcome_back')}</Text>

            <ErrorMessage message={error} />

            {/* Email */}
            <TextInputField
              value={email}
              onChangeText={setEmail}
              placeholder={t('email')}
            />

            {/* Password */}
            <TextInputField
              value={password}
              onChangeText={setPassword}
              placeholder={t('password')}
              secureTextEntry
            />

            {/* Submit */}
            <TouchableOpacity
              style={styles.confirmButton}
              onPress={handleLogin}
              disabled={loading}
            >
              {loading ? (
                <ActivityIndicator size="small" color={COLORS.accentGreen} />
              ) : (
                <Text style={styles.confirmButtonText}>{t('login_button')}</Text>
              )}
            </TouchableOpacity>

            {/* Register link */}
            <TouchableOpacity
              onPress={() => navigation.navigate('Register' as never)}
              style={styles.navLinkContainer}
            >
              <Text style={styles.navLinkText}>
                {t('no_account_register')}
              </Text>
            </TouchableOpacity>
          </View>
        </KeyboardAvoidingView>
      </ScrollView>
    </LinearGradient>
  );
};

export default LoginScreen;


// File: app\features\auth\screens\RegisterScreen.tsx
import React, { useState } from 'react';
import {
  View,
  Text,
  Image,
  KeyboardAvoidingView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  ScrollView,
  Platform,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { useTranslation } from 'react-i18next';
import { LinearGradient } from 'expo-linear-gradient';

import { useAppSelector, useAppDispatch } from '../../../store/hooks';
import { RootState } from '../../../store';
import { registerThunk } from '../store/authSlice';
import TextInputField from '../../../components/common/TextInputField';
import ErrorMessage from '../../../components/feedback/ErrorMessage';

import { COLORS } from '../../../theme/colors';
import { log } from '../../../utils/logger';
import { UserRegistrationRequest } from '../../../types/apiTypes';

// Import the shared auth styles
import { authStyles as styles } from '../styles/authStyles'; // <- Adjust path if needed

const RegisterScreen = () => {
  const { t } = useTranslation();
  const dispatch = useAppDispatch();
  const navigation = useNavigation();
  const [loading, setLoading] = useState(false);
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const { status, error } = useAppSelector((state: RootState) => state.auth);

  const handleRegister = async () => {
    if (!name.trim() || !email.trim() || !password.trim()) {
      Alert.alert(t('error_title'), t('Please fill all fields.'));
      return;
    }
    const userRegistrationRequest: UserRegistrationRequest = {
      email: email.trim(),
      password: password.trim(),
      name: name.trim(),
    };
    log.debug('Pressed register button, userRegistrationRequest:', userRegistrationRequest);
    await dispatch(registerThunk(userRegistrationRequest));
  };

  return (
    <LinearGradient
      colors={[COLORS.primary, COLORS.secondary]}
      style={styles.gradientBackground}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : undefined}
          style={styles.keyboardAvoid}
        >
          <View style={styles.logoContainer}>
            <Image
              source={require('../../../../assets/images/logo.png')}
              style={styles.logo}
            />
          </View>

          <View style={styles.cardContainer}>
            <Text style={styles.title}>{t('create_account')}</Text>

            <ErrorMessage message={error} />

            {/* Name */}
            <TextInputField
              value={name}
              onChangeText={setName}
              placeholder={t('name')}
            />

            {/* Email */}
            <TextInputField
              value={email}
              onChangeText={setEmail}
              placeholder={t('email')}
            />

            {/* Password */}
            <TextInputField
              value={password}
              onChangeText={setPassword}
              placeholder={t('password')}
              secureTextEntry
            />

            {/* Submit */}
            <TouchableOpacity
              style={styles.confirmButton}
              onPress={handleRegister}
              disabled={loading}
            >
              {loading ? (
                <ActivityIndicator size="small" color={COLORS.accentGreen} />
              ) : (
                <Text style={styles.confirmButtonText}>
                  {t('register_button')}
                </Text>
              )}
            </TouchableOpacity>

            {/* Already have account */}
            <TouchableOpacity
              onPress={() => navigation.navigate('Login' as never)}
              style={styles.navLinkContainer}
            >
              <Text style={styles.navLinkText}>
                {t('have_account_login')}
              </Text>
            </TouchableOpacity>
          </View>
        </KeyboardAvoidingView>
      </ScrollView>
    </LinearGradient>
  );
};

export default RegisterScreen;


// File: app\features\auth\store\authSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { authService } from '../../../api/authService';
import { storage } from '../../../utils/storage';
import { RootState } from '../../../store';
import { 
  UserLoginRequest, 
  UserLoginResponse, 
  UserRegistrationRequest, 
  RefreshTokenRequest, 
  AuthTokenResponse
} from '../../../types/apiTypes';

import { log } from '../../../utils/logger';
import {useQueryClient} from 'react-query';

interface AuthState {
  accessToken: string | null;
  refreshToken: string | null;
  status: 'idle' | 'loading' | 'error';
  error: string | null;
}

const initialState: AuthState = {
  accessToken: null,
  refreshToken: null,
  status: 'idle',
  error: null
};

export const loginThunk = createAsyncThunk<
  UserLoginResponse,    // On success, returns UserLoginResponse
  UserLoginRequest,     // The argument type is UserLoginRequest
  { rejectValue: string }
>(
  'auth/login',
  async (credentials, { rejectWithValue }) => {
    try {
      const data = await authService.login(credentials);
      // Store tokens securely
      log.debug('loginThunk data:', data);
      await storage.saveTokens(data.tokens.accessToken, data.tokens.refreshToken);
      return data;
    } catch (error: any) {
      // 1) Log everything about the error before rejecting
      log.error("Login error details:", error);

      return rejectWithValue(error.response?.data?.message || 'Login failed');
    }
  }
);

export const registerThunk = createAsyncThunk<
  UserLoginResponse,
  UserRegistrationRequest,
  { rejectValue: string }
>(
  'auth/register',
  async (payload, { rejectWithValue }) => {
    try {
      const data = await authService.register(payload);
      await storage.saveTokens(data.tokens.accessToken, data.tokens.refreshToken);
      return data;
    } catch (error: any) {
      // 1) Log everything about the error before rejecting
      log.error("Registration error details:", error);

      // 2) If we have an error.response, log its data
      if (error.response) {
        log.error("Registration error response data:", error.response.data);
        log.error("Registration error response status:", error.response.status);
        log.error("Registration error response headers:", error.response.headers);
      } else {
        log.error("Registration error: no response object", error.message);
      }
      return rejectWithValue(error.response?.data || 'Registration failed');
    }
  }
);

export const refreshTokenThunk = createAsyncThunk<
  AuthTokenResponse,
  void,
  { state: RootState; rejectValue: string }
>(
  'auth/refreshToken',
  async (_, { getState, rejectWithValue }) => {
    const state = getState();
    const refreshToken = state.auth.refreshToken;
    if (!refreshToken) {
      return rejectWithValue('No refresh token available');
    }
    const payload: RefreshTokenRequest = { refreshToken: refreshToken };
    try {
      const data = await authService.refreshToken(payload);
      await storage.saveTokens(data.accessToken, data.refreshToken);
      return data;
    } catch (error: any) {
      return rejectWithValue('Token refresh failed');
    }
  }
);

export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    setInitialTokens(
      state,
      action: PayloadAction<{ accessToken: string | null; refreshToken: string | null }>
    ) {
      state.accessToken = action.payload.accessToken;
      state.refreshToken = action.payload.refreshToken;
    },
    logout(state) {
      state.accessToken = null;
      state.refreshToken = null;
      state.error = null;
      state.status = 'idle';
    }
  },
  extraReducers: (builder) => {
    builder
      // loginThunk
      .addCase(loginThunk.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(loginThunk.fulfilled, (state, action) => {
        state.status = 'idle';
        // action.payload: UserLoginResponse
        state.accessToken = action.payload.tokens.accessToken;
        state.refreshToken = action.payload.tokens.refreshToken;
      })
      .addCase(loginThunk.rejected, (state, action) => {
        state.status = 'error';
        state.error = action.payload || 'Unknown error';
      })

      // registerThunk
      .addCase(registerThunk.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(registerThunk.fulfilled, (state, action) => {
        state.status = 'idle';
        // action.payload: UserLoginResponse
        state.accessToken = action.payload.tokens.accessToken;
        state.refreshToken = action.payload.tokens.refreshToken;
      })
      .addCase(registerThunk.rejected, (state, action) => {
        state.status = 'error';
        state.error = action.payload || 'Unknown error';
      })

      // refreshTokenThunk
      .addCase(refreshTokenThunk.fulfilled, (state, action) => {
        // action.payload: AuthTokenResponse
        state.accessToken = action.payload.accessToken;
        state.refreshToken = action.payload.refreshToken;
      })
      .addCase(refreshTokenThunk.rejected, (state) => {
        // If refresh fails, clear credentials
        state.accessToken = null;
        state.refreshToken = null;
        state.error = null;
        state.status = 'idle';
r      });
  }
});

export const { logout, setInitialTokens } = authSlice.actions;


// File: app\features\auth\styles\authStyles.ts
import { StyleSheet, Platform } from 'react-native';
import { COLORS } from '../../../theme/colors';

export const authStyles = StyleSheet.create({
  gradientBackground: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    justifyContent: 'center',
  },
  keyboardAvoid: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 24,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  logo: {
    width: 200,
    height: 200,
    resizeMode: 'contain',
    borderRadius: 10,
  },
  cardContainer: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 20,
    marginHorizontal: 4,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOpacity: 0.1,
        shadowRadius: 5,
        shadowOffset: { width: 0, height: 3 },
      },
      android: {
        elevation: 3,
      },
    }),
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
    color: COLORS.textDark,
    textAlign: 'center',
  },
  // Common navigation link styling ("Register" or "Login")

  navLinkContainer: {
    marginTop: 20,
    alignSelf: 'center',
  },
  navLinkText: {
    color: COLORS.accentGreen,
    fontSize: 14,
    fontWeight: '600',
  },
  confirmButton: {
    backgroundColor: COLORS.accentGreen,
    borderRadius: 8,
    padding: 13,
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 20,
  },
  confirmButtonText: {
    fontSize: 14,
    color: COLORS.textLight,
    fontWeight: '600',
    textAlign: 'center',
  },
});


// File: app\features\auth\types\authTypes.ts


// File: app\features\main\index.ts


// File: app\features\main\components\ChatShelf.tsx
import React, {
  useState,
  useRef,
  useCallback,
  memo,
  forwardRef,
  useImperativeHandle,
} from 'react';
import {
  Animated,
  Easing,
  View,
  TouchableOpacity,
  StyleSheet,
  LayoutChangeEvent,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

import { COLORS } from '../../../theme/colors';
import { PlantCardWithInfo } from './PlantCardWithInfo';
import { PlantResponse } from '../../../types/apiTypes';
import { log } from '../../../utils/logger';

export interface ChatShelfRef {
  toggleShelf: () => void;
  openShelf: () => void;
  closeShelf: () => void;
}

interface ChatShelfProps {
  plant1?: PlantResponse;
  plant2?: PlantResponse;
}

// Wrap with forwardRef to expose imperative methods
const ChatShelf = forwardRef<ChatShelfRef, ChatShelfProps>(
  function ChatShelf({ plant1, plant2 }, ref) {
    const [isShelfOpen, setIsShelfOpen] = useState(true);
    const [maxShelfHeight, setMaxShelfHeight] = useState<number>(0);
    const shelfAnim = useRef(new Animated.Value(0)).current;

    const handleShelfLayout = useCallback(
      (event: LayoutChangeEvent) => {
        const { height } = event.nativeEvent.layout;
        log.debug('Measured layout height:', height);
        if (height > maxShelfHeight) {
          setMaxShelfHeight(height);
          // Keep shelf fully open if we are currently open
          if (isShelfOpen) {
            shelfAnim.setValue(height);
          }
        }
      },
      [isShelfOpen, maxShelfHeight, shelfAnim]
    );

    // The actual animation
    const animateTo = useCallback(
      (toValue: number) => {
        Animated.timing(shelfAnim, {
          toValue,
          duration: 300,
          easing: Easing.ease,
          useNativeDriver: false,
        }).start();
      },
      [shelfAnim]
    );

    const toggleShelf = useCallback(() => {
      if (!maxShelfHeight) return; // if not measured, skip
      const collapsedHeight = styles.shelfToggleButton.height;
      const targetValue = isShelfOpen ? collapsedHeight : maxShelfHeight;
      animateTo(targetValue);
      setIsShelfOpen(!isShelfOpen);
    }, [isShelfOpen, maxShelfHeight, animateTo]);

    const closeShelf = useCallback(() => {
      if (!maxShelfHeight) return;
      if (isShelfOpen) {
        const collapsedHeight = styles.shelfToggleButton.height;
        animateTo(collapsedHeight);
        setIsShelfOpen(false);
      }
    }, [isShelfOpen, maxShelfHeight, animateTo]);

    const openShelf = useCallback(() => {
      if (!maxShelfHeight) return;
      if (!isShelfOpen) {
        animateTo(maxShelfHeight);
        setIsShelfOpen(true);
      }
    }, [isShelfOpen, maxShelfHeight, animateTo]);

    /**
     * Expose these methods via useImperativeHandle
     */
    useImperativeHandle(ref, () => ({
      toggleShelf,
      closeShelf,
      openShelf,
    }));

    // If not yet measured, don't force any height. Otherwise, animate the height with shelfAnim.
    const containerStyle = maxShelfHeight > 0 ? { height: shelfAnim } : undefined;

    return (
      <Animated.View style={[styles.animatedShelf, containerStyle]}>
        <View style={styles.shelfInnerContainer} onLayout={handleShelfLayout}>
          <View style={styles.plantCardWrapper}>
            {plant1 && <PlantCardWithInfo plant={plant1} compact />}
          </View>
          <View style={styles.plantCardWrapper}>
            {plant2 && <PlantCardWithInfo plant={plant2} compact />}
          </View>
        </View>

        {/* The toggle handle pinned at the bottom */}
        <TouchableOpacity
          style={styles.shelfToggleButton}
          onPress={toggleShelf}
          activeOpacity={0.7}
        >
          <Ionicons
            name={isShelfOpen ? 'chevron-up-outline' : 'chevron-down-outline'}
            size={10}
            color="#fff"
          />
        </TouchableOpacity>
      </Animated.View>
    );
  }
);

export default memo(ChatShelf);

const styles = StyleSheet.create({
  animatedShelf: {
    overflow: 'hidden',
    backgroundColor: '#f1f1f1',
  },
  shelfInnerContainer: {
    flexDirection: 'row',
    justifyContent: 'space-evenly',
    paddingHorizontal: 12,
    paddingVertical: 8,
    paddingBottom: 23,
  },
  plantCardWrapper: {
    width: '45%',
    borderRadius: 8,
    alignSelf: 'center',
  },
  shelfToggleButton: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    height: 15,
    backgroundColor: COLORS.accentGreen,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
});


// File: app\features\main\components\CompletedTradeActions.tsx
import React from "react";
import {
  StyleSheet,
  Text,
  View,
  TouchableOpacity,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { COLORS } from "../../../theme/colors";
import PlantThumbnail from "./PlantThumbnail";

type CompletedTradeActionsProps = {
  plants: any[];
  proposalId: number;
  onConfirmDecisions: (proposalId: number, plantsToDelete: number[]) => void;
  onPlantInfoPress?: (plant: any) => void;
  isConfirming?: boolean; // optional loading state if you'd like to disable the button
};

const CompletedTradeActions: React.FC<CompletedTradeActionsProps> = ({
  plants,
  proposalId,
  onConfirmDecisions,
  onPlantInfoPress,
  isConfirming = false,
}) => {
  // "deleted" or "keep" or undefined if not yet decided
  const [decisions, setDecisions] = React.useState<{
    [plantId: number]: "delete" | "keep" | undefined;
  }>({});

  const markPlant = (
    plantId: number,
    decision: "delete" | "keep" | undefined
  ) => {
    setDecisions((prev) => ({ ...prev, [plantId]: decision }));
  };

  // Determine if all plants have a decision
  const allDecided =
    plants.length > 0 &&
    plants.every((p) => decisions[p.plantId] !== undefined);

  // Handle confirm (call the parent’s callback)
  const handleConfirm = () => {
    // Gather plant IDs marked for deletion
    const plantsToDelete = plants
      .filter((p) => decisions[p.plantId] === "delete")
      .map((p) => p.plantId);

    onConfirmDecisions(proposalId, plantsToDelete);
  };

  return (
    <View style={styles.completedSection}>
      <Text style={styles.completedPrompt}>
        Trade complete – choose your action for your plants:
      </Text>
      <View style={styles.plantGrid}>
        {plants.map((plant) => {
          const decision = decisions[plant.plantId];
          return (
            <View key={plant.plantId} style={styles.plantThumbnailContainer}>
              <PlantThumbnail
                plant={plant}
                selectable={false}
                onInfoPress={() =>
                  onPlantInfoPress && onPlantInfoPress(plant)
                }
              />
              {decision ? (
                <View style={styles.decisionRow}>
                  <View style={styles.decisionTag}>
                    <Text style={styles.decisionLabelText}>
                      {decision === "delete" ? "Delete" : "Keep"}
                    </Text>
                  </View>
                  <TouchableOpacity
                    style={styles.undoButton}
                    onPress={() => markPlant(plant.plantId, undefined)}
                  >
                    <Ionicons name="arrow-undo" size={14} color="#fff" />
                  </TouchableOpacity>
                </View>
              ) : (
                <View style={styles.plantActions}>
                  <TouchableOpacity
                    style={[
                      styles.plantActionButton,
                      styles.individualDeleteButton,
                    ]}
                    onPress={() => markPlant(plant.plantId, "delete")}
                  >
                    <Text style={styles.plantActionText}>Delete</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[
                      styles.plantActionButton,
                      styles.individualKeepButton,
                    ]}
                    onPress={() => markPlant(plant.plantId, "keep")}
                  >
                    <Text style={styles.plantActionText}>Keep</Text>
                  </TouchableOpacity>
                </View>
              )}
            </View>
          );
        })}
      </View>

      {/* "Confirm" button - only enable if all plants decided */}
      <TouchableOpacity
        style={[
          styles.confirmButton,
          (!allDecided || isConfirming) && styles.confirmButtonDisabled,
        ]}
        onPress={handleConfirm}
        disabled={!allDecided || isConfirming}
      >
        <Text style={styles.confirmButtonText}>
          {isConfirming ? "Processing..." : "Confirm"}
        </Text>
      </TouchableOpacity>
    </View>
  );
};

export default CompletedTradeActions;

const styles = StyleSheet.create({
  completedSection: {
    marginTop: 10,
    alignItems: "center",
  },
  completedPrompt: {
    fontSize: 14,
    marginBottom: 6,
    color: COLORS.textDark,
  },
  // Container for the plant grid instead of a scroll view
  plantGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "center",
    paddingHorizontal: 10,
  },
  plantThumbnailContainer: {
    margin: 5, // Increased margin to provide spacing between grid items
    alignItems: "center",
  },
  plantActions: {
    flexDirection: "row",
    marginTop: 4,
  },
  plantActionButton: {
    paddingVertical: 6,
    paddingHorizontal: 8,
    borderRadius: 6,
    marginHorizontal: 2,
  },
  plantActionText: {
    color: "#fff",
    fontSize: 12,
  },
  individualDeleteButton: {
    backgroundColor: COLORS.accentRed,
  },
  individualKeepButton: {
    backgroundColor: COLORS.accentGreen,
  },
  decisionRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 4,
  },
  decisionTag: {
    backgroundColor: "#ddd",
    borderRadius: 6,
    paddingHorizontal: 6,
    paddingVertical: 2,
  },
  decisionLabelText: {
    fontSize: 12,
    color: "#555",
    fontWeight: "600",
  },
  undoButton: {
    marginLeft: 6,
    backgroundColor: COLORS.accentOrange,
    paddingHorizontal: 6,
    paddingVertical: 4,
    borderRadius: 6,
  },
  confirmButton: {
    marginTop: 10,
    backgroundColor: COLORS.accentGreen,
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
  },
  confirmButtonDisabled: {
    backgroundColor: "#ccc",
  },
  confirmButtonText: {
    color: "#fff",
    fontWeight: "600",
    fontSize: 16,
  },
});


// File: app\features\main\components\ConfirmCancelButtons.tsx
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, ActivityIndicator } from 'react-native';
import { COLORS } from '../../../theme/colors';

interface ConfirmCancelButtonsProps {
  confirmButtonText: string;
  cancelButtonText: string;
  onConfirm: () => void;
  onCancel: () => void;
  loading?: boolean;
}

export const ConfirmCancelButtons: React.FC<ConfirmCancelButtonsProps> = ({
  confirmButtonText,
  cancelButtonText,
  onConfirm,
  onCancel,
  loading = false,
}) => {
  return (
    <View style={styles.actions}>
      <TouchableOpacity
        style={styles.confirmButton}
        onPress={onConfirm}
        disabled={loading}
      >
        {loading ? (
          <ActivityIndicator size="small" color="#fff" />
        ) : (
          <Text style={styles.confirmButtonText}>{confirmButtonText}</Text>
        )}
      </TouchableOpacity>

      <TouchableOpacity
        style={styles.cancelButton}
        onPress={onCancel}
        disabled={loading}
      >
        <Text style={styles.cancelButtonText}>{cancelButtonText}</Text>
      </TouchableOpacity>
    </View>
  );
};

export default ConfirmCancelButtons;

const styles = StyleSheet.create({
  actions: {
    flexDirection: 'column',
    justifyContent: 'flex-end',
  },
  confirmButton: {
    backgroundColor: COLORS.accentGreen,
    borderRadius: 8,
    padding: 13,
    alignItems: 'center',
    justifyContent: 'center',
  },
  confirmButtonText: {
    fontSize: 14,
    color: COLORS.textLight,
    fontWeight: '600',
    textAlign: 'center',
  },
  cancelButton: {
    borderWidth: 1,
    borderColor: COLORS.accentGreen,
    borderRadius: 8,
    padding: 13,
    marginTop: 6,
    alignItems: 'center',
    justifyContent: 'center',
  },
  cancelButtonText: {
    fontSize: 14,
    color: COLORS.accentGreen,
    fontWeight: '600',
    textAlign: 'center',
  },
});


// File: app\features\main\components\MatchCard.tsx
// MatchCard.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { MatchResponse } from '../../../types/apiTypes';
import PlantThumbnail from './PlantThumbnail';

interface MatchCardProps {
  match: MatchResponse;
  currentUserId: number;
}

const MatchCard: React.FC<MatchCardProps> = ({ match, currentUserId }) => {
  // Determine which plant is yours and which is your connection's.
  const currentUserPlant =
    match.plant1.userId === currentUserId ? match.plant1 : match.plant2;
  const connectionPlant =
    match.plant1.userId === currentUserId ? match.plant2 : match.plant1;

  return (
    <View style={styles.card}>
      <PlantThumbnail plant={currentUserPlant} selectable={false} />
      <PlantThumbnail plant={connectionPlant} selectable={false} />
    </View>
  );
};

export default MatchCard;

const styles = StyleSheet.create({
  card: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginVertical: 8,
    padding: 8,
    backgroundColor: '#fff',
    borderRadius: 12,
    shadowColor: '#000',
    shadowOpacity: 0.1,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 3 },
    elevation: 3,
  },
});


// File: app\features\main\components\MessageBubble.tsx
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MessageResponse } from '../../../types/apiTypes';
import { COLORS } from '../../../theme/colors';
import { Platform } from 'react-native';

interface BubbleProps {
  message: MessageResponse;
  isMine: boolean;
}
export const  MessageBubble: React.FC<BubbleProps> = ({ message, isMine }) => {
  return (
    <View
      style={[
        styles.bubbleContainer,
        isMine ? styles.bubbleRightContainer : styles.bubbleLeftContainer,
      ]}
    >
      <View style={[styles.bubble, isMine ? styles.bubbleRight : styles.bubbleLeft]}>
        <Text style={styles.bubbleText}>{message.messageText}</Text>
        <Text style={styles.timestamp}>
          {new Date(message.sentAt).toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit',
          })}
        </Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  bubbleContainer: {
    marginVertical: 3,
    },
  bubbleLeftContainer: {
    alignSelf: 'flex-start',
  },
  bubbleRightContainer: {
    alignSelf: 'flex-end',
  },
  bubble: {
    maxWidth: '80%',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 8,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOpacity: 0.1,
        shadowRadius: 5,
      },
      android: {
        elevation: 3,
      },
    }),
  },
  bubbleLeft: {
    backgroundColor: COLORS.bubbleLeft,
    borderTopLeftRadius: 0,
  },
  bubbleRight: {
    backgroundColor: COLORS.bubbleRight,
    borderTopRightRadius: 0,
  },
  bubbleText: {
    fontSize: 14,
    color: '#333',
  },
  timestamp: {
    marginTop: 5,
    fontSize: 10,
    color: '#777',
    textAlign: 'right',
  },
});


// File: app\features\main\components\MultiSelectTagGroup.tsx
// components/shared/MultiSelectTagGroup.tsx
import React from 'react';
import { View, TouchableOpacity, Text, StyleSheet } from 'react-native';

interface MultiSelectTagGroupProps<T extends string | number> {
  values: T[];
  selectedValues: T[];
  onToggle: (val: T) => void;
}

function MultiSelectTagGroup<T extends string | number>({
  values,
  selectedValues,
  onToggle,
}: MultiSelectTagGroupProps<T>) {
  return (
    <View style={styles.tagGroupContainer}>
      {values.map((val) => {
        const isSelected = selectedValues.includes(val);
        return (
          <TouchableOpacity
            key={String(val)}
            style={[
              styles.singleTag,
              isSelected && styles.singleTagSelected,
            ]}
            onPress={() => onToggle(val)}
          >
            <Text
              style={[
                styles.singleTagText,
                isSelected && styles.singleTagTextSelected,
              ]}
            >
              {val}
            </Text>
          </TouchableOpacity>
        );
      })}
    </View>
  );
}

export default MultiSelectTagGroup;

const styles = StyleSheet.create({
  tagGroupContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 6,
  },
  singleTag: {
    borderWidth: 1,
    borderColor: '#1EAE98', // or your "COLORS.primary"
    borderRadius: 20,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  singleTagSelected: {
    backgroundColor: '#1EAE98', // or your "COLORS.primary"
  },
  singleTagText: {
    fontSize: 12,
    color: '#1EAE98', // or your "COLORS.primary"
  },
  singleTagTextSelected: {
    color: '#fff',
    fontWeight: '600',
  },
});


// File: app\features\main\components\PlantCardWithInfo.tsx
// FullSizePlantCard.tsx

import React, { useState, useCallback } from 'react';
import {
    View,
    Image,
    StyleSheet,
    Platform,
    LayoutChangeEvent,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { COLORS } from '../../../theme/colors';
import { PlantOverlay } from '../components/PlantOverlay';
import { PlantResponse } from '../../../types/apiTypes';
import { LinearGradient } from 'expo-linear-gradient';

interface PlantCardWithInfoProps {
    plant: PlantResponse;
    compact?: boolean;
    /**
     * If true, the black extension height is dynamic (half the overlay).
     * If false, the black extension uses a fixed height.
     */
    isDynamic?: boolean;
    /**
     * When isDynamic=false, this sets the black extension height (default 120).
     */
    fixedExtensionHeight?: number;
}

export const PlantCardWithInfo: React.FC<PlantCardWithInfoProps> = ({
    plant,
    compact = false,
    isDynamic = true,
    fixedExtensionHeight = 120,
}) => {
    const [overlayHeight, setOverlayHeight] = useState(0);

    // Combine any tags for the overlay
    const allTags = [
        plant.plantStage,
        plant.plantCategory,
        plant.wateringNeed,
        plant.lightRequirement,
        plant.size,
        plant.indoorOutdoor,
        plant.propagationEase,
        plant.petFriendly,
        ...(plant.extras ?? []),
    ].filter(Boolean);

    /**
     * Only measure the overlay if dynamic. We store its height to compute extension.
     */
    const handleOverlayLayout = useCallback(
        (event: LayoutChangeEvent) => {
            if (isDynamic && overlayHeight === 0) { // Only set once
                const { height } = event.nativeEvent.layout;
                setOverlayHeight(height);
            }
        },
        [isDynamic, overlayHeight]
    );

    /**
     * If dynamic, black extension height = half the overlay’s measured height.
     * Otherwise, use the fixed extension height.
     */
    const blackExtensionHeight = isDynamic
        ? overlayHeight / 2
        : fixedExtensionHeight;

    return (
        <View style={styles.cardContainer}>
            {/* ---- Plant Image / Placeholder ---- */}
            <View style={styles.imageContainer}>
                {plant.imageUrl ? (
                    <Image
                        source={{ uri: plant.imageUrl }}
                        style={styles.fullImage}
                        resizeMode="contain"
                    />
                ) : (
                    <View style={styles.plantPlaceholder}>
                        <Ionicons name="leaf" size={60} color={COLORS.primary} />
                    </View>
                )}
                <LinearGradient colors={['rgba(0,0,0,0)', 'rgba(0,0,0,1)']} style={[styles.lowerGradient, { height: compact ? overlayHeight : overlayHeight * 1.5}]} />
            </View>

            {/* ---- Black Extension (dynamic or fixed) ---- */}
            <View
                style={[
                    styles.blackExtension,
                    { height: blackExtensionHeight },
                ]}
            />
            <View
                style={styles.overlayWrapper}
                onLayout={handleOverlayLayout}
            >
                <PlantOverlay
                    speciesName={plant.speciesName}
                    description={plant.description}
                    tags={allTags}
                    compact={compact}
                />
            </View>
            {/* 
        ---- Overlay Section ----
        The overlay will measure itself (if dynamic),
      */}
        </View>
    );
};

export default PlantCardWithInfo;

const styles = StyleSheet.create({
    cardContainer: {
        borderRadius: 8,
        overflow: 'hidden',
        backgroundColor: '#fff',
        ...Platform.select({
            ios: {
                shadowColor: '#000',
                shadowOpacity: 0.12,
                shadowRadius: 5,
                shadowOffset: { width: 0, height: 3 },
            },
            android: {
                elevation: 3,
            },
        }),
    },
    imageContainer: {
        width: '100%',
    },
    fullImage: {
        width: '100%',
        aspectRatio: 3 / 4,
    },
    plantPlaceholder: {
        width: '100%',
        aspectRatio: 3 / 4,
        backgroundColor: '#eee',
        justifyContent: 'center',
        alignItems: 'center',
    },
    lowerGradient: {
        position: 'absolute',
        bottom: -1,
        width: '100%',
    },

    blackExtension: {
        width: '100%',
        backgroundColor: '#000',
    },
    overlayWrapper: {
        position: 'absolute',
        bottom: 0,
        // We measure this layout if isDynamic=true, so we can
        // compute overlayHeight and adjust the extension accordingly.
        // The negative margin is applied dynamically above.
    },
});


// File: app\features\main\components\PlantOverlay.tsx
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { COLORS } from '../../../theme/colors'; 

interface PlantOverlayProps {
  speciesName: string;
  description?: string;
  tags?: string[];
  compact?: boolean;
}

export const PlantOverlay: React.FC<PlantOverlayProps> = ({ speciesName, description, tags = [], compact=false }) => (
  <View style={[styles.overlayContent, compact && styles.overlayContentCompact]}>
    <Text style={[styles.fullPlantName, compact && styles.fullPlantNameCompact]}>{speciesName}</Text>
    {tags.length > 0 && (
      <View style={[styles.tagRow, compact && styles.tagRowCompact]}>
        {tags.map((tag) => (
          <View key={tag} style={[styles.tag, compact && styles.tagCompact]}>
            <Text style={[styles.tagText, compact && styles.tagTextCompact]}>{tag}</Text>
          </View>
        ))}
      </View>
    )}
    {description ? (
      <Text style={[styles.fullDescription, compact && styles.fullDescriptionCompact]}>{description}</Text>
    ) : null}
  </View>
);

const styles = StyleSheet.create({
  overlayContent: {
    padding: 10,
    bottom: 0,
    marginBottom: 2,
    marginLeft: 4,
  },
  overlayContentCompact: {
    padding: 6,
    bottom: 0,
    marginBottom: 1,
    marginLeft: 2,
  },
  fullPlantName: {
    fontSize: 18,
    fontWeight: '700',
    color: '#fff',
    marginBottom: 6,
  },
  fullPlantNameCompact: {
    fontSize: 14,
    fontWeight: '700',
    color: '#fff',
    marginBottom: 3,
  },
  tagRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginLeft: -6,
  },
  tagRowCompact: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginLeft: -3,
  },
  tag: {
    backgroundColor: COLORS.accentGreen,
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 4,
    marginRight: 6,
    marginBottom: 6,
  },
  tagCompact: {
    backgroundColor: COLORS.accentGreen,
    borderRadius: 10,
    paddingHorizontal: 4,
    paddingVertical: 2,
    marginRight: 3,
    marginBottom: 3,
  },
  tagText: {
    color: COLORS.textLight,
    fontSize: 12,
    fontWeight: '600',
  },
  tagTextCompact: {
    color: COLORS.textLight,
    fontSize: 10,
    fontWeight: '600',
  },
  fullDescription: {
    color: COLORS.textLight,
    fontSize: 14,
    fontWeight: '400',
  },
  fullDescriptionCompact: {
    fontSize: 10,
    color: COLORS.textLight,
    fontWeight: '400',
  },
});


// File: app\features\main\components\PlantThumbnail.tsx
// File: app/features/main/components/PlantThumbnail.tsx
import React from 'react';
import { TouchableOpacity, View, Image, Text, StyleSheet, Platform, Dimensions, StyleProp, ViewStyle } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { COLORS } from '../../../theme/colors';
import { PlantResponse } from '../../../types/apiTypes';

const screenWidth = Dimensions.get('window').width;

export interface PlantThumbnailProps {
  plant: PlantResponse;
  onPress?: () => void;
  isSelected?: boolean;
  containerStyle?: StyleProp<ViewStyle>;
  selectable?: boolean;
  deletable?: boolean;
  OnDelete?: () => void;
  // <-- NEW prop for info icon press:
  onInfoPress?: () => void;
}

const PlantThumbnail: React.FC<PlantThumbnailProps> = ({
  plant,
  onPress,
  isSelected = false,
  containerStyle,
  selectable = false,
  deletable = false,
  OnDelete,
  onInfoPress,
}) => {
  return (
    <View style={[styles.outerContainer, isSelected && styles.selected]}>
      <TouchableOpacity
        style={[styles.mainContainer, containerStyle]}
        onPress={onPress}
        disabled={!selectable}
      >
        {plant.imageUrl ? (
          <Image
            source={{ uri: plant.imageUrl }}
            style={styles.thumbImage}
            resizeMode="contain"
          />
        ) : (
          <View style={styles.plantPlaceholder}>
            <Ionicons name="leaf" size={40} color={COLORS.accentGreen} />
          </View>
        )}
        {/* Render an info icon if onInfoPress is provided */}
        {onInfoPress && (
          <TouchableOpacity style={styles.infoIconContainer} onPress={onInfoPress}>
            <Ionicons name="information-circle-outline" size={20} color={COLORS.textLight} />
          </TouchableOpacity>
        )}
        <View style={styles.thumbTextWrapper}>
          <Text style={styles.thumbPlantName}>{plant.speciesName}</Text>
        </View>
      </TouchableOpacity>
      {deletable && (
        <TouchableOpacity style={styles.deleteButton} onPress={OnDelete}>
          <Ionicons name="close-circle" size={24} color={COLORS.accentRed} />
        </TouchableOpacity>
      )}
    </View>
  );
};

export default PlantThumbnail;

const styles = StyleSheet.create({
  outerContainer: {
    margin: 5,
    alignSelf: 'flex-start',
  },
  selected: {
    backgroundColor: COLORS.accentGreen,
    borderRadius: 10,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOpacity: 0.1,
        shadowRadius: 5,
      },
      android: {
        elevation: 3,
      },
    }),
  },
  mainContainer: {
    width: (screenWidth - 70) / 3,
    backgroundColor: COLORS.cardBg1,
    borderRadius: 8,
    margin: 3,
    overflow: 'hidden',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOpacity: 0.1,
        shadowRadius: 5,
      },
      android: {
        elevation: 3,
      },
    }),
  },
  thumbImage: {
    width: '100%',
    aspectRatio: 3 / 4,
  },
  plantPlaceholder: {
    width: '100%',
    height: 120,
    backgroundColor: '#eee',
    justifyContent: 'center',
    alignItems: 'center',
  },
  thumbTextWrapper: {
    padding: 8,
    alignItems: 'center',
  },
  thumbPlantName: {
    fontSize: 14,
    fontWeight: '600',
    color: COLORS.textDark,
    textAlign: 'center',
  },
  deleteButton: {
    position: 'absolute',
    top: -8,
    right: -8,
    borderRadius: 50,
    backgroundColor: 'white',
  },
  infoIconContainer: {
    position: 'absolute',
    top: 5,
    right: 5,
    backgroundColor: 'rgba(0,0,0,0.5)',
    borderRadius: 12,
    padding: 2,
    zIndex: 2,
    alignItems: 'center',
    justifyContent: 'center',
  },
});


// File: app\features\main\components\ProfileCard.tsx
// src/components/ProfileCard.tsx

import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Image, ImageBackground } from 'react-native';
import { Ionicons, MaterialIcons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { useTranslation } from 'react-i18next';

import { COLORS } from '../../../theme/colors';
import { profileCardStyles } from '../styles/profileCardStyles';
import { UserResponse } from '../../../types/apiTypes'; // Adjust the path based on your project structure
import ProfileLocationDisplay from './ProfileLocationDisplay'; // Adjust the path based on your project structure

interface ProfileCardProps {
  userProfile: UserResponse;
  isEditable?: boolean;
  onEditPress?: () => void;
  screenWidth: number;
}

export const ProfileCard: React.FC<ProfileCardProps> = ({
  userProfile,
  isEditable = false,
  onEditPress,
  screenWidth,
}) => {
  const { t } = useTranslation();

  return (
    <View style={[profileCardStyles.profileCardContainer]}>
      <LinearGradient colors={[COLORS.cardBg1, COLORS.cardBg2]} style={profileCardStyles.profileCardInner}>
        <View style={profileCardStyles.profileTopContainer}>
          <ImageBackground
            source={require('../../../../assets/images/profileBackground.png')}
            style={profileCardStyles.profileBackgroundImage}
          />
          <View style={profileCardStyles.profilePictureContainer}>
            {userProfile.profilePictureUrl ? (
              <Image
                source={{ uri: userProfile.profilePictureUrl }}
                style={profileCardStyles.profilePicture}
              />
            ) : (
              <View style={profileCardStyles.profilePlaceholder}>
                <Ionicons name="person-circle-outline" size={90} color="#ccc" />
              </View>
            )}
          </View>

          {/* Conditionally render the Edit button */}
          {isEditable && onEditPress && (
            <TouchableOpacity
              onPress={onEditPress}
              style={profileCardStyles.profileEditButton}
              accessibilityLabel={t('profile_edit_button')}
            >
              <MaterialIcons name="edit" size={20} color={COLORS.textLight} />
            </TouchableOpacity>
          )}
        </View>

        {/* Name, location, bio */}
        <View style={profileCardStyles.profileInfoContainer}>
          <View style={profileCardStyles.nameContainer}>
            <Text style={profileCardStyles.profileNameText}>{userProfile.name}</Text>
          </View>
          <View style={[profileCardStyles.profileLocationRow, {maxWidth: screenWidth*0.9 - 215}]}>
            <Ionicons
              name="location-sharp"
              size={16}
              color={COLORS.accentLightRed}
              style={profileCardStyles.locationIcon}
            />
            {userProfile.locationLatitude && userProfile.locationLongitude && (
              <ProfileLocationDisplay
                latitude={userProfile.locationLatitude}
                longitude={userProfile.locationLongitude}
              />
            )}
          </View>
        </View>
        <View style={profileCardStyles.bioContainer}>
          <Text
            style={[
              profileCardStyles.bioText,
              !userProfile.bio && profileCardStyles.bioPlaceholder,
            ]}
          >
            {userProfile.bio ? userProfile.bio : t('profile_no_bio_placeholder')}
          </Text>
        </View>
      </LinearGradient>
    </View>
  );
};


// File: app\features\main\components\ProfileCardShelf.tsx
// File: src/features/main/components/ProfileCardShelf.tsx

import React, {
  useState,
  useRef,
  useCallback,
  memo,
  forwardRef,
  useImperativeHandle,
} from 'react';
import {
  Animated,
  Easing,
  View,
  TouchableOpacity,
  StyleSheet,
  LayoutChangeEvent,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

import { COLORS } from '../../../theme/colors';
import { log } from '../../../utils/logger';
import { UserResponse } from '../../../types/apiTypes';
import { ProfileCard } from './ProfileCard';

/**
 * Exposes imperative methods for opening, closing, toggling.
 */
export interface ProfileCardShelfRef {
  toggleShelf: () => void;
  openShelf: () => void;
  closeShelf: () => void;
}

interface ProfileCardShelfProps {
  /**
   * The user profile to display inside the shelf.
   */
  userProfile?: UserResponse;
}

const ProfileCardShelf = forwardRef<ProfileCardShelfRef, ProfileCardShelfProps>(
  function ProfileCardShelf({ userProfile }, ref) {
    // Start in open state
    const [isShelfOpen, setIsShelfOpen] = useState(true);
    // Store the maximum shelf height once measured
    const [maxShelfHeight, setMaxShelfHeight] = useState<number>(0);

    // This animated value transitions between minHeight and maxShelfHeight
    const shelfAnim = useRef(new Animated.Value(0)).current;

    /**
     * On layout, measure the full height so we can animate from that in the future.
     * If it's bigger than any previously recorded height, save it.
     * If the shelf is still open, set the animated value to that full height.
     */
    const handleShelfLayout = useCallback(
      (event: LayoutChangeEvent) => {
        const { height } = event.nativeEvent.layout;
        log.debug('Measured shelf layout height:', height);

        if (height > maxShelfHeight) {
          setMaxShelfHeight(height);

          // If we’re meant to be open, show the full shelf right now
          if (isShelfOpen) {
            shelfAnim.setValue(height);
          }
        }
      },
      [isShelfOpen, maxShelfHeight, shelfAnim]
    );

    /**
     * A simple function to animate the shelfAnim to a given height.
     */
    const animateTo = useCallback(
      (toValue: number) => {
        Animated.timing(shelfAnim, {
          toValue,
          duration: 300,
          easing: Easing.ease,
          useNativeDriver: false,
        }).start();
      },
      [shelfAnim]
    );

    /**
     * Toggle between fully open (maxShelfHeight) and collapsed (~15 px).
     */
    const toggleShelf = useCallback(() => {
      if (!maxShelfHeight) return; // Not measured yet, so skip

      // The small height for the toggle handle only
      const collapsedHeight = styles.shelfToggleButton.height;
      const targetValue = isShelfOpen ? collapsedHeight : maxShelfHeight;

      animateTo(targetValue);
      setIsShelfOpen(!isShelfOpen);
    }, [isShelfOpen, maxShelfHeight, animateTo]);

    /**
     * Explicitly close the shelf (collapse).
     */
    const closeShelf = useCallback(() => {
      if (!maxShelfHeight) return; // Not measured yet

      if (isShelfOpen) {
        const collapsedHeight = styles.shelfToggleButton.height;
        animateTo(collapsedHeight);
        setIsShelfOpen(false);
      }
    }, [isShelfOpen, maxShelfHeight, animateTo]);

    /**
     * Explicitly open the shelf (expand).
     */
    const openShelf = useCallback(() => {
      if (!maxShelfHeight) return; // Not measured yet

      if (!isShelfOpen) {
        animateTo(maxShelfHeight);
        setIsShelfOpen(true);
      }
    }, [isShelfOpen, maxShelfHeight, animateTo]);

    // Expose these methods for the parent (ChatScreen, etc.)
    useImperativeHandle(ref, () => ({
      toggleShelf,
      closeShelf,
      openShelf,
    }));

    /**
     * If we've already measured, we animate the container to shelfAnim.
     * If not measured yet, we let it wrap content naturally (so we can measure).
     */
    const containerStyle =
      maxShelfHeight > 0
        ? { height: shelfAnim }
        : undefined;

    return (
      <Animated.View style={[styles.animatedShelf, containerStyle]}>
        <View style={styles.shelfInnerContainer} onLayout={handleShelfLayout}>
          {userProfile && (
            <View style={styles.profileCardWrapper}>
              <ProfileCard
                userProfile={userProfile}
              />
            </View>
          )}
        </View>

        {/* The toggle "handle" pinned at the bottom */}
        <TouchableOpacity
          style={styles.shelfToggleButton}
          onPress={toggleShelf}
          activeOpacity={0.7}
        >
          <Ionicons
            name={isShelfOpen ? 'chevron-up-outline' : 'chevron-down-outline'}
            size={10}
            color="#fff"
          />
        </TouchableOpacity>
      </Animated.View>
    );
  }
);

export default memo(ProfileCardShelf);

const styles = StyleSheet.create({
  animatedShelf: {
    overflow: 'hidden',
    backgroundColor: '#f1f1f1',
  },
  shelfInnerContainer: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    paddingBottom: 23,
  },
  profileCardWrapper: {
    borderRadius: 8,
    alignSelf: 'center',
  },
  shelfToggleButton: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    height: 15,
    backgroundColor: COLORS.accentGreen,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
});


// File: app\features\main\components\ProfileLocationDisplay.tsx
// File: app/features/main/components/ProfileLocationDisplay.tsx
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import * as Location from 'expo-location';
import { profileCardStyles } from '../styles/profileCardStyles';

interface ProfileLocationDisplayProps {
  latitude: number;
  longitude: number;
}

const ProfileLocationDisplay: React.FC<ProfileLocationDisplayProps> = ({ latitude, longitude }) => {
  const [locationName, setLocationName] = useState<string>('');

  useEffect(() => {
    const fetchLocationName = async () => {
      try {
        const [result] = await Location.reverseGeocodeAsync({ latitude, longitude });
        const city = result.city || result.subregion || '';
        const country = result.country || '';
        setLocationName(city && country ? `${city}, ${country}` : city || country);
      } catch (error) {
        console.error("Reverse geocoding error:", error);
        setLocationName('');
      }
    };
    fetchLocationName();
  }, [latitude, longitude]);

  return (
      <Text style={profileCardStyles.profileLocationText}>{locationName || "Location not set"}</Text>
  );
};

export default ProfileLocationDisplay;


// File: app\features\main\components\SwipeableCard.tsx
import React, { forwardRef, useImperativeHandle } from 'react';
import {
  StyleSheet,
  View,
  Image,
  Text,
  Dimensions,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { PanGestureHandler, PanGestureHandlerGestureEvent } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedGestureHandler,
  useAnimatedStyle,
  runOnJS,
  withSpring,
} from 'react-native-reanimated';
import { LinearGradient } from 'expo-linear-gradient';
import { PlantResponse } from '../../../types/apiTypes';
import { COLORS } from '../../../theme/colors';
import { PlantOverlay } from './PlantOverlay';

const { width } = Dimensions.get('window');
const SWIPE_THRESHOLD = 0.25 * width;

/**
 * Methods the parent can call on this card
 * e.g. to finalize a right-swipe or reset it to center.
 */
export interface SwipeableCardRef {
  /** Animate the card flying off to the right, then call onSwipeRight. */
  flyOffRight: () => void;

  /** Reset the card back to center if user cancels. */
  resetPosition: () => void;
}

interface SwipeableCardProps {
  plant: PlantResponse;

  /** Called when the card is actually removed to the left. */
  onSwipeLeft: (plantId: number) => void;

  /** Called when the card has fully flown off the right side. */
  onSwipeRight: (plantId: number) => void;

  /**
   * Called as soon as the user crosses the swipe threshold on the right.
   * This is where you open the "SelectPlantsModal" without waiting.
   */
  onLikeGestureBegin: (plant: PlantResponse) => void;
}

/**
 * forwardRef so the parent can call flyOffRight or resetPosition
 */
export const SwipeableCard = forwardRef<SwipeableCardRef, SwipeableCardProps>(
  ({ plant, onSwipeLeft, onSwipeRight, onLikeGestureBegin }, ref) => {
    const translateX = useSharedValue(0);
    const rotateZ = useSharedValue(0);

    /**
     * Expose some methods to the parent, so it can:
     *  - finish the right-swipe
     *  - reset the card position
     */
    useImperativeHandle(ref, () => ({
      flyOffRight: () => {
        'worklet';
        // Animate card fully to the right, then call onSwipeRight
        translateX.value = withSpring(width * 1.5, {}, (finished) => {
          if (finished) {
            runOnJS(onSwipeRight)(plant.plantId);
          }
        });
      },
      resetPosition: () => {
        'worklet';
        translateX.value = withSpring(0);
        rotateZ.value = withSpring(0);
      },
    }));

    const gestureHandler = useAnimatedGestureHandler<
      PanGestureHandlerGestureEvent,
      { startX: number }
    >({
      onStart: (_, ctx) => {
        ctx.startX = translateX.value;
      },
      onActive: (event, ctx) => {
        translateX.value = ctx.startX + event.translationX;
        rotateZ.value = (event.translationX / width) * 0.15;
      },
      onEnd: (event) => {
        if (event.translationX > SWIPE_THRESHOLD) {
          // DO NOT fly off yet. Instead, partially move it aside
          // and immediately open the modal (parent triggers it).
          translateX.value = withSpring(150);
          runOnJS(onLikeGestureBegin)(plant);
        } else if (event.translationX < -SWIPE_THRESHOLD) {
          // Dislike: animate off to the left
          translateX.value = withSpring(-width * 1.5, {}, (finished) => {
            if (finished) {
              runOnJS(onSwipeLeft)(plant.plantId);
            }
          });
        } else {
          // Snap back to center
          translateX.value = withSpring(0);
          rotateZ.value = withSpring(0);
        }
      },
    });

    const animatedStyle = useAnimatedStyle(() => ({
      transform: [
        { translateX: translateX.value },
        { rotateZ: `${rotateZ.value}rad` },
      ],
    }));

    // Compute all tags from various properties
    const allTags = [
      plant.plantStage,
      plant.plantCategory,
      plant.wateringNeed,
      plant.lightRequirement,
      plant.size,
      plant.indoorOutdoor,
      plant.propagationEase,
      plant.petFriendly,
      ...(plant.extras ?? []),
    ].filter(Boolean);

    return (
      <PanGestureHandler onGestureEvent={gestureHandler}>
        <Animated.View style={[styles.cardContainer, animatedStyle]}>
          <View style={styles.fullImageContainer}>
            {plant.imageUrl ? (
              <Image
                source={{ uri: plant.imageUrl }}
                style={styles.fullImage}
                resizeMode="contain"
              />
            ) : (
              <View style={styles.plantPlaceholder}>
                <Ionicons name="leaf" size={60} color={COLORS.primary} />
              </View>
            )}
            <View style={styles.imageOverlay}>
              <LinearGradient
                colors={['rgba(0,0,0,0)', 'rgba(0,0,0,1)']}
                style={styles.overlayContent}
              />
            </View>
          </View>

          <View style={styles.plantInfoContainer}>
            <PlantOverlay
              speciesName={plant.speciesName}
              description={plant.description}
              tags={allTags}
            />
          </View>

          <View style={styles.underImageExtension} />
        </Animated.View>
      </PanGestureHandler>
    );
  }
);

const styles = StyleSheet.create({
  cardContainer: {
    position: 'absolute',
    maxWidth: width * 0.9,
    borderRadius: 8,
    overflow: 'hidden',
    marginVertical: 'auto',

    backgroundColor: COLORS.cardBg,
    shadowColor: '#000',
    shadowOpacity: 0.12,
    shadowRadius: 5,
    shadowOffset: { width: 0, height: 3 },
    elevation: 3,
  },
  fullImageContainer: {
    width: '100%',
    position: 'relative',
    aspectRatio: 3 / 4,
  },
  fullImage: {
    ...StyleSheet.absoluteFillObject,
  },
  plantPlaceholder: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#eee',
  },
  imageOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'flex-end',
  },
  overlayContent: {
    position: 'relative',
    bottom: 0,
    paddingTop: 200,
  },
  underImageExtension: {
    backgroundColor: 'black',
    zIndex: -1,
    height: 50,
  },
  plantInfoContainer: {
    padding: 5,
    position: 'absolute',
    bottom: 0,
  },
  fullPlantName: {
    fontSize: 18,
    fontWeight: '700',
    color: '#fff',
    marginBottom: 6,
  },
  tagRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 6,
  },
  tag: {
    backgroundColor: COLORS.primary,
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 4,
    marginRight: 6,
    marginBottom: 4,
  },
  tagText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
  fullDescription: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '400',
  },
});


// File: app\features\main\components\TagGroup.tsx
import React from 'react';
import {
  View,
  TouchableOpacity,
  Text,
  StyleSheet,
  StyleProp,
  ViewStyle,
  TextStyle,
} from 'react-native';
import { COLORS } from '../../../theme/colors';

/**
 * A single component that can handle both single-selection and multi-selection
 * by switching on the `mode` prop.
 */
export type TagGroupMode = 'single' | 'multiple';

interface TagGroupProps<T> {
  /** The list of all possible tag values. */
  values: T[];

  /** The selection mode of this component (single or multiple). */
  mode: TagGroupMode;

  /** Single-select: the selected tag. */
  selectedValue?: T | null;

  /** Multi-select: the selected tags. */
  selectedValues?: T[];

  /**
   * Single-select callback: 
   *   - If `isRequired` is true, tapping the selected tag again keeps it selected.
   *   - If `isRequired` is false, tapping the selected tag again deselects it (sets it to null).
   */
  onSelectSingle?: (val: T | null) => void;

  /** Multi-select callback: toggles an item in or out of the array of selected values. */
  onToggleMulti?: (val: T) => void;

  /** Whether a single-select is required (cannot unselect once set). Default is false. */
  isRequired?: boolean;

  /** Optional container style override for the tag group wrapper. */
  containerStyle?: StyleProp<ViewStyle>;

  /** Optional style override for individual tags. */
  tagStyle?: StyleProp<ViewStyle>;

  /** Optional style override for selected tags. */
  tagSelectedStyle?: StyleProp<ViewStyle>;

  /** Optional style override for text inside each tag. */
  tagTextStyle?: StyleProp<TextStyle>;

  /** Optional style override for text in a selected tag. */
  tagTextSelectedStyle?: StyleProp<TextStyle>;
}

function TagGroup<T extends string | number>(props: TagGroupProps<T>) {
  const {
    mode,
    values,
    selectedValue,
    selectedValues,
    onSelectSingle,
    onToggleMulti,
    isRequired = false,
    containerStyle,
    tagStyle,
    tagSelectedStyle,
    tagTextStyle,
    tagTextSelectedStyle,
  } = props;

  /**
   * Returns true if `val` is currently selected in either single- or multi-select mode.
   */
  const isSelected = (val: T) => {
    if (mode === 'single') {
      return val === selectedValue;
    }
    // Multi-select
    return selectedValues?.includes(val);
  };

  /**
   * Handle tag presses differently depending on the mode.
   * - Single-select: either select the new tag or possibly unselect if isRequired is false.
   * - Multi-select: toggle the given tag in the selectedValues array.
   */
  const handlePress = (val: T) => {
    if (mode === 'single') {
      if (!onSelectSingle) return;

      const alreadySelected = isSelected(val);
      if (isRequired) {
        // Must have exactly one selected always.
        onSelectSingle(val);
      } else {
        // Tapping the selected tag again should unselect it.
        onSelectSingle(alreadySelected ? null : val);
      }
    } else {
      // Multi-select
      if (!onToggleMulti) return;
      onToggleMulti(val);
    }
  };

  return (
    <View style={[styles.container, containerStyle]}>
      {values.map((val) => {
        const selected = isSelected(val);

        return (
          <TouchableOpacity
            key={String(val)}
            style={[
              styles.tag,
              tagStyle,
              selected && [styles.tagSelected, tagSelectedStyle],
            ]}
            onPress={() => handlePress(val)}
            accessible
            accessibilityRole="button"
            accessibilityLabel={`Select tag value: ${String(val)}`}
          >
            <Text
              style={[
                styles.tagText,
                tagTextStyle,
                selected && [styles.tagTextSelected, tagTextSelectedStyle],
              ]}
            >
              {val}
            </Text>
          </TouchableOpacity>
        );
      })}
    </View>
  );
}

export default TagGroup;

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 6,
  },
  tag: {
    borderWidth: 1,
    borderColor: COLORS.accentGreen, 
    borderRadius: 20,
    paddingVertical: 6,
    paddingHorizontal: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  tagSelected: {
    backgroundColor: COLORS.accentGreen,
  },
  tagText: {
    fontSize: 12,
    color: COLORS.accentGreen, 
    fontWeight: '600',
  },
  tagTextSelected: {
    color: COLORS.textLight,
    fontWeight: '600',
  },
});


// File: app\features\main\components\ToggleButton.tsx
// src/components/ToggleButton.tsx

import React from 'react';
import { View, TouchableOpacity, Text, StyleSheet } from 'react-native';
import { COLORS } from '../../../theme/colors';

interface ToggleButtonProps {
  options: [string, string];
  selected: string;
  onToggle: (option: string) => void;
}

export const ToggleButton: React.FC<ToggleButtonProps> = ({
  options,
  selected,
  onToggle,
}) => {
  return (
    <View style={styles.toggleContainer}>
      {options.map((option) => {
        const isActive = selected === option;
        return (
          <TouchableOpacity
            key={option}
            onPress={() => onToggle(option)}
            style={[
              styles.button,
              isActive && styles.activeButton,
            ]}
            accessibilityRole="button"
            accessibilityLabel={option}
          >
            <Text
              style={[
                styles.buttonText,
                isActive && styles.activeButtonText,
              ]}
            >
              {option}
            </Text>
          </TouchableOpacity>
        );
      })}
    </View>
  );
};

export default ToggleButton;

const styles = StyleSheet.create({
  toggleContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: COLORS.textLight,
    borderRadius: 20,
    alignSelf: 'center',
    padding: 3,
    marginBottom: 15,
  },
  button: {
    paddingHorizontal: 20,
    paddingVertical: 8,
    borderRadius: 18,
  },
  activeButton: {
    backgroundColor: COLORS.accentGreen,
  },
  buttonText: {
    fontSize: 14,
    fontWeight: '600',
    color: COLORS.textDark,
  },
  activeButtonText: {
    color: COLORS.textLight,
  },
});


// File: app\features\main\components\TradeProposalComponent.tsx


// File: app\features\main\hooks\useConnections.ts
// File: app/features/main/hooks/useConnections.ts

import { useQuery } from 'react-query';
import { connectionService } from '../../../api/connectionService';
import { ConnectionResponse } from '../../../types/apiTypes';

export function useConnections() {
  return useQuery<ConnectionResponse[], Error>('myConnections', () =>
    connectionService.getMyConnections()
  );
}

export function useConnection(connectionId: number) {
  return useQuery<ConnectionResponse, Error>(['connection', connectionId], () =>
    connectionService.getConnectionById(connectionId)
  );
}


// File: app\features\main\hooks\useMessages.ts
// File: src/features/main/hooks/useMatchConversation.ts

import { useQuery, useMutation, useQueryClient } from 'react-query';
import { messageService } from '../../../api/messageService';
import { MessageRequest, MessageResponse } from '../../../types/apiTypes';

export const useMessages = (connectionId: number) => {
  const queryClient = useQueryClient();

  // 1) Query: fetch messages for this match
  const messagesQuery = useQuery<MessageResponse[], Error>(
    ['messages', connectionId],
    () => messageService.getMessagesForConnection(connectionId),
    {
      enabled: connectionId > 0, // only fetch if matchId is valid
      staleTime: 1000 * 30, // example: 30s
    }
  );

  // 2) Mutation: send a message to this match
  const sendMessageMutation = useMutation(
    (data: MessageRequest) => messageService.sendMessage(connectionId, data),
    {
      onSuccess: () => {
        // re-fetch messages on success
        queryClient.invalidateQueries(['messages', connectionId]);
      },
    }
  );

  return {
    // Query states
    messages: messagesQuery.data,
    isLoadingMessages: messagesQuery.isLoading,
    isErrorMessages: messagesQuery.isError,
    refetchMessages: messagesQuery.refetch,

    // Mutation states
    sendMessage: sendMessageMutation.mutate,
    isSending: sendMessageMutation.isLoading,
  };
};


// File: app\features\main\hooks\useMyProfileHooks.ts
// hooks/useProfileHooks.ts
import { useQuery, useMutation, useQueryClient } from 'react-query';
import { userService } from '../../../api/userService';
import { UserResponse, UserUpdateRequest, UpdateLocationRequest, UserProfileImageUpdateRequest } from '../../../types/apiTypes';
import { useAppSelector } from '../../../store/hooks';

// Fetch User Profile
export const useMyProfile = () => {
  const { accessToken } = useAppSelector(state => state.auth);
  return useQuery<UserResponse, Error>(
    ['myProfile'],
    userService.getCurrentUserProfile,
    {
      staleTime: 1000 * 60 * 5, // 5 minutes
      cacheTime: 1000 * 60 * 10, // 10 minutes
      retry: 1, // Retry once on failure
    }
  );
};

// Update User Profile (Name, Bio, etc.)
export const useUpdateProfile = () => {
  const queryClient = useQueryClient();

  return useMutation(
    (payload: UserUpdateRequest) => userService.updateMe(payload),
    {
      onSuccess: () => {
        // Invalidate and refetch
        queryClient.invalidateQueries(['myProfile']);
      },
      onError: (error: any) => {
        console.error('Error updating profile:', error);
      },
    }
  );
};

// Update Profile Picture
export const useUpdateProfilePicture = () => {
  const queryClient = useQueryClient();

  return useMutation(
    (data: UserProfileImageUpdateRequest) => {

      return userService.updateProfilePicture(data);
    },
    {
      onSuccess: () => {
        // Invalidate and refetch
        queryClient.invalidateQueries(['myProfile']);
      },
      onError: (error: any) => {
        console.error('Error updating profile picture:', error);
      },
    }
  );
};

// **New Hook: Update User Location**
export const useUpdateLocation = () => {
  const queryClient = useQueryClient();

  return useMutation(
    (payload: UpdateLocationRequest) => userService.updateLocation(payload),
    {
      onSuccess: () => {
        // Invalidate and refetch
        queryClient.invalidateQueries(['myProfile']);
      },
      onError: (error: any) => {
        console.error('Error updating location:', error);
      },
    }
  );
};


// File: app\features\main\hooks\useOtherProfile.ts
import {useQuery} from 'react-query';
import { userService } from '../../../api/userService';
import { UserResponse, UserUpdateRequest } from '../../../types/apiTypes';
import { useSelector } from 'react-redux';
import { RootState } from '../../../store';

export const useOtherProfile = (userId: number) => {
        // Only run the query if we have a userId
    return useQuery<UserResponse, Error>(
      ['userProfile', userId],
      () => {
        if (!userId) {
          throw new Error('No userId available');
        }
        return userService.getUser(userId);
      },
      {
        enabled: !!userId,
        staleTime: 1000 * 60 * 5 // 5 minutes
      }
    );  
  };



// File: app\features\main\hooks\usePlantHooks.ts
// src/features/main/hooks/usePlantHooks.ts
import { useQuery } from "react-query";
import { plantService } from "../../../api/plantService";
import { PlantResponse } from "../../../types/apiTypes";
import { useSelector } from "react-redux";
import { RootState } from "../../../store";
import { useMutation, useQueryClient } from "react-query";

export const useOtherUserPlants = (userId: number) => {
  return useQuery(
    ["otherUserPlants", userId],
    () => plantService.getUserPlants(userId),
    {
      enabled: !!userId, // only fetch if userId is available
      staleTime: 1000 * 60 * 5, // 5 minutes
    }
  );
};

export const useMyPlants = () => {
  const queryClient = useQueryClient();
  const query = useQuery<PlantResponse[], Error>(
    ["myPlants"],
    () => {
      return plantService.getMyPlants();
    },
    {
      staleTime: 1000 * 60 * 5,
    }
  );

  const mutation = useMutation(
    (plantId: number) => plantService.deleteMyPlant(plantId),
    {
      onSettled: () => queryClient.invalidateQueries(["myPlants"]),
    }
  );

  return {
    ...query,
    deletePlant: mutation.mutate,
    isDeleting: mutation.isLoading,
  };
};

export const usePlantsLikedByMeFromUser = (otherUserId: number) => {
  return useQuery<PlantResponse[], Error>(
    ["plantsLikedByMeFromUser", otherUserId],
    () => plantService.getPlantsLikedByMeFromUser(otherUserId),
    {
      enabled: !!otherUserId,
    }
  );
};

export const usePlantsLikedByUserFromMe = (otherUserId: number) => {
  return useQuery<PlantResponse[], Error>(
    ["plantsLikedByUserFromMe", otherUserId],
    () => plantService.getPlantsLikedByUserFromMe(otherUserId),
    {
      enabled: !!otherUserId,
    }
  );
};

export const useMarkPlantsAsTraded = () => {
  const queryClient = useQueryClient();

  return useMutation(async (plantIds: number[]) => (plantService.markPlantsAsTraded(plantIds)), {
    onSettled: () => {
      queryClient.invalidateQueries(["myPlants"]);
      queryClient.invalidateQueries(["plantsLikedByMeFromUser"]);
      queryClient.invalidateQueries(["plantsLikedByUserFromMe"]);
    },
  });
};

// File: app\features\main\hooks\usePreferences.ts
// src/features/main/hooks/useUserPreferences.ts
import { useQuery, useMutation, useQueryClient } from 'react-query';
import { userPreferencesService } from '../../../api/userPreferencesService';
import { UserPreferencesResponse, UserPreferencesRequest } from '../../../types/apiTypes';
import { log } from '../../../utils/logger';
export const useUserPreferences = () => {
  const queryClient = useQueryClient();

  const query = useQuery<UserPreferencesResponse, Error>(
    ['myPreferences'],
    userPreferencesService.getPreferences,
    {
      staleTime: 1000 * 60 * 5
    }
  );

  const mutation = useMutation(
    (data: UserPreferencesRequest) => userPreferencesService.updatePreferences(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['myPreferences']);
        queryClient.invalidateQueries(['likablePlants']);
      }
    }
  );

  return {
    ...query,
    updatePreferences: mutation.mutate,
    isUpdating: mutation.isLoading
  };
};


// File: app\features\main\hooks\useSearchRadius.ts
// File: app/features/main/hooks/useSearchRadius.ts
import { useUserPreferences } from './usePreferences';

export const useSearchRadius = () => {
  const { data: preferences, isLoading, isError } = useUserPreferences();

  return {
    searchRadius: preferences?.searchRadius ?? 0, // default to 0 if undefined
    isLoading,
    isError,
  };
};


// File: app\features\main\hooks\useSwipe.ts
// useLikablePlants.ts
import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import { swipeService } from '../../../api/swipeService';
import { plantService } from '../../../api/plantService';
import {
  PlantResponse,
  SwipeRequest,
  SwipeResponse,
} from '../../../types/apiTypes';

export const useLikablePlants = () => {
  const queryClient = useQueryClient();
  const [matches, setMatches] = useState<SwipeResponse[]>([]);

  const query = useQuery<PlantResponse[], Error>(
    ['likablePlants'],
    plantService.getLikablePlants,
    {
      staleTime: 1000 * 60, // 1 minute
      refetchOnWindowFocus: true,
      retry: 1,
    }
  );

  const mutation = useMutation(
    (data: SwipeRequest[]) => swipeService.sendSwipes(data),
    {
      onSuccess: (swipeResponses: SwipeResponse[]) => {
        // Filter and store only the responses that indicate a match.
        const newMatches = swipeResponses.filter((resp) => resp.isMatch);
        if (newMatches.length > 0) {
          setMatches((prev) => [...prev, ...newMatches]);
          queryClient.invalidateQueries(['myConnections']);
        }
      },
    }
  );

  const clearMatches = () => setMatches([]);

  return {
    ...query,
    sendSwipes: mutation.mutate,
    isSending: mutation.isLoading,
    matches,
    clearMatches,
  };
};


// File: app\features\main\hooks\useTradeProposalHooks.ts
import { useMutation, useQueryClient } from 'react-query';
import { connectionService } from '../../../api/connectionService';
import { TradeProposalRequest, TradeProposalResponse } from '../../../types/apiTypes';
import { useQuery } from 'react-query';
import { TradeProposalStatus } from '../../../types/enums';

export const useCreateTradeProposal = (connectionId: number) => {
  const queryClient = useQueryClient();

  return useMutation<TradeProposalResponse, Error, TradeProposalRequest>(
    (payload: TradeProposalRequest) => connectionService.createTradeProposal(connectionId, payload),
    {
      onSuccess: () => {
        // Invalidate or refetch relevant queries if needed
        queryClient.invalidateQueries(['tradeProposals', connectionId]);
        // Or queryClient.invalidateQueries(['connections']); etc.
      },
    }
  );
};

export const useTradeProposals = (connectionId: number) => {
  return useQuery<TradeProposalResponse[], Error>(
    ["tradeProposals", connectionId],
    () => connectionService.getTradeProposals(connectionId),
    { staleTime: 1000 * 60 } // 1 minute stale time
  );
};

// Hook to update the status of a trade proposal.
export const useUpdateTradeProposalStatus = (connectionId: number) => {
  const queryClient = useQueryClient();
  return useMutation(
    ({
      proposalId,
      newStatus,
    }: {
      proposalId: number;
      newStatus: TradeProposalStatus;
    }) => connectionService.updateTradeProposalStatus(connectionId, proposalId, { newStatus }),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(["tradeProposals", connectionId]);
      },
    }
  );
};

export const useConfirmTradeProposalCompletion = (connectionId: number) => {
  const queryClient = useQueryClient();
  return useMutation(
    (proposalId: number) => connectionService.confirmTradeProposalCompletion(connectionId, proposalId),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(["tradeProposals", connectionId]);
      },
    }
  );
}

// File: app\features\main\hooks\useUserMatches.ts
// File: app/features/main/hooks/useUserMatches.ts
import { useQuery } from 'react-query';
import { matchService } from '../../../api/matchService'; // Or wherever your service lives
import { MatchResponse } from '../../../types/apiTypes';
import { connect } from 'react-redux';

export const useUserMatches = (connectionId: number) => {
  return useQuery<MatchResponse[]>(
    ['connectionMatches', connectionId],
    () => matchService.getMyMatchesForConnectionId(connectionId),
    {
      // You can configure staleTime, refetchOnWindowFocus, etc. here
      staleTime: 1000 * 60, // 1 minute
      //refetch on changing connectionId
      refetchOnWindowFocus: true,
    }
  );
};


// File: app\features\main\modals\ChangeLocationModal.tsx
// File: app/features/onboarding/screens/ChangeLocationModal.tsx

import React, { useState, useEffect } from 'react';
import {
  Modal,
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  Dimensions,
} from 'react-native';
import MapView, { Marker, MapPressEvent, Region } from 'react-native-maps';
import * as Location from 'expo-location'; // If using Expo
import { useTranslation } from 'react-i18next';
import { log } from '../../../utils/logger';
import ConfirmCancelButtons from '../components/ConfirmCancelButtons';
import { userService } from '../../../api/userService';
import { UpdateLocationRequest } from '../../../types/apiTypes';
import { COLORS } from '../../../theme/colors';

interface ChangeLocationModalProps {
  visible: boolean;
  initialLatitude?: number;
  initialLongitude?: number;
  onClose: () => void;
  onUpdated: () => void;
}

export const ChangeLocationModal: React.FC<ChangeLocationModalProps> = ({
  visible,
  initialLatitude,
  initialLongitude,
  onClose,
  onUpdated,
}) => {
  const { t } = useTranslation();
  const [markerPosition, setMarkerPosition] = useState<{ lat: number; lng: number } | null>(null);
  const [region, setRegion] = useState<Region | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [permissionStatus, setPermissionStatus] =
    useState<Location.PermissionStatus | null>(null);

  // Check if valid numeric coords (including zero).
  const hasInitialCoords =
    typeof initialLatitude === 'number' &&
    !Number.isNaN(initialLatitude) &&
    typeof initialLongitude === 'number' &&
    !Number.isNaN(initialLongitude);

  // When the modal opens, handle location permission + region setup
  useEffect(() => {
    if (!visible) return;

    (async () => {
      const { status } = await Location.requestForegroundPermissionsAsync();
      setPermissionStatus(status);

      // If granted and no initial coords, try fetching current location
      if (status === Location.PermissionStatus.GRANTED && !hasInitialCoords) {
        try {
          const loc = await Location.getCurrentPositionAsync({});
          setRegion({
            latitude: loc.coords.latitude,
            longitude: loc.coords.longitude,
            latitudeDelta: 0.05,
            longitudeDelta: 0.05,
          });
          setMarkerPosition({ lat: loc.coords.latitude, lng: loc.coords.longitude });
        } catch (error) {
          // fallback to a default region if location fails
          setRegion({
            latitude: 37.78825,
            longitude: -122.4324,
            latitudeDelta: 0.05,
            longitudeDelta: 0.05,
          });
        }
      } else if (hasInitialCoords) {
        setRegion({
          latitude: initialLatitude!,
          longitude: initialLongitude!,
          latitudeDelta: 0.05,
          longitudeDelta: 0.05,
        });
        setMarkerPosition({ lat: initialLatitude!, lng: initialLongitude! });
      } else {
        // If no coords and permission denied, default
        setRegion({
          latitude: 37.78825,
          longitude: -122.4324,
          latitudeDelta: 0.05,
          longitudeDelta: 0.05,
        });
      }

      setError(null);
    })();
  }, [visible]);

  // If not visible, do not render
  if (!visible) {
    return null;
  }

  // Handle map tap
  const handleMapPress = (e: MapPressEvent) => {
    const { latitude, longitude } = e.nativeEvent.coordinate;
    setMarkerPosition({ lat: latitude, lng: longitude });
  };

  // Update region after user panning/zooming
  const handleRegionChangeComplete = (newRegion: Region) => {
    setRegion(newRegion);
  };

  // Confirm location => call API
  const handleConfirm = async () => {
    if (!markerPosition) {
      onClose();
      return;
    }
    setLoading(true);
    setError(null);

    const payload: UpdateLocationRequest = {
      latitude: markerPosition.lat,
      longitude: markerPosition.lng,
    };

    try {
      await userService.updateLocation(payload);
      onUpdated();
      onClose();
    } catch {
      setError(t('change_location_error_message'));
    } finally {
      setLoading(false);
    }
  };

  // Cancel
  const handleCancel = () => {
    onClose();
  };

  return (
    <Modal visible={visible} animationType="slide" transparent>
      <View style={styles.overlay}>
        <View style={styles.modalContainer}>
          <Text style={styles.title}>{t('change_location_title')}</Text>
          <Text style={styles.subtitle}>
            {permissionStatus === Location.PermissionStatus.DENIED
              ? t('Permission denied. Tap on the map to place a marker.')
              : t('Tap on the map to place or move the marker.')}
          </Text>

          {error && <Text style={styles.errorText}>{error}</Text>}

          <View style={styles.mapContainer}>
            {region && (
              <MapView
                style={{ flex: 1 }}
                region={region}
                onRegionChangeComplete={handleRegionChangeComplete}
                onPress={handleMapPress}
              >
                {markerPosition && (
                  <Marker
                    coordinate={{
                      latitude: markerPosition.lat,
                      longitude: markerPosition.lng,
                    }}
                  />
                )}
              </MapView>
            )}
          </View>

          {loading && (
            <ActivityIndicator size="small" color={COLORS.accentGreen} style={{ marginVertical: 10 }} />
          )}

          <ConfirmCancelButtons
            onCancel={handleCancel}
            onConfirm={handleConfirm}
            confirmButtonText={t('Confirm')}
            cancelButtonText={t('Cancel')}
          />
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '90%',
    height: '80%',
    backgroundColor: '#fff',
    borderRadius: 16,
    padding: 20,
    // iOS shadow
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    // Android elevation
    elevation: 5,
  },
  title: {
    fontSize: 18,
    fontWeight: '700',
    color: '#333',
    marginBottom: 6,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#555',
    marginBottom: 10,
    textAlign: 'center',
  },
  errorText: {
    color: '#FF6B6B',
    marginBottom: 10,
    textAlign: 'center',
  },
  mapContainer: {
    flex: 1,
    borderRadius: 8,
    overflow: 'hidden',
    marginBottom: 10,
    backgroundColor: '#eee',
  },
});


// File: app\features\main\modals\EditProfileModal.tsx
// components/profile/EditProfileModal.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
  Modal,
  View,
  Text,
  Image,
  TextInput,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  Dimensions,
  ImageBackground,
} from 'react-native';
import { useTranslation } from 'react-i18next';
import { Ionicons, MaterialIcons } from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
import * as ImageManipulator from 'expo-image-manipulator';
import * as Location from 'expo-location';
import { LinearGradient } from 'expo-linear-gradient';

import {ChangeLocationModal} from './ChangeLocationModal';
import { COLORS } from '../../../theme/colors';
import { profileCardStyles } from '../styles/profileCardStyles';
import { log } from '../../../utils/logger';
import {
  useMyProfile,
  useUpdateProfile,
  useUpdateProfilePicture,
} from '../hooks/useMyProfileHooks'; // Adjust the path as necessary
import { UserResponse, UserUpdateRequest } from '../../../types/apiTypes';

interface EditProfileModalProps {
  visible: boolean;
  userProfile: UserResponse;
  onClose: () => void;
  onUpdated: () => void; // callback after successful update (refetch in parent)
  cardLayout: { x: number; y: number; width: number; height: number };
}

export const  EditProfileModal: React.FC<EditProfileModalProps> = ({
  visible,
  userProfile,
  onClose,
  onUpdated,
  cardLayout,
}) => {
  const { t } = useTranslation();
  const screenWidth = Dimensions.get('window').width;

  // Local states for name, bio, and location display
  const [name, setName] = useState(userProfile.name);
  const [bio, setBio] = useState(userProfile.bio || '');
  const [cityCountry, setCityCountry] = useState<string>('');
  const [error, setError] = useState<string | null>(null);

  // For nested ChangeLocationModal
  const [locationModalVisible, setLocationModalVisible] = useState(false);

  // Reverse-geocode city/country for display
  const userHasLocation =
    userProfile.locationLatitude !== undefined &&
    userProfile.locationLongitude !== undefined;

  useEffect(() => {
    (async () => {
      if (userHasLocation) {
        try {
          const [geo] = await Location.reverseGeocodeAsync({
            latitude: userProfile.locationLatitude!,
            longitude: userProfile.locationLongitude!,
          });
          if (geo) {
            const city = geo.city || geo.subregion || '';
            const country = geo.country || '';
            setCityCountry(
              city && country ? `${city}, ${country}` : city || country
            );
          }
        } catch (err) {
          console.log('Reverse geocoding error:', err);
          setCityCountry('');
        }
      } else {
        setCityCountry('');
      }
    })();
  }, [userHasLocation, userProfile]);

  // ----------- Hooks for Mutations -----------
  const {
    mutate: updateProfile,
    isLoading: isUpdatingProfile,
    isError: isUpdateProfileError,
    error: updateProfileError,
  } = useUpdateProfile();

  const {
    mutate: updateProfilePicture,
    isLoading: isUpdatingPicture,
    isError: isUpdatePictureError,
    error: updatePictureError,
  } = useUpdateProfilePicture();

  const isUpdating = isUpdatingProfile || isUpdatingPicture;

  // ----------- Handle Profile Picture Updates -----------
  const handleChangeProfilePicture = useCallback(() => {
    Alert.alert(
      t('profile_change_picture_title'),
      t('profile_change_picture_msg'),
      [
        {
          text: t('profile_picture_select_library'),
          onPress: pickImageFromLibrary,
        },
        {
          text: t('profile_picture_take_photo'),
          onPress: takePictureWithCamera,
        },
        { text: t('profile_picture_cancel'), style: 'cancel' },
      ]
    );
  }, [t]);

  const pickImageFromLibrary = async () => {
    try {
      const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (!permissionResult.granted) {
        Alert.alert(t('error_title'), t('error_media_library_permission_denied'));
        return;
      }

      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [1, 1],
        quality: 0.7,
      });
      if (!result.canceled && result.assets[0].uri) {
        const resized = await resizeImage(result.assets[0].uri);
        handleUploadProfilePicture(resized.uri);
      }
    } catch (err) {
      console.error('pickImageFromLibrary error:', err);
      Alert.alert(t('error_title'), t('error_could_not_open_image_library'));
    }
  };

  const takePictureWithCamera = async () => {
    try {
      const cameraPermission = await ImagePicker.requestCameraPermissionsAsync();
      if (!cameraPermission.granted) {
        Alert.alert(t('error_title'), t('error_camera_permission_denied'));
        return;
      }
      const result = await ImagePicker.launchCameraAsync({
        allowsEditing: true,
        aspect: [1, 1],
        quality: 0.7,
      });
      if (!result.canceled && result.assets[0].uri) {
        const resized = await resizeImage(result.assets[0].uri);
        handleUploadProfilePicture(resized.uri);
      }
    } catch (err) {
      console.error('takePictureWithCamera error:', err);
      Alert.alert(t('error_title'), t('error_could_not_open_camera'));
    }
  };

  const resizeImage = async (uri: string) => {
    return await ImageManipulator.manipulateAsync(
      uri,
      [{ resize: { width: 800 } }],
      { compress: 0.7, format: ImageManipulator.SaveFormat.JPEG }
    );
  };

  const handleUploadProfilePicture = async (uri: string) => {
    try {
      const img = await resizeImage(uri);
      const photo = {
        uri: img.uri,
        name: 'profile.jpg',
        type: 'image/jpeg',
      } as any;
      updateProfilePicture({image: photo});
    } catch (err) {
      console.error('Error preparing profile picture:', err);
      Alert.alert(t('error_title'), t('error_profile_picture_update_failed'));
    }
  };

  // ----------- Handle “Save” -----------
  const handleSave = async () => {
    setError(null);

    const payload: UserUpdateRequest = {
      name: name.trim(),
      bio: bio.trim(),
    };

    if (!payload.name) {
      setError(t('edit_profile_error_name_required'));
      return;
    }

    updateProfile(payload, {
      onError: (error: any) => {
        setError(error?.message || t('edit_profile_error_message'));
      },
      onSuccess: () => {
        onUpdated();
        onClose();
      },
    });
  };

  // ----------- Handle Location Modal -----------
  const handleOpenSetLocationModal = () => {
    log.debug('Opening location modal');
    log.debug('userProfile.locationLatitude', userProfile.locationLatitude);
    log.debug('userProfile.locationLongitude', userProfile.locationLongitude);
    setLocationModalVisible(true);
  };

  // ----------- Effect to Handle Mutation Errors -----------
  useEffect(() => {
    if (isUpdateProfileError && updateProfileError) {
      Alert.alert(t('error_title'), updateProfileError.message || t('error_update_profile_failed'));
    }
    if (isUpdatePictureError && updatePictureError) {
      Alert.alert(t('error_title'), updatePictureError.message || t('error_update_profile_picture_failed'));
    }
  }, [isUpdateProfileError, updateProfileError, isUpdatePictureError, updatePictureError, t]);

  return (
    <Modal visible={visible} animationType="fade" transparent>
      <View style={styles.modalOverlay}>
        {/* Card positioned absolutely where the user’s profile card was */}
        <View
          style={[
            profileCardStyles.profileCardContainer,
            {
              position: 'absolute',
              top: cardLayout.y,
              left: cardLayout.x,
              width: cardLayout.width,
            },
          ]}
        >
          <LinearGradient
            colors={[COLORS.cardBg1, COLORS.cardBg2]}
            style={profileCardStyles.profileCardInner}
          >
            {/* Top portion + background image + picture */}
            <View style={profileCardStyles.profileTopContainer}>
              <ImageBackground
                source={require('../../../../assets/images/profileBackground.png')}
                style={profileCardStyles.profileBackgroundImage}
              />
              <View style={profileCardStyles.profilePictureContainer}>
                {userProfile.profilePictureUrl ? (
                  <Image
                    source={{ uri: userProfile.profilePictureUrl }}
                    style={profileCardStyles.profilePicture}
                  />
                ) : (
                  <View style={profileCardStyles.profilePlaceholder}>
                    <Ionicons name="person-circle-outline" size={90} color="#ccc" />
                  </View>
                )}

                {/* Camera icon to change picture */}
                <TouchableOpacity
                  style={profileCardStyles.cameraIconWrapper}
                  onPress={handleChangeProfilePicture}
                  disabled={isUpdating}
                >
                  <Ionicons name="camera" size={18} color="#fff" />
                </TouchableOpacity>
              </View>

              {/* “Save” checkmark in the top-right corner */}
              <TouchableOpacity
                onPress={handleSave}
                style={profileCardStyles.profileEditButton}
                disabled={isUpdating}
              >
                {isUpdating ? (
                  <ActivityIndicator size="small" color={COLORS.textLight} />
                ) : (
                  <MaterialIcons name="check" size={20} color={COLORS.textLight} />
                )}
              </TouchableOpacity>
            </View>

            {/* Middle portion: name / location */}
            <View style={profileCardStyles.profileInfoContainer}>
              <View
                style={[
                  profileCardStyles.nameContainer,
                  profileCardStyles.editNameContainer,
                  { maxWidth: screenWidth * 0.9 - 215 },
                ]}
              >
                <TextInput
                  style={[
                    profileCardStyles.profileNameText,
                    profileCardStyles.editableTextName,
                  ]}
                  value={name}
                  maxLength={16}
                  onChangeText={setName}
                  placeholder={t('edit_profile_name_label')}
                  placeholderTextColor="#999"
                />
              </View>
              <View style={[profileCardStyles.profileLocationRow, { maxWidth: screenWidth * 0.9 - 215 }]}>
                {/* Tapping location opens the location modal */}
                <Ionicons
                  name="location-sharp"
                  size={16}
                  color={COLORS.accentLightRed}
                  style={profileCardStyles.locationIcon}
                />
                <TouchableOpacity onPress={handleOpenSetLocationModal} style={{ flex: 1 }}>
                  <Text
                    style={[
                      profileCardStyles.profileLocationText,
                      { textDecorationLine: 'underline', color: COLORS.accentRed },
                    ]}
                  >
                    {cityCountry || t('profile_no_location')}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>

            {/* Bio: multiline text input */}
            <View
              style={[
                profileCardStyles.bioContainer,
                profileCardStyles.bioContainerEdit,
              ]}
            >
              <TextInput
                style={[
                  profileCardStyles.bioText,
                  profileCardStyles.editableTextBio,
                  !bio && profileCardStyles.bioPlaceholder,
                ]}
                multiline
                maxLength={1000}
                value={bio}
                onChangeText={setBio}
                placeholder={t('profile_no_bio_placeholder')}
                placeholderTextColor="#999"
              />
            </View>

            {/* Error Message */}
            {error && <Text style={profileCardStyles.errorText}>{error}</Text>}
          </LinearGradient>
        </View>
      </View>

      {/* Loading Indicator Overlay */}
      {isUpdating && (
        <View style={styles.loadingOverlay}>
          <ActivityIndicator size="large" color={COLORS.accentRed} />
        </View>
      )}

      {/* Location modal */}
      <ChangeLocationModal
        visible={locationModalVisible}
        initialLatitude={userProfile.locationLatitude}
        initialLongitude={userProfile.locationLongitude}
        onClose={() => setLocationModalVisible(false)}
        onUpdated={() => {
          setLocationModalVisible(false);
          onUpdated();
        }}
      />
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.45)',
  },
  loadingOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  
});


// File: app\features\main\modals\InfoModal.tsx
// File: app/features/main/components/InfoModal.tsx
import React from 'react';
import { Modal, View, TouchableOpacity, StyleSheet, Dimensions } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { COLORS } from '../../../theme/colors'; // adjust the import path as needed
import { LinearGradient } from 'expo-linear-gradient';

const { width } = Dimensions.get('window');

export interface InfoModalProps {
  visible: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

const InfoModal: React.FC<InfoModalProps> = ({ visible, onClose, children }) => {
  return (
    <Modal visible={visible} transparent animationType="fade">
      <View style={styles.infoOverlayContainer}>
        <LinearGradient style={styles.infoModalContainer} colors={[COLORS.primary, COLORS.secondary]}>
          <TouchableOpacity style={styles.closeButton} onPress={onClose}>
            <Ionicons name="close" size={24} color="#fff" />
          </TouchableOpacity>
          {children}
        </LinearGradient>
      </View>
    </Modal>
  );
};

export default InfoModal;

const styles = StyleSheet.create({
  infoOverlayContainer: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.6)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  infoModalContainer: {
    width: width * 0.9,
    borderRadius: 12,
    overflow: 'hidden',
    padding: 10,
    position: 'relative',
  },
  closeButton: {
    position: 'absolute',
    top: 15,
    right: 15,
    backgroundColor: 'rgba(0,0,0,0.5)',
    borderRadius: 20,
    padding: 4,
    zIndex: 10,
  },
});


// File: app\features\main\modals\ItsAMatchModal.tsx
import React from 'react';
import {
  Modal,
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  Image,
  ScrollView,
} from 'react-native';
import {
  SwipeResponse,
  ConnectionResponse,
  MatchResponse
} from '../../../types/apiTypes';
import MatchCard from '../components/MatchCard';
import { COLORS } from '../../../theme/colors';
import { t } from 'i18next';

interface ItsAMatchModalProps {
  visible: boolean;
  matches: SwipeResponse[];
  currentUserId: number;
  onClose: () => void;
}

const ItsAMatchModal: React.FC<ItsAMatchModalProps> = ({
  visible,
  matches,
  currentUserId,
  onClose,
}) => {
  // If there are no matches, we can render nothing or an empty state
  if (!matches.length) {
    return null;
  }

  // Since we assume all matches belong to a single connection,
  // we can derive the connection from the first match
  const { connection } = matches[0];

  // Determine the "other user" in this connection
  const otherUser =
    connection.user1.userId === currentUserId
      ? connection.user2
      : connection.user1;

  // Extract just the `match` objects
  const matchData = matches.map((swipeResp) => swipeResp.match);

  return (
    <Modal visible={visible} transparent animationType="slide">
      <View style={styles.overlay}>
        <View style={styles.modalContainer}>
          <Text style={styles.title}>{t('new_matches')}</Text>

            {/* Show the other user's info once at the top */}
            <View style={styles.connectionHeader}>
              <Image
                source={{ uri: otherUser.profilePictureUrl }}
                style={styles.connectionImage}
              />
              <Text style={styles.connectionName}>{otherUser.name}</Text>
            </View>

            {/* Render the list of Match objects */}
            <FlatList
              data={matchData}
              keyExtractor={(item) => item.matchId.toString()}
              showsVerticalScrollIndicator={false}
              renderItem={({ item }) => (
                <MatchCard match={item} currentUserId={currentUserId} />
              )}
              contentContainerStyle={styles.matchesList}
            />

          {/* Close button */}
          <TouchableOpacity style={styles.closeButton} onPress={onClose}>
            <Text style={styles.closeButtonText}>Close</Text>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
};

export default ItsAMatchModal;

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.6)',
    justifyContent: 'center',
    padding: 20,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: '#fff',
    borderRadius: 16,
    padding: 20,
    marginVertical: 40,
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
    color: COLORS.accentGreen,
    marginBottom: 16,
    textAlign: 'center',
  },
  contentContainer: {
    paddingBottom: 20,
  },
  connectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
    alignSelf: 'center',
  },
  connectionImage: {
    width: 50,
    height: 50,
    borderRadius: 25,
    marginRight: 12,
  },
  connectionName: {
    fontSize: 18,
    fontWeight: '600',
    color: COLORS.textDark,
  },
  matchesList: {
    padding: 10,
  },
  closeButton: {
    backgroundColor: COLORS.accentGreen,
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 10,
  },
  closeButtonText: {
    color: COLORS.textLight,
    fontSize: 16,
    fontWeight: '600',
  },
});


// File: app\features\main\modals\SelectPlantsModal.tsx
import React, { useState, useEffect } from 'react';
import {
  Modal,
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Image,
  ActivityIndicator,
  Platform,
  Dimensions,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useMyPlants } from '../hooks/usePlantHooks'; // Adjust import path if necessary
import { PlantResponse } from '../../../types/apiTypes';
import { t } from 'i18next';
import { COLORS } from '../../../theme/colors';
import ConfirmCancelButtons from '../components/ConfirmCancelButtons';
import { PlantThumbnail } from '../components/PlantThumbnail';

interface SelectPlantsModalProps {
  visible: boolean;
  /**
   * Called when the user confirms their selection.
   * Passes an array of plant IDs that the user selected.
   */
  onConfirm: (selectedPlantIds: number[]) => void;
  /**
   * Called when the user cancels/closes the modal (no selection returned).
   */
  onClose: () => void;
}

const { width } = Dimensions.get('window');

export const SelectPlantsModal: React.FC<SelectPlantsModalProps> = ({
  visible,
  onConfirm,
  onClose,
}) => {
  // Fetch the user’s plants
  const {
    data: myPlants,
    isLoading,
    isError,
    refetch,
  } = useMyPlants();

  // Track which plants have been selected
  const [selectedPlantIds, setSelectedPlantIds] = useState<number[]>([]);

  // Reset selection each time the modal opens
  useEffect(() => {
    if (visible) {
      setSelectedPlantIds([]);
      // Optionally refresh user plants each time the modal opens
      refetch();
    }
  }, [visible, refetch]);

  const handleToggleSelect = (plantId: number) => {
    setSelectedPlantIds((prev) => {
      if (prev.includes(plantId)) {
        // Already selected => deselect
        return prev.filter((id) => id !== plantId);
      } else {
        // Not selected => select
        return [...prev, plantId];
      }
    });
  };

  const handleConfirm = () => {
    onConfirm(selectedPlantIds);
  };

  if (!visible) {
    return null;
  }

  return (
    <Modal visible={visible} transparent animationType="slide">
      <View style={styles.modalContainer}>
        <View style={styles.modalContent}>
          

          {isLoading && (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={COLORS.primary} />
              <Text style={styles.loadingText}>Loading your plants...</Text>
            </View>
          )}

          {isError && (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>
                Could not load your plants. Please try again.
              </Text>
              <TouchableOpacity style={styles.retryButton} onPress={refetch}>
                <Text style={styles.retryButtonText}>Retry</Text>
              </TouchableOpacity>
            </View>
          )}

          {!isLoading && !isError && myPlants && (
            <>
              {myPlants.length === 0 ? (
                <View style={styles.emptyStateContainer}>
                  <Text style={styles.emptyStateText}>
                    You have no plants in your collection yet.
                  </Text>
                </View>
              ) : (
                <ScrollView style={styles.scrollArea}>
                  <Text style={styles.modalTitle}>Select Plants</Text>
                  <Text style={styles.titleText}>
                    Select the plants you want to trade for. Tap on a plant to select it.
                  </Text>
                  <View style={styles.gridContainer}>
                    {myPlants.map((plant: PlantResponse) => {
                      const isSelected = selectedPlantIds.includes(plant.plantId);
                      return (
                        <PlantThumbnail
                          key={plant.plantId}
                          plant={plant}
                          isSelected={isSelected}
                          selectable={true}
                          onPress={() => handleToggleSelect(plant.plantId)}
                        />
                      );
                    })}
                  </View>
                  <View style={styles.actionbuttons}>
                  <ConfirmCancelButtons
                    onConfirm={handleConfirm}
                    onCancel={onClose}
                    confirmButtonText="Confirm"
                    cancelButtonText="Cancel"
                  />
                  </View>
                </ScrollView>
              )}
            </>
          )}

          

        </View>
      </View>
    </Modal>
  );
};

// Replicating (and adapting) styles from your MyProfileScreen thumbnails:
const styles = StyleSheet.create({
  modalContainer: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: COLORS.textLight,
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    maxHeight: '85%',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOpacity: 0.15,
        shadowRadius: 10,
        shadowOffset: { width: 0, height: -4 },
      },
      android: {
        elevation: 10,
      },
    }),
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: COLORS.textDark,
    textAlign: 'center',
    marginTop: 15,
  },
  titleText: {
    fontSize: 14,
    color: COLORS.textDark,
    margin: 10,
    textAlign: 'center',
  },
  loadingContainer: {
    alignItems: 'center',
    marginVertical: 20,
  },
  loadingText: {
    marginTop: 10,
    fontSize: 14,
    color: COLORS.textDark,
  },
  errorContainer: {
    alignItems: 'center',
    marginVertical: 20,
  },
  errorText: {
    fontSize: 14,
    color: COLORS.textDark,
    marginBottom: 10,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: COLORS.primary,
    borderRadius: 6,
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  emptyStateContainer: {
    alignItems: 'center',
    marginVertical: 20,
  },
  emptyStateText: {
    fontSize: 14,
    color: COLORS.textDark,
    textAlign: 'center',
  },
  scrollArea: {
  },
  gridContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
  },
  actionbuttons: {
    marginHorizontal: 17,
    marginBottom: 17,
    marginTop: 5,
  },
});


// File: app\features\main\screens\AddPlantScreen.tsx
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Image,
  Alert,
  TextInput,
  Platform,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons, MaterialIcons } from '@expo/vector-icons';
import { useTranslation } from 'react-i18next';
import { useNavigation } from '@react-navigation/native';
import { useQueryClient } from 'react-query';
import * as ImagePicker from 'expo-image-picker';
import * as ImageManipulator from 'expo-image-manipulator';

import TagGroup from '../components/TagGroup';
import ConfirmCancelButtons from '../components/ConfirmCancelButtons';
import { COLORS } from '../../../theme/colors';
import { headerStyles } from '../styles/headerStyles';

import {
  PlantCategory,
  PlantStage,
  WateringNeed,
  LightRequirement,
  Size,
  IndoorOutdoor,
  PropagationEase,
  PetFriendly,
  Extras,
} from '../../../types/enums';
import {
  PlantCreateRequest,
  PlantRequest,
} from '../../../types/apiTypes';
import { plantService } from '../../../api/plantService';

const AddPlantScreen: React.FC = () => {
  const { t } = useTranslation();
  const navigation = useNavigation();
  const queryClient = useQueryClient();

  const [speciesName, setSpeciesName] = useState('');
  const [stage, setStage] = useState<PlantStage | null>(null);
  const [image, setImage] = useState<any>(null);

  const [category, setCategory] = useState<PlantCategory | null>(null);
  const [watering, setWatering] = useState<WateringNeed | null>(null);
  const [light, setLight] = useState<LightRequirement | null>(null);
  const [size, setSize] = useState<Size | null>(null);
  const [indoorOutdoor, setIndoorOutdoor] = useState<IndoorOutdoor | null>(null);
  const [propagationEase, setPropagationEase] = useState<PropagationEase | null>(null);
  const [petFriendly, setPetFriendly] = useState<PetFriendly | null>(null);
  const [selectedExtras, setSelectedExtras] = useState<Extras[]>([]);
  const [description, setDescription] = useState('');

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSelectImageOption = async () => {
    Alert.alert(
      t('add_plant_select_image_title'),
      t('add_plant_select_image_desc'),
      [
        {
          text: t('add_plant_select_picture_button'),
          onPress: pickImageFromLibrary,
        },
        {
          text: t('add_plant_take_picture_button'),
          onPress: takePictureWithCamera,
        },
        {
          text: t('add_plant_cancel_button'),
          style: 'cancel',
        },
      ]
    );
  };

  const pickImageFromLibrary = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [3, 4],
        quality: 0.7,
      });
      if (!result.canceled) {
        const resized = await resizeImage(result.assets[0].uri);
        setImage(resized);
      }
    } catch (err) {
      console.error('pickImageFromLibrary error:', err);
      Alert.alert('Error', 'Could not open image library.');
    }
  };

  const takePictureWithCamera = async () => {
    try {
      const cameraPermission = await ImagePicker.requestCameraPermissionsAsync();
      if (!cameraPermission.granted) {
        Alert.alert('Error', 'Camera permission denied.');
        return;
      }
      const result = await ImagePicker.launchCameraAsync({
        allowsEditing: true,
        aspect: [3, 4],
        quality: 0.7,
      });
      if (!result.canceled) {
        const resized = await resizeImage(result.assets[0].uri);
        setImage(resized);
      }
    } catch (err) {
      console.error('takePictureWithCamera error:', err);
      Alert.alert('Error', 'Could not open camera.');
    }
  };

  const resizeImage = async (uri: string) => {
    return await ImageManipulator.manipulateAsync(
      uri,
      [{ resize: { width: 800 } }],
      { compress: 0.7, format: ImageManipulator.SaveFormat.JPEG }
    );
  };

  const handleExtraToggle = (extra: Extras) => {
    setSelectedExtras((prev) =>
      prev.includes(extra)
        ? prev.filter((e) => e !== extra)
        : [...prev, extra]
    );
  };

  const isExtraSelected = (extra: Extras) => selectedExtras.includes(extra);

  const handleCancel = () => {
    navigation.goBack();
  };

  const handleSave = async () => {
    if (!speciesName.trim()) {
      Alert.alert('Validation Error', 'Species name is required.');
      return;
    }
    if (!stage) {
      Alert.alert('Validation Error', 'Plant stage is required.');
      return;
    }
    if (!image) {
      Alert.alert('Validation Error', 'An image is required.');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const plantRequest: PlantRequest = {
        speciesName: speciesName.trim(),
        plantStage: stage,
        description: description.trim() ? description : null,
        plantCategory: category,
        wateringNeed: watering,
        lightRequirement: light,
        size: size,
        indoorOutdoor: indoorOutdoor,
        propagationEase: propagationEase,
        petFriendly: petFriendly,
        extras: selectedExtras,
      };

      const photo = {
        uri: image.uri,
        name: 'plant.jpg',
        type: 'image/jpeg',
      } as any;

      const plantCreateRequest: PlantCreateRequest = {
        plantDetails: plantRequest,
        image: photo,
      };

      await plantService.addMyPlant(plantCreateRequest);
      queryClient.invalidateQueries('myPlants');
      navigation.goBack();
    } catch (err) {
      console.error('Error adding plant:', err);
      setError(t('add_plant_error_message'));
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <LinearGradient
        colors={[COLORS.primary, COLORS.secondary]}
        style={styles.gradientBackground}
      >
        <View style={headerStyles.headerAboveScroll}>
          <View style={headerStyles.headerColumn1}>
            <Ionicons
              name="chevron-back"
              size={30}
              color={COLORS.textLight}
              style={headerStyles.headerBackButton}
              onPress={() => navigation.goBack()}
            />
            <Text style={headerStyles.headerTitle}>{t('add_plant_title')}</Text>
          </View>
          <MaterialIcons name="info" size={24} color="#fff" />
        </View>
        <ScrollView
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={false}
        >
          <View style={styles.formContainer}>
            {error && <Text style={styles.errorText}>{error}</Text>}

            <Text style={styles.label}>{t('add_plant_species_name_label')}:</Text>
            <TextInput
              style={styles.input}
              value={speciesName}
              onChangeText={setSpeciesName}
              placeholder="e.g. Monstera Deliciosa"
            />

            <Text style={styles.label}>{t('add_plant_description_label')}:</Text>
            <TextInput
              style={[styles.input, { height: 80 }]}
              value={description}
              onChangeText={setDescription}
              multiline
            />

            <Text style={styles.label}>{t('add_plant_stage_label')}:</Text>
            <TagGroup
              mode="single"
              values={Object.values(PlantStage)}
              selectedValue={stage}
              onSelectSingle={(val) => setStage(val)}
              isRequired={true}
            />

            <Text style={styles.label}>{t('add_plant_category_label')}:</Text>
            <TagGroup
              mode="single"
              values={Object.values(PlantCategory)}
              selectedValue={category}
              onSelectSingle={(val) => setCategory(val === category ? null : val)}
              isRequired={false}
            />

            <Text style={styles.label}>{t('add_plant_watering_label')}:</Text>
            <TagGroup
              mode="single"
              values={Object.values(WateringNeed)}
              selectedValue={watering}
              onSelectSingle={(val) => setWatering(val === watering ? null : val)}
              isRequired={false}
            />

            <Text style={styles.label}>{t('add_plant_light_label')}:</Text>
            <TagGroup
              mode="single"
              values={Object.values(LightRequirement)}
              selectedValue={light}
              onSelectSingle={(val) => setLight(val === light ? null : val)}
              isRequired={false}
            />

            <Text style={styles.label}>{t('add_plant_size_question')}:</Text>
            <TagGroup
              mode="single"
              values={Object.values(Size)}
              selectedValue={size}
              onSelectSingle={(val) => setSize(val === size ? null : val)}
              isRequired={false}
            />

            <Text style={styles.label}>{t('add_plant_indoor_outdoor_question')}:</Text>
            <TagGroup
              mode="single"
              values={Object.values(IndoorOutdoor)}
              selectedValue={indoorOutdoor}
              onSelectSingle={(val) => setIndoorOutdoor(val === indoorOutdoor ? null : val)}
              isRequired={false}
            />

            <Text style={styles.label}>{t('add_plant_propagation_ease_question')}:</Text>
            <TagGroup
              mode="single"
              values={Object.values(PropagationEase)}
              selectedValue={propagationEase}
              onSelectSingle={(val) => setPropagationEase(val === propagationEase ? null : val)}
              isRequired={false}
            />

            <Text style={styles.label}>{t('add_plant_pet_friendly_question')}:</Text>
            <TagGroup
              mode="single"
              values={Object.values(PetFriendly)}
              selectedValue={petFriendly}
              onSelectSingle={(val) => setPetFriendly(val === petFriendly ? null : val)}
              isRequired={false}
            />

            <Text style={styles.label}>{t('add_plant_extras_question')}:</Text>
            <TagGroup
              mode="multiple"
              values={Object.values(Extras)}
              selectedValues={selectedExtras}
              onToggleMulti={(val) => handleExtraToggle(val)}
            />

            <Text style={styles.label}>{t('add_plant_select_image_title')}:</Text>
            <TouchableOpacity style={styles.imageButton} onPress={handleSelectImageOption}>
              <Ionicons name="image" size={24} color="#fff" />
              <Text style={styles.imageButtonText}>
                {t('add_plant_select_image_title')}
              </Text>
            </TouchableOpacity>
            {image ? (
              <Image source={{ uri: image.uri }} style={styles.previewImage} />
            ) : (
              <Text style={styles.noImageText}>
                {t('add_plant_no_image_selected')}
              </Text>
            )}

            <ConfirmCancelButtons
              onConfirm={handleSave}
              onCancel={handleCancel}
              confirmButtonText={t('add_plant_save_button')}
              cancelButtonText={t('add_plant_cancel_button')}
              loading={loading}
            />
          </View>
        </ScrollView>
      </LinearGradient>
    </View>
  );
};

export default AddPlantScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  gradientBackground: {
    flex: 1,
  },
  scrollContent: {
    paddingTop: 0,
    paddingBottom: 30,
  },
  formContainer: {
    backgroundColor: '#fff',
    marginHorizontal: 20,
    borderRadius: 12,
    padding: 16,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOpacity: 0.1,
        shadowRadius: 5,
        shadowOffset: { width: 0, height: 4 },
      },
      android: {
        elevation: 3,
      },
    }),
  },
  errorText: {
    color: COLORS.textDark,
    marginBottom: 10,
    fontWeight: '600',
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: COLORS.textDark,
    marginTop: 12,
    marginBottom: 4,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    fontSize: 14,
  },
  imageButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: COLORS.accentLightRed,
    padding: 10,
    borderRadius: 8,
  },
  imageButtonText: {
    fontSize: 14,
    color: '#fff',
    marginLeft: 6,
    fontWeight: '600',
  },
  previewImage: {
    width: '100%',
    aspectRatio: 3 / 4,
    borderRadius: 8,
    marginTop: 6,
    marginBottom: 10,
    resizeMode: 'cover',
  },
  noImageText: {
    fontSize: 14,
    color: '#555',
    marginTop: 3,
    marginLeft: 13,
    marginBottom: 15,
  },
});


// File: app\features\main\screens\BrowseMatchesScreen.tsx
// File: app/features/main/screens/BrowseMatchesScreen.tsx

import React from "react";
import {
  View,
  Text,
  ActivityIndicator,
  FlatList,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import { SafeAreaProvider } from "react-native-safe-area-context";
import { useRoute, useNavigation } from "@react-navigation/native";
import { LinearGradient } from "expo-linear-gradient";

// Import your custom hooks and components
import { useUserMatches } from "../hooks/useUserMatches";
import { useMyProfile } from "../hooks/useMyProfileHooks";
import MatchCard from "../components/MatchCard";
import { headerStyles } from "../styles/headerStyles";
import { COLORS } from "../../../theme/colors";
import { Ionicons } from "@expo/vector-icons";

// Define the route params type
type RouteParams = {
  connectionId: number;
};

const BrowseMatchesScreen: React.FC = () => {
  // Get the connectionId from the route parameters
  const route = useRoute();
  const { connectionId } = route.params as RouteParams;

  const navigation = useNavigation();

  // Use react-query hook to fetch matches for this connection
  const { data: matches, isLoading, isError, refetch } = useUserMatches(connectionId);

  // Get the current user's profile (to pass currentUserId to MatchCard)
  const { data: myProfile, isLoading: profileLoading, isError: profileError } = useMyProfile();

  // Display a loading indicator if either query is loading
  if (isLoading || profileLoading) {
    return (
      <SafeAreaProvider style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
      </SafeAreaProvider>
    );
  }

  // Display an error view if there is an error loading matches or profile
  if (isError || profileError) {
    return (
      <SafeAreaProvider style={styles.errorContainer}>
        <Text style={styles.errorText}>Failed to load matches.</Text>
        <TouchableOpacity style={styles.retryButton} onPress={() => refetch()}>
          <Text style={styles.retryButtonText}>Retry</Text>
        </TouchableOpacity>
      </SafeAreaProvider>
    );
  }

  // Render each match using the MatchCard component
  const renderItem = ({ item }: { item: any }) => (
    <MatchCard match={item} currentUserId={myProfile!.userId} />
  );

  return (
    <SafeAreaProvider style={styles.container}>
      <LinearGradient
        colors={[COLORS.primary, COLORS.secondary]}
        style={headerStyles.headerGradient}
      >
        <View style={headerStyles.headerColumn1}>
          <TouchableOpacity
            style={headerStyles.headerBackButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="chevron-back" size={30} color={COLORS.textLight} />
            
          </TouchableOpacity>
          <Text style={headerStyles.headerTitle}>Browse Matches</Text>
        </View>
      </LinearGradient>
      <FlatList
        data={matches}
        keyExtractor={(item) => item.matchId.toString()}
        renderItem={renderItem}
        contentContainerStyle={styles.listContent}
      />
    </SafeAreaProvider>
  );
};

export default BrowseMatchesScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  errorContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 20,
  },
  errorText: {
    fontSize: 16,
    color: COLORS.textDark,
    marginBottom: 10,
    textAlign: "center",
  },
  retryButton: {
    backgroundColor: COLORS.primary,
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  retryButtonText: {
    color: "#fff",
    fontWeight: "600",
    fontSize: 16,
  },
  listContent: {
    paddingHorizontal: 16,
  },
});


// File: app\features\main\screens\ChatScreen.tsx
// File: src/features/main/screens/ChatScreen.tsx

import React, { useEffect, useMemo, useRef, useState, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  TextInput,
  TouchableOpacity,
  FlatList,
  KeyboardAvoidingView,
  Platform,
  Alert,
  Image,
  Animated,
} from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useTranslation } from 'react-i18next';
import { useRoute, useNavigation } from '@react-navigation/native';
import { LinearGradient } from 'expo-linear-gradient';

// Hooks
import { useMyProfile } from '../hooks/useMyProfileHooks';
import { useMessages } from '../hooks/useMessages';
import { useOtherProfile } from '../hooks/useOtherProfile';

// For fetching trade proposals
import { useQuery } from 'react-query';
import { connectionService } from '../../../api/connectionService';
import { TradeProposalResponse } from '../../../types/apiTypes';
import { TradeProposalStatus } from '../../../types/enums';

// Types
import { MessageResponse, MessageRequest } from '../../../types/apiTypes';

// Theme & Styles
import { COLORS } from '../../../theme/colors';
import { headerStyles } from '../styles/headerStyles';

// Components
import { MessageBubble } from '../components/MessageBubble';
import ProfileCardShelf, { ProfileCardShelfRef } from '../components/ProfileCardShelf';

// ---------- Custom hook for trade proposals ----------
const useTradeProposals = (connectionId: number) => {
  return useQuery<TradeProposalResponse[], Error>(
    ['tradeProposals', connectionId],
    () => connectionService.getTradeProposals(connectionId),
    { staleTime: 1000 * 60 }
  );
};

const ChatScreen: React.FC = () => {
  const { t } = useTranslation();
  const route = useRoute();
  const navigation = useNavigation();

  // Expect connectionId and otherUserId from route parameters
  const { connectionId, otherUserId } = route.params as {
    connectionId: number;
    otherUserId: number;
  };

  // Current user (to distinguish our messages)
  const {
    data: myProfile,
    isLoading: loadingMyProfile,
    isError: errorMyProfile,
  } = useMyProfile();

  // Other user's profile (for the ProfileCardShelf)
  const {
    data: otherUserProfile,
    isLoading: loadingOtherUser,
    isError: errorOtherUser,
  } = useOtherProfile(otherUserId);

  // Messages for this connection
  const {
    messages,
    isLoadingMessages,
    isErrorMessages,
    refetchMessages,
    sendMessage,
    isSending,
  } = useMessages(connectionId);

  // Trade proposals for this connection (to compute pending proposals)
  const { data: proposals } = useTradeProposals(connectionId);
  const pendingProposals = proposals?.filter(
    (proposal) => proposal.tradeProposalStatus === TradeProposalStatus.Pending
  ) || [];
  const pendingCount = pendingProposals.length;

  // --- Animated values for the trade proposals button ---
  const buttonWidth = useRef(new Animated.Value(56)).current;
  const glimmerAnim = useRef(new Animated.Value(1)).current;

  useEffect(() => {
    if (pendingCount > 0) {
      // Expand the background to reveal text
      Animated.timing(buttonWidth, {
        toValue: 210, // or whatever max width you want
        duration: 300,
        useNativeDriver: false,
      }).start();

      // Pulse
      Animated.loop(
        Animated.sequence([
          Animated.timing(glimmerAnim, {
            toValue: 0.8,
            duration: 500,
            useNativeDriver: false,
          }),
          Animated.timing(glimmerAnim, {
            toValue: 1,
            duration: 500,
            useNativeDriver: false,
          }),
        ]),
        { resetBeforeIteration: true }
      ).start();
    } else {
      // Shrink back to icon-only
      Animated.timing(buttonWidth, {
        toValue: 56,
        duration: 300,
        useNativeDriver: false,
      }).start();

      // Stop pulsing by resetting
      glimmerAnim.setValue(1);
    }
  }, [pendingCount]);

  // Animated style for the button
  const buttonAnimatedStyle = {
    width: buttonWidth,
    opacity: glimmerAnim,
  };

  // Sort messages by ascending sent time
  const sortedMessages = useMemo(() => {
    if (!messages) return [];
    return [...messages].sort(
      (a, b) => new Date(a.sentAt).getTime() - new Date(b.sentAt).getTime()
    );
  }, [messages]);

  // Auto-scroll to bottom when messages update
  const flatListRef = useRef<FlatList<MessageResponse>>(null);
  useEffect(() => {
    if (sortedMessages.length > 0) {
      setTimeout(() => {
        flatListRef.current?.scrollToEnd({ animated: true });
      }, 300);
    }
  }, [sortedMessages]);

  // Input state
  const [inputText, setInputText] = useState('');

  // Handle sending a message
  const handleSendMessage = useCallback(() => {
    const text = inputText.trim();
    if (!text) return;
    setInputText('');
    const payload: MessageRequest = { messageText: text };
    sendMessage(payload, {
      onError: (error) => {
        console.error('Error sending message:', error);
        Alert.alert(t('chat_error'), t('chat_send_failed'));
      },
    });
  }, [inputText, sendMessage, t]);

  // Ref for ProfileCardShelf (if used) to close it on input focus
  const shelfRef = useRef<ProfileCardShelfRef>(null);
  const handleInputFocus = useCallback(() => {
    shelfRef.current?.closeShelf();
  }, []);

  if (loadingMyProfile || isLoadingMessages || loadingOtherUser) {
    return (
      <SafeAreaProvider style={styles.centerContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
        <Text style={styles.loadingText}>{t('chat_loading_conversation')}</Text>
      </SafeAreaProvider>
    );
  }

  if (errorMyProfile || isErrorMessages || errorOtherUser) {
    return (
      <SafeAreaProvider style={styles.centerContainer}>
        <Text style={styles.errorText}>{t('chat_error_message')}</Text>
        <TouchableOpacity style={styles.retryButton} onPress={() => refetchMessages()}>
          <Text style={styles.retryButtonText}>{t('chat_retry_button')}</Text>
        </TouchableOpacity>
      </SafeAreaProvider>
    );
  }

  // Navigate to "Browse Matches" screen
  const handleBrowseMatches = () => {
    navigation.navigate('BrowseMatches' as never, { connectionId } as never);
  };

  // Navigate to Trade Proposals screen
  const handleOpenTradeProposals = () => {
    navigation.navigate('TradeProposals' as never, { connectionId } as never);
  };

  // Navigate to Make Trade Proposal screen (for creating a new proposal)
  const handleOpenTradeProposal = () => {
    navigation.navigate('MakeTradeProposal' as never, { connectionId, otherUserId } as never);
  };

  // Navigate to the other user's profile screen
  const handleNavigateToProfile = () => {
    navigation.navigate('OtherProfile' as never, { userId: otherUserProfile.userId } as never);
  };

  return (
    <SafeAreaProvider style={styles.container}>
      {/* Header */}
      <LinearGradient
        style={[headerStyles.headerGradient, { marginBottom: 0 }]}
        colors={[COLORS.primary, COLORS.secondary]}
      >
        <View style={headerStyles.headerColumn1}>
          <TouchableOpacity style={headerStyles.headerBackButton} onPress={() => navigation.goBack()}>
            <Ionicons name="chevron-back" size={30} color={COLORS.textLight} />
          </TouchableOpacity>
          {otherUserProfile && (
            <TouchableOpacity style={styles.headerUserInfo} onPress={handleNavigateToProfile}>
              <Image
                source={{ uri: otherUserProfile.profilePictureUrl }}
                style={styles.headerUserImage}
              />
              <Text style={headerStyles.headerTitle}>{otherUserProfile.name}</Text>
            </TouchableOpacity>
          )}
        </View>
      </LinearGradient>

      {/* "Browse Matches" button */}
      <TouchableOpacity style={styles.browseButton} onPress={handleBrowseMatches}>
        <Text style={styles.browseButtonText}>
          {t('chat_browse_matches_button', 'Browse Matches')}
        </Text>
      </TouchableOpacity>



      {/* Chat messages */}
      {sortedMessages.length === 0 ? (
        <View style={styles.emptyChatContainer}>
          <Text style={styles.noMessagesText}>{t('chat_no_messages_yet')}</Text>
        </View>
      ) : (
        <View style={styles.listContainer}>
          <FlatList
            ref={flatListRef}
            data={sortedMessages}
            keyExtractor={(item) => item.messageId.toString()}
            contentContainerStyle={styles.listContent}
            renderItem={({ item }) => {
              const isMine = item.senderUserId === myProfile?.userId;
              return <MessageBubble message={item} isMine={isMine} />;
            }}
          />
        </View>
      )}

      <View style={styles.floatingButtonsContainer}>
        <Animated.View
          style={[
            styles.pendingButtonContainer,
            { width: buttonWidth, opacity: glimmerAnim },
          ]}
        >
          {/* Single Touchable: tapping text or circle calls the same onPress */}
          <TouchableOpacity
            style={styles.pendingButtonTouchable}
            onPress={handleOpenTradeProposals}
            activeOpacity={0.8}
          >
            {/* The “pill” background behind everything */}
            <View style={styles.backgroundBar}>
              {pendingCount > 0 && (
                <Text style={styles.pendingButtonText}>
                  {`${pendingCount} pending proposals`}
                </Text>
              )}
            </View>

            {/* The circle button (with icon + shadow) pinned on the left */}
            <View style={styles.circleButton}>
              <Ionicons name="document-text-outline" size={24} color="#fff" />
            </View>
          </TouchableOpacity>
        </Animated.View>

        {/* Floating Trade Proposals Button (right bottom) */}
        <TouchableOpacity style={styles.tradeFab} onPress={handleOpenTradeProposal}>
          <Ionicons name="swap-horizontal" size={26} color="#fff" />
        </TouchableOpacity>

      </View>

      {/* Message Input */}
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : undefined}
        keyboardVerticalOffset={10}
      >
        <View style={styles.inputContainer}>
          <TextInput
            style={styles.textInput}
            value={inputText}
            onChangeText={setInputText}
            placeholder={t('chat_message_placeholder')}
            multiline
            onFocus={handleInputFocus}
          />
          {isSending ? (
            <ActivityIndicator style={{ marginRight: 12 }} color={COLORS.primary} />
          ) : (
            <TouchableOpacity onPress={handleSendMessage} style={styles.sendButton}>
              <Ionicons name="send" size={20} color={COLORS.background} />
            </TouchableOpacity>
          )}
        </View>
      </KeyboardAvoidingView>
    </SafeAreaProvider>
  );
};

export default ChatScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  // Header User Info
  headerUserInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginLeft: 10,
  },
  headerUserImage: {
    borderColor: COLORS.accentGreen,
    borderWidth: 3,
    width: 60,
    height: 60,
    borderRadius: 30,
    marginRight: 8,
    backgroundColor: '#ccc',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
  },
  loadingText: {
    fontSize: 16,
    color: COLORS.textDark,
    marginTop: 10,
    textAlign: 'center',
  },
  errorText: {
    fontSize: 16,
    color: COLORS.textDark,
    marginBottom: 10,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: COLORS.accentGreen,
    borderRadius: 8,
    paddingHorizontal: 16,
    paddingVertical: 10,
    marginTop: 10,
  },
  retryButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  // "Browse Matches" button
  browseButton: {
    margin: 10,
    padding: 12,
    borderRadius: 8,
    backgroundColor: '#fff',
    alignSelf: 'center',
    minWidth: '60%',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOpacity: 0.1,
    shadowRadius: 5,
    elevation: 2,
  },
  browseButtonText: {
    color: COLORS.textDark,
    fontSize: 16,
    fontWeight: '600',
  },
  // If no messages
  emptyChatContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  noMessagesText: {
    fontSize: 16,
    color: COLORS.textDark,
    textAlign: 'center',
    paddingHorizontal: 20,
  },
  // Chat messages list
  listContainer: {
    flex: 1,
  },
  listContent: {
    padding: 8,
    paddingBottom: 60,
  },
  // Input
  inputContainer: {
    flexDirection: 'row',
    paddingVertical: 8,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderTopColor: '#ddd',
    alignItems: 'flex-end',
  },
  textInput: {
    flex: 1,
    minHeight: 40,
    maxHeight: 100,
    backgroundColor: '#f2f2f2',
    borderRadius: 20,
    paddingHorizontal: 12,
    paddingVertical: 8,
    marginRight: 8,
    fontSize: 14,
  },
  sendButton: {
    backgroundColor: COLORS.accentGreen,
    borderRadius: 20,
    padding: 10,
  },
  // Floating Buttons
  floatingButtonsContainer: {
    position: 'relative',
    flexDirection: 'row',
  },
  // Floating Trade Proposals Button (right bottom)
  tradeFab: {
    position: 'absolute',
    bottom: 20,
    right: 20,
    backgroundColor: COLORS.accentGreen,
    width: 56,
    height: 56,
    borderRadius: 28,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 4,
  },

  // Pending Proposals Button (bottom-left)
  // The container we animate in width (and keep a fixed height).
  // We use overflow: 'hidden' so text slides out from under the circle.
  pendingButtonContainer: {
    position: 'absolute',
    bottom: 20,
    left: 20,
    height: 56,
    borderRadius: 28,
    overflow: 'hidden',
  },

  // Make the entire area clickable by wrapping in a single Touchable.
  pendingButtonTouchable: {
    flex: 1,
    borderRadius: 28,
  },

  // The pill behind the circle and text:
  backgroundBar: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: COLORS.accentGreen,
    borderRadius: 28,
    paddingLeft: 56, // Leave room for the circle on the left
    justifyContent: 'center', 
    paddingRight: 16, 
  },

  // The text that appears when expanded:
  pendingButtonText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 14,
    alignSelf: 'flex-end',
  },

  // The circle with the icon on top, pinned on the left:
  circleButton: {
    position: 'absolute',
    left: 0,
    top: 0,
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: COLORS.accentGreen,
    alignItems: 'center',
    justifyContent: 'center',

    // Shadow (iOS + Android)
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },
});


// File: app\features\main\screens\ConnectionsScreen.tsx
// File: src/features/main/screens/ConnectionsScreen.tsx

import React, { useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  TouchableOpacity,
  FlatList,
  Image,
  Dimensions,
} from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useTranslation } from 'react-i18next';
import { useNavigation } from '@react-navigation/native';

import { LinearGradient } from 'expo-linear-gradient';

import { useMyProfile } from '../hooks/useMyProfileHooks';
import { useConnections } from '../hooks/useConnections';

// Types
import { ConnectionResponse, UserResponse } from '../../../types/apiTypes';

// Theme & Styles
import { COLORS } from '../../../theme/colors';
import { headerStyles } from '../styles/headerStyles';

const { width } = Dimensions.get('window');

const ConnectionsScreen: React.FC = () => {
  const { t } = useTranslation();
  const navigation = useNavigation();

  // Fetch the current user's profile to identify myUserId
  const {
    data: userProfile,
    isLoading: loadingProfile,
    isError: errorProfile,
  } = useMyProfile();

  // Fetch the user's connections
  const {
    data: connections,
    isLoading: loadingConnections,
    isError: errorConnections,
    refetch: refetchConnections,
  } = useConnections();

  // If we haven't loaded the user yet, handle loading state
  if (!userProfile) {
    return (
      <SafeAreaProvider style={styles.centerContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
        <Text style={styles.loadingText}>{t('connections_loading')}</Text>
      </SafeAreaProvider>
    );
  }
  
  const myUserId = userProfile.userId;

  /**
   * Navigate to a details or conversation screen for the selected connection.
   * Now passes both connectionId and otherUserId to ChatScreen.
   */
  const handleConversationPress = useCallback(
    (connectionId: number, otherUserId: number) => {
      navigation.navigate('Chat' as never, { connectionId, otherUserId } as never);
    },
    [navigation]
  );

  // ------------ RENDER LOGIC ------------
  if (loadingProfile || loadingConnections) {
    return (
      <SafeAreaProvider style={styles.centerContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
        <Text style={styles.loadingText}>{t('connections_loading')}</Text>
      </SafeAreaProvider>
    );
  }

  if (errorProfile || errorConnections) {
    return (
      <SafeAreaProvider style={styles.centerContainer}>
        <Text style={styles.errorText}>{t('connections_error')}</Text>
        <TouchableOpacity style={styles.retryButton} onPress={refetchConnections}>
          <Text style={styles.retryButtonText}>{t('connections_retry_button')}</Text>
        </TouchableOpacity>
      </SafeAreaProvider>
    );
  }

  // If no connections, show empty state
  if (!connections || connections.length === 0) {
    return (
      <SafeAreaProvider style={styles.container}>
        <LinearGradient
          style={headerStyles.headerGradient}
          colors={[COLORS.primary, COLORS.secondary]}
        >
          <Text style={headerStyles.headerTitle}>
            {t('connections_title')}
          </Text>
        </LinearGradient>

        <View style={styles.emptyStateContainer}>
          <Ionicons
            name="people-outline"
            size={64}
            color={COLORS.accentGreen}
            style={{ marginBottom: 20 }}
          />
          <Text style={styles.emptyStateTitle}>{t('connections_none_title')}</Text>
          <Text style={styles.emptyStateMessage}>
            {t('connections_none_message')}
          </Text>
            <Text style={styles.emptyStateButtonText}>
              {t('connections_none_action')}
            </Text>
        </View>
      </SafeAreaProvider>
    );
  }

  return (
    <SafeAreaProvider style={styles.container}>
      {/* Header */}
      <LinearGradient
        style={headerStyles.headerGradient}
        colors={[COLORS.primary, COLORS.secondary]}
      >
        <Text style={headerStyles.headerTitle}>
          {t('connections_title', 'Connections')}
        </Text>
      </LinearGradient>

      {/* Connections list */}
      <FlatList
        data={connections}
        keyExtractor={(item) => item.connectionId.toString()}
        contentContainerStyle={{ paddingBottom: 20 }}
        renderItem={({ item }) => {
          const connection: ConnectionResponse = item;
          
          // Identify the other user
          const isUser1Me = connection.user1.userId === myUserId;
          const otherUser: UserResponse = isUser1Me
            ? connection.user2
            : connection.user1;

          return (
            <TouchableOpacity
              style={styles.rowContainer}
              onPress={() => handleConversationPress(connection.connectionId, otherUser.userId)}
              activeOpacity={0.8}
            >
              <Image
                source={
                  otherUser.profilePictureUrl
                    ? { uri: otherUser.profilePictureUrl }
                    : require('../../../../assets/images/icon.png') // fallback
                }
                style={styles.avatar}
              />
              <View style={styles.textSection}>
                <Text style={styles.userName}>{otherUser.name}</Text>
                {/* Using connection.numberOfMatches to show match info if relevant */}
                <Text style={styles.matchCount}>
                  {t('connections_matches_label', {
                    count: connection.numberOfMatches,
                  })}
                </Text>
              </View>
              <Ionicons
                name="chevron-forward"
                size={24}
                color={COLORS.textDark}
              />
            </TouchableOpacity>
          );
        }}
      />
    </SafeAreaProvider>
  );
};

export default ConnectionsScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: COLORS.textDark,
  },
  errorText: {
    fontSize: 16,
    color: COLORS.textDark,
    marginBottom: 10,
    textAlign: 'center',
  },
  retryButton: {
    paddingHorizontal: 16,
    paddingVertical: 10,
    backgroundColor: COLORS.primary,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  rowContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff',
    marginHorizontal: 10,
    marginVertical: 6,
    borderRadius: 8,
    padding: 10,
    // Shadow/elevation for iOS/Android
    shadowColor: '#000',
    shadowOpacity: 0.1,
    shadowRadius: 5,
    shadowOffset: { width: 0, height: 2 },
    elevation: 2,
  },
  avatar: {
    width: 52,
    height: 52,
    borderRadius: 26,
    marginRight: 12,
    backgroundColor: '#eee',
  },
  textSection: {
    flex: 1,
    justifyContent: 'center',
  },
  userName: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.textDark,
    marginBottom: 4,
  },
  matchCount: {
    fontSize: 14,
    color: '#777',
  },

  // Empty state
  emptyStateContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingHorizontal: 30,
  },
  emptyStateTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: COLORS.textDark,
    marginBottom: 8,
    textAlign: 'center',
  },
  emptyStateMessage: {
    fontSize: 14,
    color: '#555',
    textAlign: 'center',
    marginBottom: 20,
  },
  emptyStateButton: {
    backgroundColor: COLORS.accentGreen,
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 8,
    marginTop: 10,
  },
  emptyStateButtonText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 14,
  },
});


// File: app\features\main\screens\MakeTradeProposalScreen.tsx
// File: app/features/main/screens/MakeTradeProposalScreen.tsx
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  TouchableOpacity,
  Alert,
  Dimensions,
  ScrollView,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';

import {
  usePlantsLikedByMeFromUser,
  usePlantsLikedByUserFromMe,
} from '../hooks/usePlantHooks';
import { useCreateTradeProposal } from '../hooks/useTradeProposalHooks';
import { PlantResponse } from '../../../types/apiTypes';
import PlantThumbnail from '../components/PlantThumbnail';
import PlantCardWithInfo from '../components/PlantCardWithInfo';
import InfoModal from '../modals/InfoModal';
import { COLORS } from '../../../theme/colors';

const { width, height } = Dimensions.get('window');

interface MakeTradeProposalRouteParams {
  connectionId: number;
  otherUserId: number;
}

const MakeTradeProposalScreen: React.FC = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { connectionId, otherUserId } = route.params as MakeTradeProposalRouteParams;

  const {
    data: othersPlantsILiked,
    isLoading: loadingOtherPlants,
    isError: errorOtherPlants,
  } = usePlantsLikedByMeFromUser(otherUserId);

  const {
    data: myPlantsTheyLiked,
    isLoading: loadingMyPlants,
    isError: errorMyPlants,
  } = usePlantsLikedByUserFromMe(otherUserId);

  const { mutate: createTradeProposal, isLoading: creatingProposal } =
    useCreateTradeProposal(connectionId);

  const [selectedOtherPlantIds, setSelectedOtherPlantIds] = useState<number[]>([]);
  const [selectedMyPlantIds, setSelectedMyPlantIds] = useState<number[]>([]);
  const [plantInfo, setPlantInfo] = useState<PlantResponse | null>(null);

  const toggleOtherPlantSelection = (plantId: number) => {
    setSelectedOtherPlantIds((prev) =>
      prev.includes(plantId) ? prev.filter((id) => id !== plantId) : [...prev, plantId]
    );
  };

  const toggleMyPlantSelection = (plantId: number) => {
    setSelectedMyPlantIds((prev) =>
      prev.includes(plantId) ? prev.filter((id) => id !== plantId) : [...prev, plantId]
    );
  };

  const handleTrade = () => {
    if (selectedOtherPlantIds.length === 0 && selectedMyPlantIds.length === 0) {
      Alert.alert('Empty Trade', 'Select at least one plant to trade!');
      return;
    }
    const payload = {
      userPlantIds: selectedMyPlantIds,
      otherPlantIds: selectedOtherPlantIds,
    };
    createTradeProposal(payload, {
      onSuccess: () => {
        Alert.alert('Success', 'Trade proposal created!', [
          { text: 'OK', onPress: () => navigation.goBack() },
        ]);
      },
      onError: (err) => {
        console.error('Failed to create proposal:', err);
        Alert.alert('Error', 'Could not create proposal. Try again.');
      },
    });
  };

  const renderHorizontalSection = (
    label: string,
    data: PlantResponse[] | undefined,
    selectedIds: number[],
    onToggle: (id: number) => void
  ) => {
    if (!data) return null;
    return (
      <View style={styles.sectionWrapper}>
        <Text style={styles.sectionTitle}>{label}</Text>
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.horizontalScrollContent}
        >
          {data.map((plant) => {
            const isSelected = selectedIds.includes(plant.plantId);
            return (
              <PlantThumbnail
                key={plant.plantId}
                plant={plant}
                isSelected={isSelected}
                selectable
                onPress={() => onToggle(plant.plantId)}
                onInfoPress={() => setPlantInfo(plant)}
              />
            );
          })}
        </ScrollView>
      </View>
    );
  };

  if (loadingOtherPlants || loadingMyPlants) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
        <Text style={styles.loadingText}>Loading liked plants...</Text>
      </View>
    );
  }

  if (errorOtherPlants || errorMyPlants) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>Couldn’t load plants. Please retry.</Text>
        <TouchableOpacity style={styles.closeButton} onPress={() => navigation.goBack()}>
          <Ionicons name="close" size={24} color="#fff" />
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={styles.modalBackground}>
      <LinearGradient style={styles.modalContainer} colors={[COLORS.primary, COLORS.secondary]}>
        <TouchableOpacity style={styles.closeButton} onPress={() => navigation.goBack()}>
          <Ionicons name="close" size={24} color="#fff" />
        </TouchableOpacity>

        {renderHorizontalSection("They’re Offering?", othersPlantsILiked, selectedOtherPlantIds, toggleOtherPlantSelection)}

        {/* Enhanced Divider with a Cool Gradient Trade Button */}
        <View style={styles.tradeDividerContainer}>
          <View style={styles.dividerLine} />
          <TouchableOpacity style={styles.tradeButtonWrapper} onPress={handleTrade}>
            <LinearGradient colors={['#ff8c00', '#ff4500']} style={styles.tradeButton}>
              {creatingProposal ? (
                <ActivityIndicator size="small" color="#fff" />
              ) : (
                <View style={styles.tradeButtonContent}>
                  <Ionicons name="swap-horizontal" size={20} color="#fff" />
                  <Text style={styles.tradeButtonText}> TRADE</Text>
                </View>
              )}
            </LinearGradient>
          </TouchableOpacity>
          <View style={styles.dividerLine} />
        </View>

        {renderHorizontalSection("You’re Offering?", myPlantsTheyLiked, selectedMyPlantIds, toggleMyPlantSelection)}
      </LinearGradient>

      {/* Reusable InfoModal */}
      <InfoModal visible={!!plantInfo} onClose={() => setPlantInfo(null)}>
        {plantInfo && <PlantCardWithInfo plant={plantInfo} compact={false} />}
      </InfoModal>
    </View>
  );
};

export default MakeTradeProposalScreen;

const styles = StyleSheet.create({
  modalBackground: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    // Center content vertically and horizontally
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    margin: 20,
    borderRadius: 20,
    padding: 20,
    alignItems: 'center',
    position: 'relative',
    shadowColor: '#000',
    shadowOpacity: 0.25,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 4 },
    elevation: 10,
  },
  closeButton: {
    position: 'absolute',
    top: 15,
    right: 15,
    backgroundColor: 'rgba(255,255,255,0.3)',
    borderRadius: 20,
    padding: 6,
    zIndex: 5,
  },
  sectionWrapper: {
    width: '100%',
    marginVertical: 10,
  },
  sectionTitle: {
    fontSize: 18,
    color: '#fff',
    fontWeight: '700',
    textAlign: 'center',
    marginBottom: 8,
  },
  horizontalScrollContent: {
    paddingHorizontal: 10,
  },
  // New Divider and Trade Button Styles
  tradeDividerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 20,
    width: '100%',
  },
  dividerLine: {
    flex: 1,
    height: 1,
    backgroundColor: '#fff',
    opacity: 0.7,
  },
  tradeButtonWrapper: {
    marginHorizontal: 10,
  },
  tradeButton: {
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 25,
    shadowColor: '#000',
    shadowOpacity: 0.3,
    shadowRadius: 4,
    shadowOffset: { width: 0, height: 2 },
    elevation: 5,
  },
  tradeButtonContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  tradeButtonText: {
    color: '#fff',
    fontWeight: '700',
    fontSize: 16,
    marginLeft: 5,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    color: '#fff',
    fontSize: 16,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
  },
  errorText: {
    fontSize: 16,
    color: '#fff',
    textAlign: 'center',
    marginBottom: 10,
  },
});


// File: app\features\main\screens\MyProfileScreen.tsx
// src/screens/MyProfileScreen.tsx

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  TouchableOpacity,
  Platform,
  ScrollView,
  Dimensions
} from 'react-native';
import { SafeAreaView, SafeAreaProvider } from 'react-native-safe-area-context';
import { useTranslation } from 'react-i18next';
import { useNavigation } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import { PlantCardWithInfo } from '../components/PlantCardWithInfo';
import { useMyProfile } from '../hooks/useMyProfileHooks';
import { useMyPlants } from '../hooks/usePlantHooks';
import { useSearchRadius } from '../hooks/useSearchRadius';
import { PlantResponse } from '../../../types/apiTypes';
import { COLORS } from '../../../theme/colors';
import { EditProfileModal } from '../modals/EditProfileModal';
import PlantThumbnail  from '../components/PlantThumbnail';
import { headerStyles } from '../styles/headerStyles';
import { ProfileCard } from '../components/ProfileCard';
import { ToggleButton } from '../components/ToggleButton'; // Import the new ToggleButton component

const MyProfileScreen: React.FC = () => {
  const { t } = useTranslation();
  const navigation = useNavigation();

  // Hooks
  const {
    data: userProfile,
    isLoading: loadingProfile,
    isError: errorProfile,
    refetch: refetchProfile,
  } = useMyProfile();
  const {
    data: myPlants,
    isLoading: loadingPlants,
    isError: errorPlants,
    refetch: refetchPlants,
  } = useMyPlants();
  const {
    searchRadius,
    isLoading: srLoading,
    isError: srError,
  } = useSearchRadius();

  // For showing city, country
  const [cityCountry, setCityCountry] = useState<string>('');
  const [editProfileVisible, setEditProfileVisible] = useState(false);

  // Toggle: Thumbnails or Full-size for plants
  const [viewOption, setViewOption] = useState<'Thumbnails' | 'Full Size'>('Thumbnails');

  // Position for the EditProfileModal
  const [editCardLayout, setEditCardLayout] = useState({
    x: 0,
    y: 0,
    width: 0,
    height: 0,
  });
  const cardRef = useRef<View>(null);
  const screenWidth = Dimensions.get('window').width;

  // Handler for measuring the card and opening the modal
  const openEditModal = () => {
    cardRef.current?.measureInWindow((x, y, width, height) => {
      setEditCardLayout({ x, y, width, height });
      setEditProfileVisible(true);
    });
  };

  const OnDelete = () => {
    // Implement delete functionality here
  };

  // Navigation to AddPlant
  const handleAddPlant = () => {
    navigation.navigate('AddPlant' as never);
  };

  // Rendering plants
  const renderPlantItem = (item: PlantResponse) => {
    if (viewOption === 'Thumbnails') {
      return (
        <PlantThumbnail
          key={item.plantId}
          plant={item}
          selectable
          deletable
          onPress={OnDelete}
        />
      );
    } else {
      return (
        <View key={item.plantId} style={styles.plantCardWrapper}>
          <PlantCardWithInfo plant={item} />
        </View>
      );
    }
  };

  // Loading states
  if (loadingProfile || loadingPlants || srLoading) {
    return (
      <SafeAreaView style={styles.centerContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
        <Text style={styles.loadingText}>{t('profile_loading_message')}</Text>
      </SafeAreaView>
    );
  }

  if (errorProfile || errorPlants || srError) {
    return (
      <SafeAreaView style={styles.centerContainer}>
        <Text style={styles.errorText}>{t('profile_error_message')}</Text>
        <TouchableOpacity
          onPress={() => {
            refetchProfile();
            refetchPlants();
          }}
          style={styles.retryButton}
        >
          <Text style={styles.retryButtonText}>{t('profile_retry_button')}</Text>
        </TouchableOpacity>
      </SafeAreaView>
    );
  }

  if (!userProfile) {
    return (
      <SafeAreaView style={styles.centerContainer}>
        <Text style={styles.errorText}>{t('profile_no_user_profile_error')}</Text>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaProvider style={styles.container}>
      <ScrollView style={{ flex: 1 }}>
        {/* Header */}
        <LinearGradient
          colors={[COLORS.primary, COLORS.secondary]}
          style={headerStyles.headerGradient}
        >
          <Text style={headerStyles.headerTitle}>{t('profile_title')}</Text>
        </LinearGradient>

        {/* --- Profile Card --- */}
        <View ref={cardRef} style={styles.cardContainer}>
          <ProfileCard
            userProfile={userProfile}
            isEditable={true} // Set to true to show the edit button
            onEditPress={openEditModal}
            screenWidth={screenWidth}
          />
        </View>

        {/* ---- My Plants Section ---- */}
        <View style={styles.plantsSectionWrapper}>
          <View style={styles.plantsSectionHeader}>
            <Text style={styles.plantsSectionTitle}>
            {t('profile_my_plants_section')}
            </Text>
            <TouchableOpacity
              onPress={handleAddPlant}
              style={styles.addPlantButton}
              accessibilityRole="button"
              accessibilityLabel={t('profile_add_plant_button')}
            >
              <Ionicons name="add-circle" size={24} color={COLORS.textLight} />
              <Text style={styles.addPlantButtonText}>
                {t('profile_add_plant_button')}
              </Text>
            </TouchableOpacity>
          </View>

          {/* Toggle between Thumbnails and Full view */}
          <ToggleButton
            options={[t('Thumbnails'), t('Full Size')]}
            selected={viewOption}
            onToggle={(option) => setViewOption(option as 'Thumbnails' | 'Full Size')}
          />

          {/* Plants List */}
          {myPlants && myPlants.length > 0 ? (
            <View style={viewOption === 'Full Size' ? styles.fullViewContainer : styles.thumbViewContainer}>
              {myPlants.map((plant) => renderPlantItem(plant))}
            </View>
          ) : (
            <View style={styles.noPlantsContainer}>
              <Text style={styles.noPlantsText}>
                {t('profile_no_plants_message')}
              </Text>
            </View>
          )}
        </View>

        {/* Edit Profile Modal */}
        <EditProfileModal
          visible={editProfileVisible}
          userProfile={userProfile}
          onClose={() => setEditProfileVisible(false)}
          onUpdated={() => {
            refetchProfile();
          }}
          cardLayout={editCardLayout}
        />
      </ScrollView>
    </SafeAreaProvider>
  );
};

export default MyProfileScreen;

// Updated Styles

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    fontSize: 16,
    color: COLORS.textDark,
    marginTop: 10,
  },
  errorText: {
    fontSize: 16,
    color: COLORS.textDark,
    marginBottom: 20,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: COLORS.primary,
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },

  // Profile Card
  cardContainer: {
    marginHorizontal: 16,
    marginTop: 20,
  },

  // ---- Plants Section ----
  plantsSectionWrapper: {
    paddingTop: 20,
    paddingBottom: 15,
  },
  plantsSectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
    paddingHorizontal: 20,
  },
  plantsSectionTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: COLORS.textDark,
  },
  addPlantButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: COLORS.accentGreen, // or any brand color
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 20,
    ...Platform.select({
      ios: {
        shadowColor: "#000",
        shadowOpacity: 0.1,
        shadowOffset: { width: 0, height: 3 },
        shadowRadius: 4,
      },
      android: {
        elevation: 3,
      },
    }),
  },
  addPlantButtonText: {
    color: COLORS.textLight,
    fontSize: 14,
    fontWeight: '600',
    marginLeft: 6,
  },
  // Different layouts for the plant items
  thumbViewContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
  },
  fullViewContainer: {
    width: '100%',
    paddingHorizontal: 20,
  },
  plantCardWrapper: {
    marginBottom: 15,
  },
  noPlantsContainer: {
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  noPlantsText: {
    fontSize: 16,
    color: '#555',
    textAlign: 'center',
  },
});


// File: app\features\main\screens\OtherProfileScreen.tsx
// src/screens/OtherProfileScreen.tsx

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  TouchableOpacity,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { SafeAreaView, SafeAreaProvider } from 'react-native-safe-area-context';
import { useTranslation } from 'react-i18next';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { LinearGradient } from 'expo-linear-gradient';
import * as Location from 'expo-location';

import { PlantCardWithInfo } from '../components/PlantCardWithInfo';
import { useOtherProfile } from '../hooks/useOtherProfile';
import { useMyPlants } from '../hooks/usePlantHooks'; // Assuming you want to show current user's plants related to the other user
import { useSearchRadius } from '../hooks/useSearchRadius';
import { PlantResponse, UserResponse } from '../../../types/apiTypes';
import { COLORS } from '../../../theme/colors';
import PlantThumbnail from '../components/PlantThumbnail';
import { headerStyles } from '../styles/headerStyles';
import { ProfileCard } from '../components/ProfileCard';

// Define navigation parameters
type RootStackParamList = {
  OtherProfile: { userId: number };
};

type OtherProfileScreenRouteProp = RouteProp<RootStackParamList, 'OtherProfile'>;

const OtherProfileScreen: React.FC = () => {
  const { t } = useTranslation();
  const navigation = useNavigation();
  const route = useRoute<OtherProfileScreenRouteProp>();
  const { userId } = route.params;

  // Hooks
  const {
    data: otherUserProfile,
    isLoading: loadingProfile,
    isError: errorProfile,
    refetch: refetchProfile,
  } = useOtherProfile(userId);
  
  // Assuming you want to display plants related to the other user
  // If plants are not user-specific, adjust accordingly
  const {
    data: myPlants,
    isLoading: loadingPlants,
    isError: errorPlants,
    refetch: refetchPlants,
  } = useMyPlants();
  
  const {
    searchRadius,
    isLoading: srLoading,
    isError: srError,
  } = useSearchRadius();

  // For showing city, country
  const [cityCountry, setCityCountry] = useState<string>('');

  // Toggle: Thumbnails or Full-size for plants
  const [showFullSize, setShowFullSize] = useState(false);

  // Position for the EditProfileModal (Not needed for OtherProfileScreen)
  // Removed related states and functions

  // If the user has location
  const userHasLocation =
    otherUserProfile?.locationLatitude !== undefined &&
    otherUserProfile?.locationLongitude !== undefined;

  // Reverse-geocode for city / country
  useEffect(() => {
    (async () => {
      if (userHasLocation) {
        try {
          const [geo] = await Location.reverseGeocodeAsync({
            latitude: otherUserProfile!.locationLatitude!,
            longitude: otherUserProfile!.locationLongitude!,
          });
          if (geo) {
            const city = geo.city || geo.subregion || '';
            const country = geo.country || '';
            setCityCountry(
              city && country ? `${city}, ${country}` : city || country
            );
          }
        } catch (error) {
          console.log('Reverse geocoding error:', error);
          setCityCountry('');
        }
      } else {
        setCityCountry('');
      }
    })();
  }, [userHasLocation, otherUserProfile]);

  // Handler for sending message to the user
  const handleSendMessage = () => {
    navigation.navigate('Chat' as never, { otherUserId: userId } as never);
  };

  // Rendering plants
  const renderPlantItem = (item: PlantResponse) => {
    if (!showFullSize) {
      return (
        <PlantThumbnail
          key={item.plantId}
          plant={item}
          // Assuming these props are not needed for viewing others' plants
          // Remove or adjust if necessary
        />
      );
    } else {
      return (
        <View key={item.plantId} style={styles.plantCardWrapper}>
          <PlantCardWithInfo plant={item} />
        </View>
      );
    }
  };

  // Loading states
  if (loadingProfile || loadingPlants || srLoading) {
    return (
      <SafeAreaView style={styles.centerContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
        <Text style={styles.loadingText}>{t('profile_loading_message')}</Text>
      </SafeAreaView>
    );
  }

  if (errorProfile || errorPlants || srError) {
    return (
      <SafeAreaView style={styles.centerContainer}>
        <Text style={styles.errorText}>{t('profile_error_message')}</Text>
        <TouchableOpacity
          onPress={() => {
            refetchProfile();
            refetchPlants();
          }}
          style={styles.retryButton}
        >
          <Text style={styles.retryButtonText}>{t('profile_retry_button')}</Text>
        </TouchableOpacity>
      </SafeAreaView>
    );
  }

  if (!otherUserProfile) {
    return (
      <SafeAreaView style={styles.centerContainer}>
        <Text style={styles.errorText}>{t('profile_no_user_profile_error')}</Text>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaProvider style={styles.container}>
      <ScrollView style={{ flex: 1 }}>
        {/* Header */}
        <LinearGradient
          colors={[COLORS.primary, COLORS.secondary]}
          style={headerStyles.headerGradient}
        >
          <View style={headerStyles.headerColumn1}>
            <TouchableOpacity
              style={headerStyles.headerBackButton}
              onPress={() => navigation.goBack()}
            >
              <Ionicons name="chevron-back" size={30} color={COLORS.textLight} />
            </TouchableOpacity>
            <View style={styles.headerUserInfo}>
              <Ionicons name="person-circle-outline" size={30} color={COLORS.textLight} />
              <Text style={headerStyles.headerTitle}>{t('profile_title')}</Text>
            </View>
          </View>
        </LinearGradient>

        {/* --- Profile Card --- */}
        <View style={styles.cardContainer}>
          <ProfileCard
            userProfile={otherUserProfile}
            // No edit functionality
            isEditable={false}
          />
        </View>

        {/* ---- User's Plants Section ---- */}
        <View style={styles.plantsSectionWrapper}>
          <View style={styles.plantsSectionHeader}>
            <Text style={styles.plantsSectionTitle}>
              {otherUserProfile.name} {t('profile_my_plants_section')}
            </Text>
            {/* If you want to allow interaction like sending a message */}
            <TouchableOpacity
              onPress={handleSendMessage}
              style={styles.addPlantButton} // Reuse styles or create new ones
              accessibilityRole="button"
              accessibilityLabel={t('profile_send_message_button')}
            >
              <Ionicons name="chatbubble-ellipses" size={24} color={COLORS.textLight} />
              <Text style={styles.addPlantButtonText}>
                {t('profile_send_message_button')}
              </Text>
            </TouchableOpacity>
          </View>

          {/* Toggle between Thumbnails and Full view */}
          <View style={styles.viewToggleRow}>
            <TouchableOpacity
              onPress={() => setShowFullSize(false)}
              style={[
                styles.segmentButton,
                !showFullSize && styles.segmentButtonActive,
              ]}
            >
              <Text
                style={[
                  styles.segmentButtonText,
                  !showFullSize && styles.segmentButtonTextActive,
                ]}
              >
                {t('Thumbnails')}
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              onPress={() => setShowFullSize(true)}
              style={[
                styles.segmentButton,
                showFullSize && styles.segmentButtonActive,
              ]}
            >
              <Text
                style={[
                  styles.segmentButtonText,
                  showFullSize && styles.segmentButtonTextActive,
                ]}
              >
                {t('Full Size')}
              </Text>
            </TouchableOpacity>
          </View>

          {/* Plants List */}
          {myPlants && myPlants.length > 0 ? (
            <View style={showFullSize ? styles.fullViewContainer : styles.thumbViewContainer}>
              {myPlants.map((plant) => renderPlantItem(plant))}
            </View>
          ) : (
            <View style={styles.noPlantsContainer}>
              <Text style={styles.noPlantsText}>
                {t('profile_no_plants_message')}
              </Text>
            </View>
          )}
        </View>

        {/* Additional Actions (e.g., Follow Button) */}
        <View style={styles.actionsContainer}>
          {/* Example: Follow Button */}
          <TouchableOpacity style={styles.followButton} onPress={() => Alert.alert('Followed!')}>
            <Text style={styles.followButtonText}>{t('profile_follow_button')}</Text>
          </TouchableOpacity>
          {/* Add more actions as needed */}
        </View>
      </ScrollView>
    </SafeAreaProvider>
  );
};

export default OtherProfileScreen;

// Styles
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    fontSize: 16,
    color: COLORS.textDark,
    marginTop: 10,
  },
  errorText: {
    fontSize: 16,
    color: COLORS.textDark,
    marginBottom: 20,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: COLORS.primary,
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },

  // Profile Card
  cardContainer: {
    marginHorizontal: 16,
    marginTop: 20,
  },

  // ---- Plants Section ----
  plantsSectionWrapper: {
    paddingTop: 20,
    paddingBottom: 15,
  },
  plantsSectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
    paddingHorizontal: 20,
  },
  plantsSectionTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: COLORS.textDark,
  },
  addPlantButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: COLORS.accentGreen, // or any brand color
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 20,
    ...Platform.select({
      ios: {
        shadowColor: "#000",
        shadowOpacity: 0.1,
        shadowOffset: { width: 0, height: 3 },
        shadowRadius: 4,
      },
      android: {
        elevation: 3,
      },
    }),
  },
  addPlantButtonText: {
    color: COLORS.textLight,
    fontSize: 14,
    fontWeight: '600',
    marginLeft: 6,
  },

  // Toggle for Thumbnails / Full
  viewToggleRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: COLORS.textLight,
    borderRadius: 20,
    alignSelf: 'center',
    padding: 3,
    marginBottom: 15,
  },
  segmentButton: {
    paddingHorizontal: 20,
    paddingVertical: 8,
    borderRadius: 18,
  },
  segmentButtonActive: {
    backgroundColor: COLORS.accentGreen,
  },
  segmentButtonText: {
    fontSize: 14,
    fontWeight: '600',
    color: COLORS.textDark,
  },
  segmentButtonTextActive: {
    color: COLORS.textLight,
  },

  // Different layouts for the plant items
  thumbViewContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
  },
  fullViewContainer: {
    width: '100%',
    paddingHorizontal: 20,
  },
  plantCardWrapper: {
    marginBottom: 15,
  },
  noPlantsContainer: {
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  noPlantsText: {
    fontSize: 16,
    color: '#555',
    textAlign: 'center',
  },

  // Header User Info
  headerUserInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginLeft: 10, // Adjust as needed
  },
  headerUserImage: {
    borderColor: COLORS.accentGreen,
    borderWidth: 3,
    width: 60,
    height: 60,
    borderRadius: 30,
    marginRight: 8,
    backgroundColor: '#ccc', // Placeholder color in case image fails to load
  },

  // Actions Container
  actionsContainer: {
    paddingHorizontal: 20,
    paddingVertical: 10,
    alignItems: 'center',
  },
  followButton: {
    backgroundColor: COLORS.accentGreen,
    paddingVertical: 12,
    paddingHorizontal: 30,
    borderRadius: 25,
    marginBottom: 10,
    width: '100%',
    alignItems: 'center',
  },
  followButtonText: {
    color: COLORS.textLight,
    fontSize: 16,
    fontWeight: '600',
  },
});


// File: app\features\main\screens\SettingsScreen.tsx
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Switch,
  ScrollView,
  Alert,
  ActivityIndicator,
  TextInput,
  Keyboard,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons, MaterialIcons } from '@expo/vector-icons';
import { useTranslation } from 'react-i18next';

import { SafeAreaProvider } from 'react-native-safe-area-context';
import { storage } from '../../../utils/storage';
import { userService } from '../../../api/userService';
import { useMyProfile } from '../hooks/useMyProfileHooks';
import { useNavigation } from '@react-navigation/native';
import { logout } from '../../auth/store/authSlice';
import { store } from '../../../store';
import { COLORS } from '../../../theme/colors';
import { headerStyles } from '../styles/headerStyles';
import { authService } from '../../../api/authService';
import { useQueryClient } from 'react-query';

const SettingsScreen: React.FC = () => {
  const { t, i18n } = useTranslation();
  const navigation = useNavigation();
  const queryClient = useQueryClient();

  // For user data
  const {
    data: userProfile,
    isLoading: userLoading,
    refetch: refetchUserProfile,
  } = useMyProfile();

  // Language management
  const [currentLang, setCurrentLang] = useState(i18n.language);

  // Toggles
  const [pushNotificationsEnabled, setPushNotificationsEnabled] = useState(false);
  const [darkModeEnabled, setDarkModeEnabled] = useState(false);

  // Edit states for email/password
  const [isEditingEmail, setIsEditingEmail] = useState(false);
  const [isEditingPassword, setIsEditingPassword] = useState(false);

  // Local states for new email/password input
  const [newEmail, setNewEmail] = useState('');
  const [newPassword, setNewPassword] = useState('');

  // "Saving" spinner
  const [saving, setSaving] = useState(false);

  // Handle language change
  const handleLanguageChange = async (lang: string) => {
    await i18n.changeLanguage(lang);
    await storage.saveLanguage(lang);
    setCurrentLang(lang);
  };

  // Stub for changing email
  const handleChangeEmail = async () => {
    if (!newEmail.trim()) {
      Alert.alert('Validation Error', t('Please enter a valid email.'));
      return;
    }
    setSaving(true);
    Keyboard.dismiss();
    try {
      // Example: await userService.updateProfile({ email: newEmail });
      Alert.alert(t('Success'), t('Email changed successfully!'));
      setNewEmail('');
      refetchUserProfile();
      setIsEditingEmail(false);
    } catch (err) {
      console.error('Failed to change email:', err);
      Alert.alert(t('Error'), t('Could not change email.'));
    } finally {
      setSaving(false);
    }
  };

  // Stub for changing password
  const handleChangePassword = async () => {
    if (!newPassword.trim()) {
      Alert.alert('Validation Error', t('Please enter a valid password.'));
      return;
    }
    setSaving(true);
    Keyboard.dismiss();
    try {
      // Example: await userService.updateProfile({ password: newPassword });
      Alert.alert(t('Success'), t('Password changed successfully!'));
      setNewPassword('');
      refetchUserProfile();
      setIsEditingPassword(false);
    } catch (err) {
      console.error('Failed to change password:', err);
      Alert.alert(t('Error'), t('Could not change password.'));
    } finally {
      setSaving(false);
    }
  };

  // Logout
  const handleLogout = async () => {
    Alert.alert(
      t('Logout'),
      t('Are you sure you want to log out?'),
      [
        { text: t('Cancel'), style: 'cancel' },
        {
          text: t('Yes'),
          style: 'destructive',
          onPress: async () => {
            queryClient.clear();
            await storage.clearTokens();
            authService.logout();
            store.dispatch(logout());
          },
        },
      ],
    );
  };

  // Delete account
  const handleDeleteAccount = async () => {
    Alert.alert(
      t('Delete Account'),
      t('Not implemented yet.'),
      [
        { text: t('Cancel'), style: 'cancel' },
        {
          // text: t('Yes, Delete'),
          // style: 'destructive',
          // onPress: async () => {
          //   try {
              
          //   } catch (err) {
          //     console.error('Failed to delete account:', err);
          //     Alert.alert(t('Error'), t('Could not delete account.'));
          //   }
          // },
        },
      ],
    );
  };

  // Not implemented yet
  const handleNotImplemented = () => {
    Alert.alert(t('Not Implemented'), t('This feature is not implemented yet.'));
  };

  // Save toggles
  const handleSaveNotificationSettings = async (value: boolean) => {
    handleNotImplemented(); 
    // e.g. userPreferencesService.updateNotifications(value);
  };

  const handleSaveDarkMode = async (value: boolean) => {
    handleNotImplemented();
    // e.g. userPreferencesService.updateDarkMode(value);
  };

  if (userLoading) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" color={COLORS.primary} />
      </View>
    );
  }

  // RENDER ROWS

  // Email Row
  const renderEmailRow = () => {
    if (!isEditingEmail) {
      // Display mode
      return (
        <View style={styles.row}>
          <View style={styles.rowLeft}>
            <Text style={styles.rowLabel}>{t('email')}</Text>
            <Text style={styles.rowValue}>
              {userProfile?.email || t('No email found')}
            </Text>
          </View>

          {/* Edit icon to start editing */}
          {/* <TouchableOpacity
            onPress={() => {
              setIsEditingEmail(true);
              setNewEmail(userProfile?.email || '');
            }}
          >
            <Ionicons name="pencil-outline" size={18} color={COLORS.accentGreen} />
          </TouchableOpacity> */}
        </View>
      );
    }

    // Edit mode
    return (
      <View style={styles.row}>
        <View style={{ flex: 1 }}>
          <Text style={styles.rowLabel}>{t('Edit Email')}</Text>
          <TextInput
            style={styles.editInput}
            value={newEmail}
            onChangeText={setNewEmail}
            autoCapitalize="none"
            keyboardType="email-address"
          />
        </View>

        <View style={styles.rowActions}>
          {/* Confirm */}
          <TouchableOpacity
            onPress={handleChangeEmail}
            style={{ marginRight: 12 }}
            disabled={saving}
          >
            {saving ? (
              <ActivityIndicator size="small" color={COLORS.accentGreen} />
            ) : (
              <Ionicons name="checkmark-circle" size={24} color={COLORS.accentGreen} />
            )}
          </TouchableOpacity>
          {/* Cancel */}
          <TouchableOpacity
            onPress={() => {
              setIsEditingEmail(false);
              setNewEmail('');
            }}
          >
            <Ionicons name="close-circle" size={24} color={COLORS.accentRed} />
          </TouchableOpacity>
        </View>
      </View>
    );
  };

  // Password Row
  const renderPasswordRow = () => {
    if (!isEditingPassword) {
      // Display mode
      return (
        <View style={styles.row}>
          <View style={styles.rowLeft}>
            <Text style={styles.rowLabel}>{t('Password')}</Text>
            <Text style={styles.rowValue}>********</Text>
          </View>

          {/* Edit icon to start editing password */}
          <TouchableOpacity
            onPress={() => {
              setIsEditingPassword(true);
              setNewPassword('');
            }}
          >
            <Ionicons name="pencil-outline" size={18} color={COLORS.accentGreen} />
          </TouchableOpacity>
        </View>
      );
    }

    // Edit mode
    return (
      <View style={styles.row}>
        <View style={{ flex: 1 }}>
          <Text style={styles.rowLabel}>{t('New Password')}</Text>
          <TextInput
            style={styles.editInput}
            value={newPassword}
            onChangeText={setNewPassword}
            secureTextEntry
            autoCapitalize="none"
          />
        </View>

        <View style={styles.rowActions}>
          {/* Confirm */}
          <TouchableOpacity
            onPress={handleChangePassword}
            style={{ marginRight: 12 }}
            disabled={saving}
          >
            {saving ? (
              <ActivityIndicator size="small" color={COLORS.accentGreen} />
            ) : (
              <Ionicons name="checkmark-circle" size={24} color={COLORS.accentGreen} />
            )}
          </TouchableOpacity>
          {/* Cancel */}
          <TouchableOpacity
            onPress={() => {
              setIsEditingPassword(false);
              setNewPassword('');
            }}
          >
            <Ionicons name="close-circle" size={24} color={COLORS.accentRed} />
          </TouchableOpacity>
        </View>
      </View>
    );
  };

  return (
    <SafeAreaProvider style={styles.safeArea}>
      {/* Header */}
      <LinearGradient
        colors={[COLORS.primary, COLORS.secondary]}
        style={headerStyles.headerGradient}
      >
        <View style={headerStyles.headerRow}>
          <Text style={headerStyles.headerTitle}>{t('Settings')}</Text>
          <MaterialIcons name="settings" size={24} color="#fff" />
        </View>
      </LinearGradient>

      {/* Content */}
      <ScrollView contentContainerStyle={styles.scrollContent}>

        {/* ACCOUNT INFO SECTION */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{t('Account')}</Text>
          {renderEmailRow()}
          {/* {renderPasswordRow()} */}

          {/* Logout */}
          <TouchableOpacity
            style={styles.logoutButton}
            onPress={handleLogout}
          >
            <Ionicons name="log-out-outline" size={18} color="#fff" />
            <Text style={styles.logoutButtonText}>{t('Log Out')}</Text>
          </TouchableOpacity>

          {/* Delete Account */}
          <TouchableOpacity
            style={styles.deleteButton}
            onPress={handleDeleteAccount}
          >
            <Ionicons name="trash-outline" size={18} color="#fff" />
            <Text style={styles.deleteButtonText}>{t('Delete Account')}</Text>
          </TouchableOpacity>
        </View>

        {/* LANGUAGE SECTION */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{t('Language')}</Text>
          <View style={styles.langButtons}>
            <TouchableOpacity
              onPress={() => handleLanguageChange('en')}
              style={[
                styles.langButton,
                currentLang === 'en' && styles.langButtonSelected,
              ]}
            >
              <Text
                style={[
                  styles.langButtonText,
                  currentLang === 'en' && styles.langButtonTextSelected,
                ]}
              >
                English
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              onPress={() => handleLanguageChange('fr')}
              style={[
                styles.langButton,
                currentLang === 'fr' && styles.langButtonSelected,
              ]}
            >
              <Text
                style={[
                  styles.langButtonText,
                  currentLang === 'fr' && styles.langButtonTextSelected,
                ]}
              >
                Français
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* NOTIFICATIONS SECTION */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{t('Notifications')}</Text>
          <View style={styles.toggleRow}>
            <Text style={styles.toggleLabel}>{t('Push Notifications')}</Text>
            <Switch
              value={pushNotificationsEnabled}
              onValueChange={(val) => {
                setPushNotificationsEnabled(val);
                handleSaveNotificationSettings(val);
              }}
              thumbColor={pushNotificationsEnabled ? COLORS.accentGreen : '#ccc'}
              trackColor={{ true: COLORS.primary, false: '#ddd' }}
            />
          </View>
        </View>

        {/* DISPLAY / THEME SECTION */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{t('Appearance')}</Text>
          <View style={styles.toggleRow}>
            <Text style={styles.toggleLabel}>{t('Dark Mode')}</Text>
            <Switch
              value={darkModeEnabled}
              onValueChange={(val) => {
                setDarkModeEnabled(val);
                handleSaveDarkMode(val);
              }}
              thumbColor={darkModeEnabled ? COLORS.accentGreen : '#ccc'}
              trackColor={{ true: COLORS.primary, false: '#ddd' }}
            />
          </View>
        </View>

        <View style={{ height: 40 }} />
      </ScrollView>
    </SafeAreaProvider>
  );
};

export default SettingsScreen;

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  scrollContent: {
    paddingBottom: 40,
    paddingHorizontal: 20,
  },
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },

  /* Sections */
  section: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
  },
  sectionTitle: {
    fontSize: 18,
    color: COLORS.textDark,
    fontWeight: '600',
    marginBottom: 10,
  },

  /* Row for email, password, etc. */
  row: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  rowLeft: {
    flex: 1,

  },
  rowLabel: {
    fontSize: 14,
    color: COLORS.textDark,
    fontWeight: '600',
    marginBottom: 2,
  },
  rowValue: {
    fontSize: 14,
    color: '#555',
  },
  rowActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  editInput: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 6,
    fontSize: 14,
    marginTop: 6,
  },

  /* Logout + Delete buttons */
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: COLORS.accentGreen,
    borderRadius: 8,
    paddingVertical: 8,
    paddingHorizontal: 12,
    marginTop: 12,
  },
  logoutButtonText: {
    marginLeft: 6,
    fontSize: 14,
    color: '#fff',
    fontWeight: '600',
  },
  deleteButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: COLORS.accentRed,
    borderRadius: 8,
    paddingVertical: 8,
    paddingHorizontal: 12,
    marginTop: 12,
  },
  deleteButtonText: {
    marginLeft: 6,
    fontSize: 14,
    color: '#fff',
    fontWeight: '600',
  },

  /* Language */
  label: {
    fontSize: 14,
    color: COLORS.textDark,
    fontWeight: '600',
    marginBottom: 4,
  },
  langButtons: {
    flexDirection: 'row',
    marginTop: 8,
  },
  langButton: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderWidth: 1,
    borderColor: COLORS.accentGreen,
    borderRadius: 20,
    marginRight: 10,
  },
  langButtonSelected: {
    backgroundColor: COLORS.accentGreen,
  },
  langButtonText: {
    fontSize: 14,
    color: COLORS.accentGreen,
  },
  langButtonTextSelected: {
    color: COLORS.textLight,
    fontWeight: '600',
  },

  /* Notifications / Appearance toggles */
  toggleRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginVertical: 8,
  },
  toggleLabel: {
    fontSize: 14,
    color: COLORS.textDark,
  },
});


// File: app\features\main\screens\SetUserPreferencesScreen.tsx
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  Platform,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { MaterialIcons, Ionicons } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native';
import { useUserPreferences } from '../hooks/usePreferences';
import Slider from '@react-native-community/slider'; // <-- Import Slider

import TagGroup from '../components/TagGroup';
import { COLORS } from '../../../theme/colors';
import { headerStyles } from '../styles/headerStyles';
import ConfirmCancelButtons from '../components/ConfirmCancelButtons';

import {
  PlantStage,
  PlantCategory,
  WateringNeed,
  LightRequirement,
  Size,
  IndoorOutdoor,
  PropagationEase,
  PetFriendly,
  Extras,
} from '../../../types/enums';
import { UserPreferencesRequest } from '../../../types/apiTypes';

const SetUserPreferencesScreen: React.FC = () => {
  const navigation = useNavigation();
  const {
    data: preferences,
    isLoading,
    isError,
    updatePreferences,
    isUpdating,
  } = useUserPreferences();

  // Local states for each preference
  const [searchRadius, setSearchRadius] = useState<number>(10);
  const [selectedStages, setSelectedStages] = useState<PlantStage[]>([]);
  const [selectedCategories, setSelectedCategories] = useState<PlantCategory[]>([]);
  const [selectedWatering, setSelectedWatering] = useState<WateringNeed[]>([]);
  const [selectedLightReq, setSelectedLightReq] = useState<LightRequirement[]>([]);
  const [selectedSize, setSelectedSize] = useState<Size[]>([]);
  const [selectedIndoorOutdoor, setSelectedIndoorOutdoor] = useState<IndoorOutdoor[]>([]);
  const [selectedPropagationEase, setSelectedPropagationEase] = useState<PropagationEase[]>([]);
  const [selectedPetFriendly, setSelectedPetFriendly] = useState<PetFriendly[]>([]);
  const [selectedExtras, setSelectedExtras] = useState<Extras[]>([]);
  const [error, setError] = useState<string | null>(null);

  // Load existing preferences on mount (or when preferences update)
  useEffect(() => {
    if (preferences) {
      setSearchRadius(preferences.searchRadius ?? 10);
      setSelectedStages(preferences.preferedPlantStage || []);
      setSelectedCategories(preferences.preferedPlantCategory || []);
      setSelectedWatering(preferences.preferedWateringNeed || []);
      setSelectedLightReq(preferences.preferedLightRequirement || []);
      setSelectedSize(preferences.preferedSize || []);
      setSelectedIndoorOutdoor(preferences.preferedIndoorOutdoor || []);
      setSelectedPropagationEase(preferences.preferedPropagationEase || []);
      setSelectedPetFriendly(preferences.preferedPetFriendly || []);
      setSelectedExtras(preferences.preferedExtras || []);
    }
  }, [preferences]);

  const handleSetSearchRadius = (val: number) => { 
    if (val === 500) setSearchRadius(40000);
    else setSearchRadius(val);
    }

  const handleCancel = () => {
    navigation.goBack();
  };

  const handleSave = async () => {
    if (!preferences) return;
    setError(null);

    const updated: UserPreferencesRequest = {
      ...preferences,
      searchRadius,
      preferedPlantStage: selectedStages,
      preferedPlantCategory: selectedCategories,
      preferedWateringNeed: selectedWatering,
      preferedLightRequirement: selectedLightReq,
      preferedSize: selectedSize,
      preferedIndoorOutdoor: selectedIndoorOutdoor,
      preferedPropagationEase: selectedPropagationEase,
      preferedPetFriendly: selectedPetFriendly,
      preferedExtras: selectedExtras,
    };

    try {
      await updatePreferences(updated);
      navigation.goBack();
    } catch (err) {
      console.error('Error updating preferences:', err);
      setError('Could not update preferences.');
    }
  };

  if (isLoading) {
    return (
      <View style={styles.center}>
        <Text>Loading preferences...</Text>
      </View>
    );
  }

  if (isError || !preferences) {
    return (
      <View style={styles.center}>
        <Text>Error loading preferences</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <LinearGradient
        colors={[COLORS.primary, COLORS.secondary]}
        style={styles.gradientBackground}
      >
        <View style={headerStyles.headerAboveScroll}>
          <View style={headerStyles.headerColumn1}>
            <Ionicons
              name="chevron-back"
              size={30}
              color={COLORS.textLight}
              style={headerStyles.headerBackButton}
              onPress={() => navigation.goBack()}
            />
            <Text style={headerStyles.headerTitle}>User Preferences</Text>
          </View>
          <MaterialIcons name="settings" size={24} color="#fff" />
        </View>

        <ScrollView
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={false}
        >
          <View style={styles.formContainer}>
            {error && <Text style={styles.errorText}>{error}</Text>}

            {/* Slider for Search Radius */}
            <Text style={styles.label}>Search Radius: {searchRadius} km</Text>
            <Slider
              style={styles.slider}
              minimumValue={1}
              maximumValue={500}
              step={1}
              value={searchRadius}
              onSlidingComplete={(val) => handleSetSearchRadius(val)}
              minimumTrackTintColor={COLORS.accentGreen}
              maximumTrackTintColor="#999"
              trackStyle={{ borderRadius: 10 }}
              thumbTintColor={COLORS.accentGreen}
            />

            <Text style={styles.label}>Preferred Plant Stages:</Text>
            <TagGroup
              mode="multiple"
              values={Object.values(PlantStage)}
              selectedValues={selectedStages}
              onToggleMulti={(val) =>
                setSelectedStages((prev) =>
                  prev.includes(val)
                    ? prev.filter((v) => v !== val)
                    : [...prev, val]
                )
              }
            />

            <Text style={styles.label}>Preferred Categories:</Text>
            <TagGroup
              mode="multiple"
              values={Object.values(PlantCategory)}
              selectedValues={selectedCategories}
              onToggleMulti={(val) =>
                setSelectedCategories((prev) =>
                  prev.includes(val)
                    ? prev.filter((v) => v !== val)
                    : [...prev, val]
                )
              }
            />

            <Text style={styles.label}>Watering Need:</Text>
            <TagGroup
              mode="multiple"
              values={Object.values(WateringNeed)}
              selectedValues={selectedWatering}
              onToggleMulti={(val) =>
                setSelectedWatering((prev) =>
                  prev.includes(val)
                    ? prev.filter((v) => v !== val)
                    : [...prev, val]
                )
              }
            />

            <Text style={styles.label}>Light Requirement:</Text>
            <TagGroup
              mode="multiple"
              values={Object.values(LightRequirement)}
              selectedValues={selectedLightReq}
              onToggleMulti={(val) =>
                setSelectedLightReq((prev) =>
                  prev.includes(val)
                    ? prev.filter((v) => v !== val)
                    : [...prev, val]
                )
              }
            />

            <Text style={styles.label}>Size:</Text>
            <TagGroup
              mode="multiple"
              values={Object.values(Size)}
              selectedValues={selectedSize}
              onToggleMulti={(val) =>
                setSelectedSize((prev) =>
                  prev.includes(val)
                    ? prev.filter((v) => v !== val)
                    : [...prev, val]
                )
              }
            />

            <Text style={styles.label}>Indoor/Outdoor:</Text>
            <TagGroup
              mode="multiple"
              values={Object.values(IndoorOutdoor)}
              selectedValues={selectedIndoorOutdoor}
              onToggleMulti={(val) =>
                setSelectedIndoorOutdoor((prev) =>
                  prev.includes(val)
                    ? prev.filter((v) => v !== val)
                    : [...prev, val]
                )
              }
            />

            <Text style={styles.label}>Propagation Ease:</Text>
            <TagGroup
              mode="multiple"
              values={Object.values(PropagationEase)}
              selectedValues={selectedPropagationEase}
              onToggleMulti={(val) =>
                setSelectedPropagationEase((prev) =>
                  prev.includes(val)
                    ? prev.filter((v) => v !== val)
                    : [...prev, val]
                )
              }
            />

            <Text style={styles.label}>Pet Friendly:</Text>
            <TagGroup
              mode="multiple"
              values={Object.values(PetFriendly)}
              selectedValues={selectedPetFriendly}
              onToggleMulti={(val) =>
                setSelectedPetFriendly((prev) =>
                  prev.includes(val)
                    ? prev.filter((v) => v !== val)
                    : [...prev, val]
                )
              }
            />

            <Text style={styles.label}>Extras:</Text>
            <TagGroup
              mode="multiple"
              values={Object.values(Extras)}
              selectedValues={selectedExtras}
              onToggleMulti={(val) =>
                setSelectedExtras((prev) =>
                  prev.includes(val)
                    ? prev.filter((v) => v !== val)
                    : [...prev, val]
                )
              }
            />

            <ConfirmCancelButtons
              onConfirm={handleSave}
              confirmButtonText="Save"
              onCancel={handleCancel}
              cancelButtonText="Cancel"
              loading={isUpdating}
            />
          </View>
        </ScrollView>
      </LinearGradient>
    </View>
  );
};

export default SetUserPreferencesScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  gradientBackground: {
    flex: 1,
  },
  scrollContent: {
    paddingTop: 0,
    paddingBottom: 30,
  },
  formContainer: {
    backgroundColor: '#fff',
    marginHorizontal: 20,
    borderRadius: 12,
    padding: 16,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOpacity: 0.1,
        shadowRadius: 5,
        shadowOffset: { width: 0, height: 4 },
      },
      android: {
        elevation: 3,
      },
    }),
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginTop: 12,
    marginBottom: 6,
  },
  slider: {
    width: '100%',
    height: 40,
  },
  errorText: {
    color: '#FF6F61',
    marginBottom: 10,
    fontWeight: '600',
  },
  center: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});


// File: app\features\main\screens\SwipeScreen.tsx
import React, { useCallback, useEffect, useRef, useState } from 'react';
import {
  StyleSheet,
  View,
  Text,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  Dimensions,
  Platform,
  FlatList,
} from 'react-native';
import { Ionicons, MaterialIcons } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native';
import { LinearGradient } from 'expo-linear-gradient';
import { SafeAreaProvider } from 'react-native-safe-area-context';

// --- Hooks ---
import { useLikablePlants } from '../hooks/useSwipe';
import { useMyProfile } from '../hooks/useMyProfileHooks';
import { useUserPreferences } from '../hooks/usePreferences';
import { useMyPlants } from '../hooks/usePlantHooks';

// --- Components & Services ---
import { SwipeableCard, SwipeableCardRef } from '../components/SwipeableCard';
import { SelectPlantsModal } from '../modals/SelectPlantsModal';
import ItsAMatchModal from '../modals/ItsAMatchModal';

// --- Types & Utils ---
import { PlantResponse, SwipeRequest } from '../../../types/apiTypes';
import { log } from '../../../utils/logger';
import { COLORS } from '../../../theme/colors';
import { headerStyles } from '../styles/headerStyles';

const { width } = Dimensions.get('window');

interface SwipeScreenProps { }

const SwipeScreen: React.FC<SwipeScreenProps> = () => {
  const navigation = useNavigation();

  // Data hooks
  const {
    data: likablePlants,
    isLoading: loadingPlants,
    isError: errorPlants,
    refetch: refetchLikablePlants,
    sendSwipes,
    isSending: sendingSwipes,
    matches,
    clearMatches,
  } = useLikablePlants();

  const { data: userProfile } = useMyProfile();
  const {
    data: userPreferences,
    updatePreferences,
  } = useUserPreferences();

  const {
    data: myPlants,
    isLoading: loadingMyPlants,
    isError: errorMyPlants,
    refetch: refetchMyPlants,
  } = useMyPlants();

  // The main card stack
  const [plantStack, setPlantStack] = useState<PlantResponse[]>([]);

  // Modal / "like" flow
  const [showSelectModal, setShowSelectModal] = useState(false);
  const [plantToLike, setPlantToLike] = useState<PlantResponse | null>(null);

  // Reference to the top card so we can reset or finalize the right-swipe
  const topCardRef = useRef<SwipeableCardRef>(null);

  // Initialize stack on fetch
  useEffect(() => {
    if (likablePlants) {
      log.debug('Likable plants fetched:', likablePlants);
      setPlantStack(likablePlants);
    }
  }, [likablePlants]);

  // ----- Navigation: Filter Button -----
  const handleFilterPress = useCallback(() => {
    navigation.navigate('SetUserPreferences' as never);
  }, [navigation]);

  // ----- Single Preference Removal -----
  const handleRemoveSinglePreference = useCallback(
    async (tagKey: string, valueToRemove: string) => {
      if (!userPreferences) return;
      const updatedPrefs = { ...userPreferences };

      switch (tagKey) {
        case 'Stage':
          updatedPrefs.preferedPlantStage = userPreferences.preferedPlantStage.filter(
            (val) => val !== valueToRemove
          );
          break;
        case 'Category':
          updatedPrefs.preferedPlantCategory = userPreferences.preferedPlantCategory.filter(
            (val) => val !== valueToRemove
          );
          break;
        case 'Light':
          updatedPrefs.preferedLightRequirement = userPreferences.preferedLightRequirement.filter(
            (val) => val !== valueToRemove
          );
          break;
        case 'Water':
          updatedPrefs.preferedWateringNeed = userPreferences.preferedWateringNeed.filter(
            (val) => val !== valueToRemove
          );
          break;
        case 'Size':
          updatedPrefs.preferedSize = userPreferences.preferedSize.filter(
            (val) => val !== valueToRemove
          );
          break;
        case 'IndoorOutdoor':
          updatedPrefs.preferedIndoorOutdoor = userPreferences.preferedIndoorOutdoor.filter(
            (val) => val !== valueToRemove
          );
          break;
        case 'PropagationEase':
          updatedPrefs.preferedPropagationEase = userPreferences.preferedPropagationEase.filter(
            (val) => val !== valueToRemove
          );
          break;
        case 'PetFriendly':
          updatedPrefs.preferedPetFriendly = userPreferences.preferedPetFriendly.filter(
            (val) => val !== valueToRemove
          );
          break;
        case 'Extras':
          updatedPrefs.preferedExtras = userPreferences.preferedExtras.filter(
            (val) => val !== valueToRemove
          );
          break;
        default:
          break;
      }

      try {
        await updatePreferences(updatedPrefs);
      } catch (err) {
        Alert.alert('Error', 'Could not remove preference.');
      }
    },
    [userPreferences, updatePreferences]
  );

  // ----- SWIPE ACTIONS -----

  /**
   * Dislike / Swipe Left: immediately removes the top card.
   */
  const handleDislike = (plantId: number) => {
    setPlantStack((prev) => prev.slice(1));
    if (!myPlants) return;
    const topCard = likablePlants?.find((p) => p.plantId === plantId);
    if (!topCard) return;

    const requests: SwipeRequest[] = myPlants.map((myPlant) => ({
      swiperPlantId: myPlant.plantId,
      swipedPlantId: topCard.plantId,
      isLike: false,
    }));

    sendSwipes(requests, {
      onError: () => {
        Alert.alert('Error', 'Failed to send swipes.');
      },
    });
  };

  /**
   * Called after the card animates off screen.
   */
  const handleSwipeRight = (plantId: number) => {
    setPlantStack((prev) => prev.slice(1));
    // The like request is sent in handleSelectConfirm.
  };

  /**
   * Begins the like gesture by opening the select modal.
   */
  const handleLikeGestureBegin = (plant: PlantResponse) => {
    setPlantToLike(plant);
    setShowSelectModal(true);
  };

  /**
   * When the user confirms the selection, sends the like request.
   */
  const handleSelectConfirm = (selectedMyPlantIds: number[]) => {
    if (!plantToLike || !myPlants) return;
    const requests: SwipeRequest[] = myPlants.map((mp) => ({
      swiperPlantId: mp.plantId,
      swipedPlantId: plantToLike.plantId,
      isLike: selectedMyPlantIds.includes(mp.plantId),
    }));

    sendSwipes(requests, {
      onSuccess: () => {
        topCardRef.current?.flyOffRight();
      },
      onError: () => {
        Alert.alert('Error', 'Failed to send swipes.');
      },
      onSettled: () => {
        setShowSelectModal(false);
        setPlantToLike(null);
      },
    });
  };

  /**
   * Cancels the selection and resets the card position.
   */
  const handleSelectCancel = () => {
    topCardRef.current?.resetPosition();
    setShowSelectModal(false);
    setPlantToLike(null);
  };

  // ----- Bottom Action Buttons -----
  const handlePassPress = () => {
    if (!plantStack.length) return;
    const topCard = plantStack[0];
    handleDislike(topCard.plantId);
  };

  const handleLikePress = () => {
    if (!plantStack.length) return;
    const topCard = plantStack[0];
    topCardRef.current?.resetPosition();
    setTimeout(() => {
      handleLikeGestureBegin(topCard);
    }, 10);
  };

  // ----- Header with Filters -----
  const renderHeader = () => {
    const prefTags: Array<{ key: string; value: string }> = [];
    if (userPreferences) {
      userPreferences.preferedPlantStage?.forEach((val) =>
        prefTags.push({ key: 'Stage', value: val })
      );
      userPreferences.preferedPlantCategory?.forEach((val) =>
        prefTags.push({ key: 'Category', value: val })
      );
      userPreferences.preferedLightRequirement?.forEach((val) =>
        prefTags.push({ key: 'Light', value: val })
      );
      userPreferences.preferedWateringNeed?.forEach((val) =>
        prefTags.push({ key: 'Water', value: val })
      );
      userPreferences.preferedSize?.forEach((val) =>
        prefTags.push({ key: 'Size', value: val })
      );
      userPreferences.preferedIndoorOutdoor?.forEach((val) =>
        prefTags.push({ key: 'IndoorOutdoor', value: val })
      );
      userPreferences.preferedPropagationEase?.forEach((val) =>
        prefTags.push({ key: 'PropagationEase', value: val })
      );
      userPreferences.preferedPetFriendly?.forEach((val) =>
        prefTags.push({ key: 'PetFriendly', value: val })
      );
      userPreferences.preferedExtras?.forEach((val) =>
        prefTags.push({ key: 'Extras', value: val })
      );
    }

    return (
      <LinearGradient
        colors={[COLORS.primary, COLORS.secondary]}
        style={headerStyles.headerGradient}
      >
        <View style={headerStyles.headerRow}>
          <Text style={headerStyles.headerTitle}>Explore</Text>
          <TouchableOpacity
            onPress={handleFilterPress}
            style={headerStyles.headerActionButton}
          >
            <Ionicons name="options" size={24} color={COLORS.textLight} />
          </TouchableOpacity>
        </View>
        <View style={styles.filterContainer}>
          <View style={styles.filterInfoContainer}>
            {prefTags.length > 0 ? (
              <Text style={styles.filterInfoTextColumn}>Filters:</Text>
            ) : (
              <Text style={styles.noFilterText}>No filters applied</Text>
            )}
          </View>
          {prefTags.length > 0 && (
            <View style={styles.filterColumn}>
              <FlatList
                data={prefTags}
                keyExtractor={(item, index) =>
                  `${item.key}-${item.value}-${index}`
                }
                horizontal
                showsHorizontalScrollIndicator={false}
                renderItem={({ item }) => (
                  <TouchableOpacity
                    style={styles.removeTagButton}
                    onPress={() =>
                      handleRemoveSinglePreference(item.key, item.value)
                    }
                  >
                    <View style={styles.tagChip}>
                      <Text style={styles.tagChipText}>{item.value}</Text>
                      <Ionicons name="close-circle" size={16} color="#fff" />
                    </View>
                  </TouchableOpacity>
                )}
              />
            </View>
          )}
        </View>
      </LinearGradient>
    );
  };

  // ----- Main Card Stack Rendering -----
  const renderCardStack = () => {
    if (loadingPlants || loadingMyPlants) {
      return (
        <View style={styles.loaderContainer}>
          <ActivityIndicator size="large" color={COLORS.primary} />
          <Text style={styles.loaderText}>Loading plants...</Text>
        </View>
      );
    }

    if (errorPlants || errorMyPlants) {
      return (
        <View style={styles.noPlantsContainer}>
          <Text style={styles.noPlantsText}>
            Failed to load plants or your gallery.
          </Text>
          <TouchableOpacity
            style={styles.reloadButton}
            onPress={() => {
              refetchLikablePlants();
              refetchMyPlants();
            }}
          >
            <Text style={styles.reloadButtonText}>Try Again</Text>
          </TouchableOpacity>
        </View>
      );
    }

    if (myPlants && myPlants.length === 0) {
      return (
        <View style={styles.noPlantsContainer}>
          <Text style={styles.noPlantsText}>
            Please add some plants to your gallery before exploring :)
          </Text>
          <TouchableOpacity
            style={styles.reloadButton}
            onPress={() => navigation.navigate('AddPlant' as never)}
          >
            <Text style={styles.reloadButtonText}>Add a Plant</Text>
          </TouchableOpacity>
        </View>
      );
    }

    if (!plantStack || plantStack.length === 0) {
      return (
        <View style={styles.noPlantsContainer}>
          <Text style={styles.noPlantsText}>
            No more plants to show in your area.
          </Text>
          <TouchableOpacity
            style={styles.reloadButton}
            onPress={() => refetchLikablePlants()}
          >
            <Text style={styles.reloadButtonText}>Reload</Text>
          </TouchableOpacity>
        </View>
      );
    }

    const visibleCards = plantStack.slice(0, 3);
    return (
      <View style={styles.deckContainer}>
        {visibleCards
          .map((plant, index) => {
            const isTopCard = index === 0;
            const offset = (visibleCards.length - 1 - index) * 5;
            return (
              <View
                key={plant.plantId}
                style={[styles.cardWrapper, { top: offset, left: offset }]}
              >
                <SwipeableCard
                  ref={isTopCard ? topCardRef : null}
                  plant={plant}
                  onSwipeLeft={handleDislike}
                  onSwipeRight={handleSwipeRight}
                  onLikeGestureBegin={handleLikeGestureBegin}
                />
              </View>
            );
          })
          .reverse()}
      </View>
    );
  };

  return (
    <SafeAreaProvider style={styles.container}>
      {renderHeader()}
      {renderCardStack()}

      {/* Bottom Action Buttons */}
      {plantStack && plantStack.length > 0 && (
        <View style={styles.bottomActionContainer}>
          <TouchableOpacity
            onPress={handlePassPress}
            style={styles.actionButtonWrapper}
            disabled={sendingSwipes}
          >
            <LinearGradient
              colors={[COLORS.accentRed, COLORS.accentLightRed]}
              style={styles.actionButton}
            >
              <MaterialIcons name="close" size={32} color={COLORS.textLight} />
            </LinearGradient>
          </TouchableOpacity>

          <View style={styles.divider} />

          <TouchableOpacity
            onPress={handleLikePress}
            style={styles.actionButtonWrapper}
            disabled={sendingSwipes}
          >
            <LinearGradient
              colors={[COLORS.primary, COLORS.secondary]}
              style={styles.actionButton}
            >
              <MaterialIcons
                name="favorite"
                size={32}
                color={COLORS.textLight}
              />
            </LinearGradient>
          </TouchableOpacity>

          <SelectPlantsModal
            visible={showSelectModal}
            onConfirm={handleSelectConfirm}
            onClose={handleSelectCancel}
          />
      {matches.length > 0 && userProfile && (
        <ItsAMatchModal
          visible={matches.length > 0}
          matches={matches}
          currentUserId={userProfile.userId}
          onClose={clearMatches}
        />
      )}
        </View>
      )}

    </SafeAreaProvider>
  );
};

export default SwipeScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'column',
    backgroundColor: COLORS.background,
  },
  loaderContainer: {
    flex: 1,
    alignItems: 'center',
  },
  loaderText: {
    fontSize: 16,
    marginTop: 10,
    color: COLORS.textDark,
  },
  noPlantsContainer: {
    flex: 1,
    alignItems: 'center',
    paddingHorizontal: 20,
    justifyContent: 'center',
  },
  noPlantsText: {
    fontSize: 16,
    color: COLORS.textDark,
    marginBottom: 10,
    textAlign: 'center',
  },
  reloadButton: {
    backgroundColor: COLORS.primary,
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 8,
  },
  reloadButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  filterContainer: {
    flexDirection: 'row',
  },
  filterInfoContainer: {
    marginTop: 10,
  },
  filterInfoTextColumn: {
    color: COLORS.textLight,
    fontSize: 14,
  },
  noFilterText: {
    color: COLORS.textLight,
    fontSize: 14,
  },
  filterColumn: {
    marginLeft: 5,
    flexDirection: 'row',
    flex: 1,
    alignItems: 'center',
  },
  tagChip: {
    flexDirection: 'row',
    backgroundColor: COLORS.accentRed,
    paddingVertical: 2,
    paddingHorizontal: 8,
    borderRadius: 16,
    marginRight: 8,
    marginTop: 10,
    alignItems: 'center',
  },
  tagChipText: {
    color: '#fff',
    marginRight: 4,
    fontSize: 12,
    fontWeight: '600',
  },
  removeTagButton: {
    paddingLeft: 2,
  },
  deckContainer: {
    marginBottom: 10,
    flex: 1,
    alignItems: 'center',
    right: 0,
  },
  cardWrapper: {
    width: width * 0.9,
  },
  bottomActionContainer: {
    backgroundColor: COLORS.textLight,
    borderRadius: 20,
    paddingHorizontal: 60,
    paddingTop: 20,
    paddingBottom: 20,
    margin: 20,
    marginHorizontal: 40,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOpacity: 0.15,
        shadowRadius: 10,
        shadowOffset: { width: 0, height: -4 },
      },
      android: {
        elevation: 10,
      },
    }),
    alignItems: 'center',
    justifyContent: 'space-between',
    flexDirection: 'row',
  },
  divider: {
    width: 1,
    height: '150%',
    backgroundColor: COLORS.border,
  },
  actionButtonWrapper: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  actionButton: {
    width: 50,
    height: 50,
    borderRadius: 25,
    alignItems: 'center',
    justifyContent: 'center',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOpacity: 0.25,
        shadowRadius: 6,
        shadowOffset: { width: 0, height: 3 },
      },
      android: {
        elevation: 6,
      },
    }),
  },
});


// File: app\features\main\screens\TradeProposalsScreen.tsx
import React from "react";
import {
  ActivityIndicator,
  Alert,
  FlatList,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from "react-native";
import { SafeAreaProvider } from "react-native-safe-area-context";
import { useNavigation, useRoute } from "@react-navigation/native";
import { LinearGradient } from "expo-linear-gradient";
import { COLORS } from "../../../theme/colors";
import { useMyProfile } from "../hooks/useMyProfileHooks";
import {
  useTradeProposals,
  useUpdateTradeProposalStatus,
  useConfirmTradeProposalCompletion,
} from "../hooks/useTradeProposalHooks";
import { TradeProposalResponse } from "../../../types/apiTypes";
import { TradeProposalStatus } from "../../../types/enums";
import PlantThumbnail from "../components/PlantThumbnail";
import CompletedTradeActions from "../components/CompletedTradeActions";
import { headerStyles } from "../styles/headerStyles";
import { Ionicons } from "@expo/vector-icons";

// New imports for the info modal functionality.
import InfoModal from "../modals/InfoModal";
import PlantCardWithInfo from "../components/PlantCardWithInfo";
import { PlantResponse } from "../../../types/apiTypes";
import { useMarkPlantsAsTraded } from "../hooks/usePlantHooks";

type RouteParams = {
  connectionId: number;
};

const TradeProposalsScreen: React.FC = () => {
  const route = useRoute();
  const navigation = useNavigation();
  const { connectionId } = route.params as RouteParams;

  const { data: myProfile, isLoading: profileLoading, isError: profileError } =
    useMyProfile();

  const {
    data: proposals,
    isLoading,
    isError,
    refetch,
  } = useTradeProposals(connectionId);

  const { mutate: updateStatus } = useUpdateTradeProposalStatus(connectionId);
  const { mutate: confirmCompletion } = useConfirmTradeProposalCompletion(connectionId);
  const { mutate: markPlantsAsTraded } = useMarkPlantsAsTraded();

  // State to track which plant's info to display.
  const [plantInfo, setPlantInfo] = React.useState<PlantResponse | null>(null);

  // Helper to update proposal status.
  const handleUpdateStatus = (proposalId: number, newStatus: TradeProposalStatus) => {
    updateStatus({ proposalId, newStatus });
  };

  // Callback invoked by CompletedTradeActions
  const handleConfirmDecisions = (proposalId: number, plantsToDelete: number[]) => {
    // 1) Mark the plants as traded if we have any
    // 2) Then confirm the trade proposal completion
    if (plantsToDelete.length > 0) {
      markPlantsAsTraded(plantsToDelete, {
        onSuccess: () => {
          confirmCompletion(proposalId);
        },
        onError: (err) => {
          console.error("Error marking as traded:", err);
        },
      });
    } else {
      // If no plants to delete, just confirm completion
      confirmCompletion(proposalId);
    }
  };

  const renderItem = ({ item }: { item: TradeProposalResponse }) => {
    // Determine which side is yours.
    const isUser1 = myProfile!.userId === item.connection.user1.userId;
    const myPlants = isUser1 ? item.plantsProposedByUser1 : item.plantsProposedByUser2;
    const otherPlants = isUser1 ? item.plantsProposedByUser2 : item.plantsProposedByUser1;

    // Determine confirmation flag.
    const isOwner = myProfile!.userId === item.proposalOwnerUserId;
    const hasConfirmed = isOwner
      ? item.ownerCompletionConfirmed
      : item.responderCompletionConfirmed;

    // Column titles.
    const userOfferTitle = "Your Offer";
    const otherOfferTitle = "Their Offer";

    // Handlers for pending proposals.
    const handleAccept = () =>
      Alert.alert("Accept Proposal", "Do you want to accept this proposal?", [
        { text: "No" },
        {
          text: "Yes",
          onPress: () =>
            handleUpdateStatus(item.tradeProposalId, TradeProposalStatus.Accepted),
        },
      ]);
    const handleDecline = () =>
      Alert.alert("Decline Proposal", "Do you want to decline this proposal?", [
        { text: "No" },
        {
          text: "Yes",
          onPress: () =>
            handleUpdateStatus(item.tradeProposalId, TradeProposalStatus.Rejected),
        },
      ]);
    const handleCancel = () =>
      Alert.alert("Cancel Proposal", "Do you want to cancel this proposal?", [
        { text: "No" },
        {
          text: "Yes",
          onPress: () =>
            handleUpdateStatus(item.tradeProposalId, TradeProposalStatus.Rejected),
        },
      ]);

    // Handlers for accepted proposals.
    const handleMarkCompleted = () =>
      Alert.alert("Complete Trade", "Mark this trade as completed?", [
        { text: "No" },
        {
          text: "Yes",
          onPress: () =>
            handleUpdateStatus(item.tradeProposalId, TradeProposalStatus.Completed),
        },
      ]);
    const handleChangedMyMind = () =>
      Alert.alert("Changed Your Mind?", "Do you want to cancel this proposal?", [
        { text: "No" },
        {
          text: "Yes",
          onPress: () =>
            handleUpdateStatus(item.tradeProposalId, TradeProposalStatus.Rejected),
        },
      ]);

    let actions = null;
    if (item.tradeProposalStatus === TradeProposalStatus.Pending) {
      actions = isOwner ? (
        <TouchableOpacity
          style={[styles.actionButton, styles.cancelButton]}
          onPress={handleCancel}
        >
          <Text style={styles.actionButtonText}>Cancel Proposal</Text>
        </TouchableOpacity>
      ) : (
        <View style={styles.actionRow}>
          <TouchableOpacity
            style={[styles.actionButton, styles.acceptButton]}
            onPress={handleAccept}
          >
            <Text style={styles.actionButtonText}>Accept</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.actionButton, styles.rejectButton]}
            onPress={handleDecline}
          >
            <Text style={styles.actionButtonText}>Decline</Text>
          </TouchableOpacity>
        </View>
      );
    } else if (item.tradeProposalStatus === TradeProposalStatus.Accepted) {
      actions = (
        <View style={styles.actionRow}>
          <TouchableOpacity
            style={[styles.actionButton, styles.completeButton]}
            onPress={handleMarkCompleted}
          >
            <Text style={styles.actionButtonText}>Mark as Completed</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.actionButton, styles.changedMyMindButton]}
            onPress={handleChangedMyMind}
          >
            <Text style={styles.actionButtonText}>Changed My Mind</Text>
          </TouchableOpacity>
        </View>
      );
    } else if (item.tradeProposalStatus === TradeProposalStatus.Completed) {
      // For completed proposals, show the CompletedTradeActions component.
      actions = !hasConfirmed ? (
        <CompletedTradeActions
          plants={myPlants}
          proposalId={item.tradeProposalId}
          onConfirmDecisions={handleConfirmDecisions}
          onPlantInfoPress={(plant) => setPlantInfo(plant)}
        />
      ) : (
        <View style={styles.completedSection}>
          <Text style={styles.completedMessage}>Trade Completed</Text>
        </View>
      );
    }

    // Determine layout:
    // • If both offers have exactly one plant, display them side-by-side (horizontally).
    // • Otherwise, stack the two sections vertically. In both cases the plant thumbnails use a flex container.
    const isHorizontalLayout = myPlants.length === 1 && otherPlants.length === 1;

    return (
      <View style={styles.card}>
        <Text style={styles.cardTitle}>Proposal #{item.tradeProposalId}</Text>
        <Text style={styles.cardSubtitle}>
          Created: {new Date(item.createdAt).toLocaleString()}
        </Text>

        {isHorizontalLayout ? (
          // Horizontal layout (one plant per offer)
          <View style={styles.offersSectionHorizontal}>
            <View style={styles.offerColumnHorizontal}>
              <Text style={styles.columnTitle}>{userOfferTitle}</Text>
              <View style={styles.offerListFlex}>
                {myPlants.map((plant) => (
                  <PlantThumbnail
                    key={plant.plantId}
                    plant={plant}
                    selectable={false}
                    onInfoPress={() => setPlantInfo(plant)}
                  />
                ))}
              </View>
            </View>
            <View style={styles.offerColumnHorizontal}>
              <Text style={styles.columnTitle}>{otherOfferTitle}</Text>
              <View style={styles.offerListFlex}>
                {otherPlants.map((plant) => (
                  <PlantThumbnail
                    key={plant.plantId}
                    plant={plant}
                    selectable={false}
                    onInfoPress={() => setPlantInfo(plant)}
                  />
                ))}
              </View>
            </View>
          </View>
        ) : (
          // Vertical layout: sections stacked one on top of the other
          <View style={styles.offersSectionVertical}>
            <View style={styles.offerSection}>
              <Text style={styles.columnTitle}>{userOfferTitle}</Text>
              <View style={styles.offerListFlex}>
                {myPlants.map((plant) => (
                  <PlantThumbnail
                    key={plant.plantId}
                    plant={plant}
                    selectable={false}
                    onInfoPress={() => setPlantInfo(plant)}
                  />
                ))}
              </View>
            </View>
            <View style={styles.offerSection}>
              <Text style={styles.columnTitle}>{otherOfferTitle}</Text>
              <View style={styles.offerListFlex}>
                {otherPlants.map((plant) => (
                  <PlantThumbnail
                    key={plant.plantId}
                    plant={plant}
                    selectable={false}
                    onInfoPress={() => setPlantInfo(plant)}
                  />
                ))}
              </View>
            </View>
          </View>
        )}

        <Text style={styles.statusText}>Status: {item.tradeProposalStatus}</Text>
        {actions}
      </View>
    );
  };

  if (isLoading || profileLoading) {
    return (
      <SafeAreaProvider style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={COLORS.primary} />
      </SafeAreaProvider>
    );
  }
  if (isError || profileError) {
    return (
      <SafeAreaProvider style={styles.errorContainer}>
        <Text style={styles.errorText}>Failed to load trade proposals.</Text>
        <TouchableOpacity style={styles.retryButton} onPress={() => refetch()}>
          <Text style={styles.retryButtonText}>Retry</Text>
        </TouchableOpacity>
      </SafeAreaProvider>
    );
  }
  return (
    <SafeAreaProvider style={styles.container}>
      <LinearGradient
        colors={[COLORS.primary, COLORS.secondary]}
        style={headerStyles.headerGradient}
      >
        <View style={headerStyles.headerColumn1}>
          <TouchableOpacity
            style={headerStyles.headerBackButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="chevron-back" size={30} color={COLORS.textLight} />
          </TouchableOpacity>
          <Text style={headerStyles.headerTitle}>Trade Proposals</Text>
          <View style={{ width: 50 }} />
        </View>
      </LinearGradient>
      {proposals && proposals.length > 0 ? (
        <FlatList
          data={proposals}
          keyExtractor={(item) => item.tradeProposalId.toString()}
          renderItem={renderItem}
          contentContainerStyle={styles.listContent}
        />
      ) : (
        <View style={styles.emptyContainer}>
          <Text style={styles.emptyText}>No trade proposals found.</Text>
        </View>
      )}
      {/* InfoModal shows the full plant card when a thumbnail’s info is pressed */}
      <InfoModal visible={!!plantInfo} onClose={() => setPlantInfo(null)}>
        {plantInfo && <PlantCardWithInfo plant={plantInfo} compact={false} />}
      </InfoModal>
    </SafeAreaProvider>
  );
};

export default TradeProposalsScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  errorContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 20,
  },
  errorText: {
    fontSize: 16,
    color: COLORS.textDark,
    marginBottom: 10,
    textAlign: "center",
  },
  retryButton: {
    backgroundColor: COLORS.primary,
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  retryButtonText: {
    color: "#fff",
    fontWeight: "600",
    fontSize: 16,
  },
  listContent: {
    padding: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 20,
  },
  emptyText: {
    fontSize: 16,
    color: COLORS.textDark,
  },
  card: {
    backgroundColor: "#fff",
    borderRadius: 10,
    padding: 16,
    marginBottom: 12,
    shadowColor: "#000",
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: "bold",
    marginBottom: 4,
  },
  cardSubtitle: {
    fontSize: 14,
    marginBottom: 12,
  },
  columnTitle: {
    fontSize: 14,
    fontWeight: "600",
    marginBottom: 4,
    textAlign: "center",
  },
  statusText: {
    fontSize: 14,
    fontWeight: "600",
    marginBottom: 12,
    textAlign: "center",
  },
  actionRow: {
    flexDirection: "row",
    justifyContent: "space-around",
  },
  actionButton: {
    flex: 1,
    paddingVertical: 10,
    marginHorizontal: 2,
    borderRadius: 8,
    alignItems: "center",
    justifyContent: "center",
  },
  acceptButton: {
    backgroundColor: COLORS.accentGreen,
  },
  rejectButton: {
    backgroundColor: COLORS.accentRed,
  },
  cancelButton: {
    backgroundColor: COLORS.accentRed,
  },
  completeButton: {
    backgroundColor: COLORS.accentGreen,
  },
  changedMyMindButton: {
    backgroundColor: "#F39C12",
  },
  actionButtonText: {
    color: "#fff",
    fontWeight: "600",
    fontSize: 14,
  },
  completedSection: {
    marginTop: 10,
    alignItems: "center",
  },
  completedMessage: {
    fontSize: 16,
    fontWeight: "600",
    color: COLORS.textDark,
    paddingVertical: 10,
  },
  // ----- Horizontal Layout Styles (when each offer has one plant) -----
  offersSectionHorizontal: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  offerColumnHorizontal: {
    flex: 1,
    alignItems: "center",
  },
  // ----- Vertical Layout Styles (when one or both offers have more than one plant) -----
  offersSectionVertical: {
    flexDirection: "column",
    alignItems: "center",
    marginBottom: 12,
  },
  offerSection: {
    width: "100%",
    alignItems: "center",
    marginBottom: 16,
  },
  // Common flex container for plant thumbnails (similar to MyProfileScreen's thumbViewContainer)
  offerListFlex: {
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "center",
    marginTop: 8,
  },
});


// File: app\features\main\styles\headerStyles.ts
// File: src/styles/headerStyles.ts
import { StyleSheet } from "react-native";
import { COLORS } from "../../../theme/colors";

export const headerStyles = StyleSheet.create({
  headerGradient: {
    paddingHorizontal: 20,
    paddingVertical: 15,
    marginBottom: 10,
    elevation: 10,
    backgroundColor: COLORS.background,
    // ... any other shared header style props
  },
  headerRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    // ...
  },
  headerColumn1: {
    flexDirection: "row",
    alignItems: "center",
    // ...
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: "700",
    color: COLORS.textLight,
    // ...
  },
  headerActionButton: {
    padding: 6,
  },
  headerBackButton: {
    marginRight: 10,
    borderColor: COLORS.textLight,
    paddingRight: 10,
    borderRightWidth: 1,
  },
  headerAboveScroll: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginHorizontal: 20,
    marginBottom: 10,
  },
});


// File: app\features\main\styles\profileCardStyles.ts
import { StyleSheet, Platform } from "react-native";
import { COLORS } from "../../../theme/colors";

export const profileCardStyles = StyleSheet.create({
  // Container that wraps the card
  profileCardContainer: {
    borderRadius: 18,
    overflow: "hidden",
    ...Platform.select({
      ios: {
        shadowColor: "#000",
        shadowOpacity: 0.12,
        shadowRadius: 6,
        shadowOffset: { width: 0, height: 3 },
      },
      android: {
        elevation: 4,
      },
    }),
  },

  // Inner container (for gradients, etc.)
  profileCardInner: {
    borderRadius: 18,
  },

  // Top “header” area of the card
  profileTopContainer: {
    backgroundColor: COLORS.primary,
    height: 120,
    position: "relative",
  },
  profileBackgroundImage: {
    height: "100%",
    resizeMode: "cover",
    position: "absolute",
    bottom: 0,
    right: 0,
    left: -200,
  },

  // Profile Picture
  profilePictureContainer: {
    position: "absolute",
    bottom: -75,
    left: 25,
  },
  profilePicture: {
    width: 170,
    height: 170,
    borderRadius: 40,
    borderWidth: 3,
    borderColor: "#fff",
  },
  profilePlaceholder: {
    width: 170,
    height: 170,
    borderRadius: 40,
    backgroundColor: "#eee",
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 3,
    borderColor: "#fff",
  },
  cameraIconWrapper: {
    position: "absolute",
    bottom: 0,
    right: 0,
    backgroundColor: COLORS.accentGreen,
    borderRadius: 16,
    padding: 6,
  },

  // Edit / Save button in the top-right corner
  profileEditButton: {
    position: "absolute",
    top: 16,
    right: 16,
    width: 35,
    height: 35,
    borderRadius: 20,
    backgroundColor: COLORS.accentGreen,
    justifyContent: "center",
    alignItems: "center",
    ...Platform.select({
      ios: {
        shadowColor: "#000",
        shadowOpacity: 0.1,
        shadowRadius: 5,
        shadowOffset: { width: 0, height: 3 },
      },
      android: {
        elevation: 3,
      },
    }),
  },

  // Name & Location area
  profileInfoContainer: {
    right: -190,
  },
  nameContainer: {
    marginLeft: 17,
    marginTop: 5,
  },
  editNameContainer: {
    flex: 1,
    marginRight: 15,
    backgroundColor: COLORS.cardBg1,
    borderRadius: 5,
    ...Platform.select({
      ios: {
        shadowColor: "#000",
        shadowOpacity: 0.1,
        shadowRadius: 5,
        shadowOffset: { width: 0, height: 3 },
      },
      android: {
        elevation: 3,
      },
    }),
  },
  profileNameText: {
    fontSize: 18,
    fontWeight: "700",
    color: COLORS.textDark,
    margin: 3,
  },
  editableTextName: {
    borderRadius: 5,
    borderBottomWidth: 0,
    padding: 3,
    margin: 0,
  },

  profileLocationRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
    marginHorizontal: 20,
  },
  locationIcon: {
    marginRight: 4,
    top: 1,
  },
  profileLocationText: {
    fontSize: 14,
    color: COLORS.textDark,
    marginTop: 2,    
  },

  // Bio
  bioContainer: {
    margin: 20,
  },
  bioContainerEdit: {
    backgroundColor: COLORS.cardBg1,
    borderRadius: 5,
    ...Platform.select({
      ios: {
        shadowColor: "#000",
        shadowOpacity: 0.1,
        shadowRadius: 5,
        shadowOffset: { width: 0, height: 3 },
      },
      android: {
        elevation: 3,
      },
    }),
  },
  bioText: {
    fontSize: 14,
    color: COLORS.textDark,
    lineHeight: 20,
    margin: 5,
  },
  editableTextBio: {
    // remove typical text input borders
    borderRadius: 5,
    borderBottomWidth: 0,
    padding: 5,
    margin: 0,
  },
  bioPlaceholder: {
    color: "#999",
    fontStyle: "italic",
  },

  // For inline editing

  // Errors
  errorText: {
    color: "#FF6B6B",
    marginBottom: 10,
    textAlign: "center",
    fontWeight: "600",
  },
});


// File: app\features\main\types\mainTypes.ts


// File: app\features\onboarding\screens\OnboardingBioScreen.tsx
import React, { useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, TextInput, Alert, Keyboard } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useNavigation } from '@react-navigation/native';
import { COLORS } from '../../../theme/colors';
// Adjust the following import to wherever your profile hook or service is defined.
import { useMyProfile } from '../../../features/main/hooks/useMyProfileHooks';
import { userService } from '../../../api/userService';

const OnboardingBioScreen: React.FC = () => {
  const navigation = useNavigation();
  const { data: userProfile } = useMyProfile();
  const [bio, setBio] = useState(userProfile?.bio ?? '');

  const handleSkip = () => {
    navigation.navigate('OnboardingLocation' as never);
  };

  const handleSubmitBio = async () => {
    // Optionally add validation if bio is empty.
    Keyboard.dismiss();
    try {
      await userService.updateMe({ name: userProfile?.name ?? '', bio });
      navigation.navigate('OnboardingLocation' as never);
    } catch (error) {
      Alert.alert('Error', 'Failed to update your bio. Please try again.');
    }
  };

  return (
    <LinearGradient colors={[COLORS.primary, COLORS.secondary]} style={styles.container}>
      <View style={styles.content}>
        <Text style={styles.title}>Your Story</Text>
        <Text style={styles.subtitle}>
          Let others know a little about you. A short bio helps fellow plant enthusiasts know more about who they are entrusting their precious plants with.
        </Text>
        <TextInput
          style={styles.textInput}
          value={bio}
          onChangeText={setBio}
          placeholder="Write a short bio..."
          placeholderTextColor="#ccc"
          multiline
          textAlignVertical="top"
        />
        <View style={styles.buttonContainer}>
          <TouchableOpacity onPress={handleSkip} style={[styles.button, styles.skipButton]}>
            <Text style={styles.buttonText}>Skip</Text>
          </TouchableOpacity>
          <TouchableOpacity onPress={handleSubmitBio} style={[styles.button, styles.submitButton]}>
            <Text style={styles.buttonText}>Next: Choose Location</Text>
          </TouchableOpacity>
        </View>
      </View>
    </LinearGradient>
  );
};

export default OnboardingBioScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    paddingHorizontal: 20,
    justifyContent: 'center',
  },
  title: {
    fontSize: 30,
    fontWeight: '700',
    color: COLORS.textLight,
    textAlign: 'center',
    marginBottom: 15,
  },
  subtitle: {
    fontSize: 18,
    color: COLORS.textLight,
    textAlign: 'center',
    marginBottom: 30,
    lineHeight: 24,
  },
  textInput: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 15,
    fontSize: 16,
    color: COLORS.textDark,
    marginBottom: 30,
    minHeight: 100,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  button: {
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    alignItems: 'center',
  },
  skipButton: {
    backgroundColor: COLORS.accentRed,
  },
  submitButton: {
    backgroundColor: COLORS.accentGreen,
  },
  buttonText: {
    color: COLORS.textLight,
    fontSize: 16,
    fontWeight: '600',
  },
});


// File: app\features\onboarding\screens\OnboardingLocationScreen.tsx
// File: app/features/onboarding/screens/OnboardingLocationScreen.tsx
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Alert,
  Dimensions,
} from 'react-native';
import MapView, { Marker, MapPressEvent, Region } from 'react-native-maps';
import * as Location from 'expo-location';
import { LinearGradient } from 'expo-linear-gradient';
import { useNavigation } from '@react-navigation/native';
import { COLORS } from '../../../theme/colors';
import { useUpdateLocation } from '../../main/hooks/useMyProfileHooks';

const { width, height } = Dimensions.get('window');

const OnboardingLocationScreen: React.FC = () => {
  const navigation = useNavigation();
  const updateLocation = useUpdateLocation();

  const [region, setRegion] = useState<Region | null>(null);
  const [selectedLocation, setSelectedLocation] = useState<{
    latitude: number;
    longitude: number;
  } | null>(null);
  const [permissionStatus, setPermissionStatus] =
    useState<Location.PermissionStatus | null>(null);

  // Request permission and possibly fetch current location on mount.
  useEffect(() => {
    (async () => {
      const { status } = await Location.requestForegroundPermissionsAsync();
      setPermissionStatus(status);

      if (status === Location.PermissionStatus.GRANTED) {
        try {
          const loc = await Location.getCurrentPositionAsync({});
          const newRegion: Region = {
            latitude: loc.coords.latitude,
            longitude: loc.coords.longitude,
            latitudeDelta: 0.05,
            longitudeDelta: 0.05,
          };
          setRegion(newRegion);
          setSelectedLocation({
            latitude: loc.coords.latitude,
            longitude: loc.coords.longitude,
          });
        } catch (err) {
          // If we fail to fetch current location, fallback to a default (e.g. SF).
          setRegion({
            latitude: 37.78825,
            longitude: -122.4324,
            latitudeDelta: 0.05,
            longitudeDelta: 0.05,
          });
        }
      } else {
        // Permission denied => fallback region
        setRegion({
          latitude: 37.78825,
          longitude: -122.4324,
          latitudeDelta: 0.05,
          longitudeDelta: 0.05,
        });
      }
    })();
  }, []);

  // Handle taps on the map to place marker
  const handleMapPress = (e: MapPressEvent) => {
    const { latitude, longitude } = e.nativeEvent.coordinate;
    setSelectedLocation({ latitude, longitude });
    setRegion((prev) =>
      prev
        ? { ...prev, latitude, longitude }
        : {
            latitude,
            longitude,
            latitudeDelta: 0.05,
            longitudeDelta: 0.05,
          }
    );
  };

  // Confirm the chosen location
  const handleConfirmLocation = async () => {
    if (!selectedLocation) {
      Alert.alert('No Location', 'Please tap on the map to choose a location.');
      return;
    }
    try {
      await updateLocation.mutateAsync({
        latitude: selectedLocation.latitude,
        longitude: selectedLocation.longitude,
      });
      // Navigate to the next onboarding step
      navigation.navigate('OnboardingWelcome' as never);
    } catch (error) {
      Alert.alert('Error', 'Failed to update location. Please try again.');
    }
  };

  return (
    <View style={styles.container}>
      <LinearGradient colors={[COLORS.primary, COLORS.secondary]} style={styles.header}>
        <Text style={styles.headerTitle}>Set Your Location</Text>
      </LinearGradient>

      <Text style={styles.instructions}>
        {permissionStatus === Location.PermissionStatus.DENIED
          ? 'Permission denied. Tap on the map to choose a location.'
          : 'Tap on the map to set your approximate location.'}
      </Text>

      <View style={styles.mapContainer}>
        {region && (
          <MapView
            style={StyleSheet.absoluteFill}
            region={region}
            onPress={handleMapPress}
          >
            {selectedLocation && (
              <Marker
                coordinate={selectedLocation}
                title="Selected Location"
              />
            )}
          </MapView>
        )}
      </View>

      <TouchableOpacity style={styles.confirmButton} onPress={handleConfirmLocation}>
        <Text style={styles.confirmButtonText}>Confirm & Continue</Text>
      </TouchableOpacity>
    </View>
  );
};

export default OnboardingLocationScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  header: {
    padding: 20,
    paddingHorizontal: 20,
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 26,
    fontWeight: '700',
    color: '#fff',
  },
  instructions: {
    fontSize: 16,
    color: '#333',
    textAlign: 'center',
    marginHorizontal: 20,
    marginVertical: 10,
  },
  mapContainer: {
    flex: 1,
    marginHorizontal: 20,
    borderRadius: 12,
    overflow: 'hidden',
    backgroundColor: '#fff',
    elevation: 4,
    shadowColor: '#000',
    shadowOpacity: 0.1,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 3 },
    marginBottom: 10,
  },
  confirmButton: {
    backgroundColor: COLORS.accentGreen,
    margin: 20,
    paddingVertical: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  confirmButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
});


// File: app\features\onboarding\screens\OnboardingWelcomeScreen.tsx
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useNavigation } from '@react-navigation/native';
import { COLORS } from '../../../theme/colors';

const OnboardingWelcomeScreen: React.FC = () => {
  const navigation = useNavigation();

  const handleNextPress = () => {
    navigation.navigate('OnboardingBio' as never);
  };

  return (
    <LinearGradient colors={[COLORS.primary, COLORS.secondary]} style={styles.container}>
      <View style={styles.content}>
        <Text style={styles.title}>Welcome to Cuttr!</Text>
        <Text style={styles.subtitle}>
          Expand and diversify your plant collection effortlessly. Cuttr lets you trade unique, free plant cuttings from the coolest, hard‐to‐find species – no more relying on big greenhouses that aren’t eco–friendly. Share your cuttings and discover new gems to brighten up your space!
        </Text>
        <TouchableOpacity onPress={handleNextPress} style={styles.button}>
          <Text style={styles.buttonText}>Next: Tell Us About You</Text>
        </TouchableOpacity>
      </View>
    </LinearGradient>
  );
};

export default OnboardingWelcomeScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    paddingHorizontal: 20,
    justifyContent: 'center',
  },
  title: {
    fontSize: 32,
    fontWeight: '700',
    color: COLORS.textLight,
    textAlign: 'center',
    marginBottom: 20,
  },
  subtitle: {
    fontSize: 18,
    color: COLORS.textLight,
    textAlign: 'center',
    marginBottom: 40,
    lineHeight: 26,
  },
  button: {
    backgroundColor: COLORS.accentGreen,
    paddingVertical: 14,
    paddingHorizontal: 20,
    borderRadius: 8,
    alignSelf: 'center',
  },
  buttonText: {
    color: COLORS.textLight,
    fontSize: 18,
    fontWeight: '600',
  },
});


// File: app\hooks\useAuthToken.ts
//This file is up for deletion

// import { useEffect, useState } from 'react';
// import { storage } from '../utils/storage';

// export const useAuthToken = () => {
//   const [initializing, setInitializing] = useState(true);
//   const [accessToken, setAccessToken] = useState<string | null>(null);
//   const [refreshToken, setRefreshToken] = useState<string | null>(null);

//   useEffect(() => {
//     const loadTokens = async () => {
//       const at = await storage.getAccessToken();
//       const rt = await storage.getRefreshToken();
//       setAccessToken(at);
//       setRefreshToken(rt);
//       setInitializing(false);
//     };
//     loadTokens();
//   }, []);

//   return { initializing, accessToken, refreshToken };
// };


// File: app\hooks\useAxiosErrorHandler.ts


// File: app\hooks\useNetworkStatus.ts


// File: app\i18n\index.ts
// app/i18n/index.ts
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import * as Localization from 'expo-localization';

import en from './locales/en.json';
import fr from './locales/fr.json';

export async function initI18n() {
  await i18n
    .use(initReactI18next)
    .init({
      fallbackLng: 'en',
      // Use the device locale from expo-localization:
      lng: Localization.getLocales()[0].languageCode, 
      resources: {
        en: { translation: en },
        fr: { translation: fr },
      },
      interpolation: {
        escapeValue: false,
      },
    });
  return i18n;
}


// File: app\i18n\locales\en.json
{
  "welcome_back": "Welcome Back",
  "create_account": "Create Account",
  "login": "Login",
  "register": "Register",
  "email": "Username",
  "password": "Password",
  "name": "Nickname",
  "no_account_register": "Don’t have an account? Register",
  "have_account_login": "Already have an account? Login",
  "profile_title": "Profile",
  "profile_loading_message": "Loading your profile...",
  "profile_error_message": "Failed to load your profile.",
  "profile_retry_button": "Try Again",
  "profile_name_label": "Nickname",
  "profile_bio_label": "Bio",
  "profile_location_label": "Location",
  "profile_no_location": "No location set",
  "profile_edit_button": "Edit Profile",
  "profile_change_location_button": "Change Location",
  "profile_add_plant_button": "Add Plant",
  "profile_my_plants_section": "My Plants",
  "profile_no_plants_message": "You have no plants yet. Add one to get started!",
  "edit_profile_title": "Edit Profile",
  "edit_profile_name_label": "Name",
  "edit_profile_bio_label": "Bio",
  "edit_profile_confirm_button": "Confirm",
  "edit_profile_cancel_button": "Cancel",
  "edit_profile_error_message": "Failed to update profile.",
  "change_location_title": "Change Location",
  "change_location_instructions": "Tap on the map to select your location.",
  "change_location_confirm_button": "Confirm",
  "change_location_cancel_button": "Cancel",
  "change_location_error_message": "Failed to update location.",
  "add_plant_title": "Add a New Plant",
  "add_plant_species_name_label": "Species Name",
  "add_plant_description_label": "Description",
  "add_plant_stage_label": "Stage",
  "add_plant_category_label": "Category",
  "add_plant_watering_label": "Watering Need",
  "add_plant_light_label": "Light Requirement",
  "add_plant_size_label": "Size",
  "add_plant_indoor_outdoor_label": "Indoor/Outdoor",
  "add_plant_propagation_ease_label": "Propagation Ease",
  "add_plant_pet_friendly_label": "Pet Friendly",
  "add_plant_extras_label": "Extras",
  "add_plant_select_image_button": "Select Image",
  "add_plant_select_image_title": "Select Image",
  "add_plant_save_button": "Save",
  "add_plant_cancel_button": "Cancel",
  "add_plant_error_message": "Failed to add plant.",
  "add_plant_no_image_selected": "No image selected.",
  "onboarding_bio_title": "Tell Us About Yourself",
  "onboarding_bio_subtitle": "Add a brief bio so others can know more about you.",
  "onboarding_bio_placeholder": "Your bio here...",
  "onboarding_bio_skip_button": "Skip",
  "onboarding_bio_submit_button": "Save & Continue",
  "onboarding_bio_note": "You can always add or edit your bio later from your profile.",
  "add_plant_size_question": "Size",
  "add_plant_indoor_outdoor_question": "Indoor/Outdoor",
  "add_plant_propagation_ease_question": "Propagation Ease",
  "add_plant_pet_friendly_question": "Pet Friendly",
  "add_plant_extras_question": "Extras",
  "plant_stage_seedling": "Seed(ling)",
  "plant_stage_cutting": "Cutting",
  "plant_stage_mature": "Mature",
  "plant_category_succulent": "Succulent",
  "plant_category_cactus": "Cactus",
  "plant_category_fern": "Fern",
  "plant_category_orchid": "Orchid",
  "plant_category_herb": "Herb",
  "plant_category_palm": "Palm",
  "plant_category_leafy_houseplant": "Leafy Houseplant",
  "plant_category_aquatic_plant": "Aquatic Plant",
  "plant_category_climbing_plant": "Climbing Plant",
  "plant_category_tree": "Tree",
  "plant_category_other": "Other",
  "watering_need_very_low_water": "Very Low Water",
  "watering_need_low_water": "Low Water",
  "watering_need_moderate_water": "Moderate Water",
  "watering_need_high_water": "High Water",
  "watering_need_very_high_water": "Very High Water",
  "light_requirement_full_sun": "Full Sun",
  "light_requirement_partial_sun": "Partial Sun",
  "light_requirement_bright_indirect_light": "Bright Indirect Light",
  "light_requirement_low_light": "Low Light",
  "size_small_size": "Small Size",
  "size_medium_size": "Medium Size",
  "size_large_size": "Large Size",
  "indoor_outdoor_indoor": "Indoor",
  "indoor_outdoor_outdoor": "Outdoor",
  "indoor_outdoor_indoor_and_outdoor": "Indoor and Outdoor",
  "propagation_ease_easy_propagation": "Easy Propagation",
  "propagation_ease_moderate_propagation": "Moderate Propagation",
  "propagation_ease_difficult_propagation": "Difficult Propagation",
  "pet_friendly_pet_friendly": "Pet Friendly",
  "pet_friendly_not_pet_friendly": "Not Pet Friendly",
  "extras_fragrant": "Fragrant",
  "extras_edible": "Edible",
  "extras_medicinal": "Medicinal",
  "extras_air_purifying": "Air Purifying",
  "extras_decorative": "Decorative",
  "extras_flowering": "Flowering",
  "extras_tropical_vibe": "Tropical Vibe",
  "extras_foliage_heavy": "Foliage Heavy",
  "extras_drought_tolerant": "Drought Tolerant",
  "extras_humidity_loving": "Humidity Loving",
  "extras_low_maintenance": "Low Maintenance",
  "extras_winter_hardy": "Winter Hardy",
  "extras_beginner_friendly": "Beginner Friendly",
  "extras_fruiting": "Fruiting",
  "extras_pollinator_friendly": "Pollinator Friendly",
  "extras_fast_growing": "Fast Growing",
  "extras_variegated_foliage": "Variegated Foliage",
  "extras_climbing": "Climbing",
  "extras_ground_cover": "Ground Cover",
  "extras_rare": "Rare",
  "connections_loading": "Loading your connections...",
  "connections_error": "Unable to load connections. Please try again.",
  "connections_retry_button": "Retry",
  "connections_none_title": "No Connections Yet",
  "connections_none_message": "It looks like you haven't matched with anyone so far.",
  "connections_none_action": "Find Plants",
  "connections_matches_label": "{{count}} Matches",
  "connections_title": "Connections",
  "chat_loading_conversation": "Loading conversation...",
  "chat_error_message": "An error occurred. Please try again.",
  "chat_retry_button": "Retry",
  "chat_no_matches_with_user": "No matches found with this user.",
  "chat_no_messages_yet": "No messages yet. Say hello!",
  "chat_message_placeholder": "Type a message",
  "profile_change_picture_title": "Change Profile Picture",
  "profile_change_picture_msg": "Choose an option to change your profile picture.",
  "profile_picture_select_library": "Select from Library",
  "profile_picture_take_photo": "Take Photo",
  "profile_picture_cancel": "Cancel",
  "profile_no_bio_placeholder": "Add a bio...",
  "error_title": "Error",
  "error_could_not_open_image_library": "Could not open image library.",
  "error_camera_permission_denied": "Camera permission denied.",
  "error_could_not_open_camera": "Could not open camera.",
  "error_profile_picture_update_failed": "Profile picture update failed.",
  "login_button": "Login",
  "register_button": "Register"
}

// File: app\i18n\locales\fr.json
{
    "welcome_back": "Bon Retour",
    "create_account": "Créer un Compte",
    "login": "Connexion",
    "register": "S'inscrire",
    "email": "E-mail",
    "password": "Mot de Passe",
    "name": "Nom",
    "no_account_register": "Vous n'avez pas de compte ? Inscrivez-vous",
    "have_account_login": "Vous avez déjà un compte ? Connectez-vous",
    "profile_title": "Mon Profil",
    "profile_loading_message": "Chargement de votre profil...",
    "profile_error_message": "Impossible de charger votre profil.",
    "profile_retry_button": "Réessayer",
    "profile_name_label": "Nom",
    "profile_bio_label": "Bio",
    "profile_location_label": "Localisation",
    "profile_no_location": "Aucune localisation définie",
    "profile_edit_button": "Modifier le Profil",
    "profile_change_location_button": "Changer la Localisation",
    "profile_add_plant_button": "Ajouter une Plante",
    "profile_my_plants_section": "Mes Plantes",
    "profile_no_plants_message": "Vous n'avez pas encore de plantes. Ajoutez-en une pour commencer !",
    "edit_profile_title": "Modifier le Profil",
    "edit_profile_name_label": "Nom",
    "edit_profile_bio_label": "Bio",
    "edit_profile_confirm_button": "Confirmer",
    "edit_profile_cancel_button": "Annuler",
    "edit_profile_error_message": "Impossible de mettre à jour le profil.",
    
    "change_location_title": "Changer de Localisation",
    "change_location_instructions": "Appuyez sur la carte pour sélectionner votre localisation.",
    "change_location_confirm_button": "Confirmer",
    "change_location_cancel_button": "Annuler",
    "change_location_error_message": "Impossible de mettre à jour la localisation.",
    
    "add_plant_title": "Ajouter une Nouvelle Plante",
    "add_plant_species_name_label": "Nom de l'Espèce",
    "add_plant_description_label": "Description",
    "add_plant_stage_label": "Stade",
    "add_plant_category_label": "Catégorie",
    "add_plant_watering_label": "Besoins en Arrosage",
    "add_plant_light_label": "Besoin en Lumière",
    "add_plant_size_label": "Taille",
    "add_plant_indoor_outdoor_label": "Intérieur/Extérieur",
    "add_plant_propagation_ease_label": "Facilité de Propagation",
    "add_plant_pet_friendly_label": "Adapté aux Animaux",
    "add_plant_extras_label": "Extras",
    "add_plant_select_image_button": "Sélectionner une Image",
    "add_plant_save_button": "Enregistrer",
    "add_plant_cancel_button": "Annuler",
    "add_plant_error_message": "Impossible d'ajouter la plante.",
    "add_plant_no_image_selected": "Aucune image sélectionnée."
  }
  

// File: app\navigation\AppNavigator.tsx
// File: app/navigation/AppNavigator.tsx
import React, { useEffect, useState } from 'react';
import { ActivityIndicator, View, StyleSheet, Text, Button } from 'react-native';
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '../store';
import AuthNavigator from './AuthNavigator';
import MainTabNavigator from './MainTabNavigator';
import OnboardingNavigator from './OnboardingNavigator';
import { useMyProfile } from '../features/main/hooks/useMyProfileHooks';
import { storage } from '../utils/storage';
import { setInitialTokens } from '../features/auth/store/authSlice';
import { userService } from '../api/userService';
import { logout } from '../features/auth/store/authSlice';
import { store } from '../store';
import MainRootStackNavigator from './MainRootStackNavigator';
import { log } from '../utils/logger';

const AppNavigator = () => {
  const dispatch = useDispatch();
  const { accessToken } = useSelector((state: RootState) => state.auth);
  const { refreshToken } = useSelector((state: RootState) => state.auth);
  const [initializing, setInitializing] = useState(true);
  const {
    data: userProfile,
    isLoading: userProfileLoading,
    isError: userProfileError,
    error: userProfileErrorDetails,
    refetch: refetchUserProfile,
  } = useMyProfile();
  

// 1. Attempt to load tokens from storage
useEffect(() => {
  const initializeAuth = async () => {
    const storedAccessToken = await storage.getAccessToken();
    const storedRefreshToken = await storage.getRefreshToken();
    
    if (storedAccessToken && storedRefreshToken) {
      // Put tokens in Redux so subsequent requests include Auth headers
      dispatch(setInitialTokens({
        accessToken: storedAccessToken,
        refreshToken: storedRefreshToken,
      }));

      // 2. Now fetch /me using these tokens
      try {
        log.debug('Fetching /me to get user profile');
        refetchUserProfile();
        dispatch(setInitialTokens({
          accessToken: store.getState().auth.accessToken,
          refreshToken: store.getState().auth.refreshToken
        }));
      } catch (err) {
        // If /me fails, log out
        dispatch(logout());
      }
    }

    setInitializing(false);
  };

  initializeAuth();
}, [dispatch, accessToken]);

  // Show spinner while initializing tokens
  if (initializing) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#1EAE98" />
      </View>
    );
  }

  
  

  // 1. If no token -> show Auth flow
  if (!accessToken) {
    return <AuthNavigator />;
  }

  // 2. If we are still loading the user profile, show a spinner
  if (userProfileLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#1EAE98" />
      </View>
    );
  }

  
  // 3. If location is NOT set, show onboarding flow
  if (!userProfile?.locationLatitude || !userProfile?.locationLongitude) {
    return <OnboardingNavigator />;
  }
  
  if (userProfileError && !userProfileLoading) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>
          Error retrieving profile: {userProfileErrorDetails?.message || "Unknown error"}
        </Text>
        <Button title="Retry" onPress={refetchUserProfile} />
      </View>
    );
  }
  // 4. Otherwise, user has location -> show main app
  return <MainRootStackNavigator />;
};

export default AppNavigator;

const styles = StyleSheet.create({
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  errorContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  errorText: {
    fontSize: 16,
    color: 'red',
    marginBottom: 10,
    textAlign: 'center',
  },
});


// File: app\navigation\AuthNavigator.tsx
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import LoginScreen from '../features/auth/screens/LoginScreen';
import RegisterScreen from '../features/auth/screens/RegisterScreen';

const Stack = createNativeStackNavigator();

const AuthNavigator = () => {
  return (
    <Stack.Navigator>
      <Stack.Screen name="Login" component={LoginScreen} options={{ headerShown: false }} />
      <Stack.Screen name="Register" component={RegisterScreen} options={{ headerShown: false }} />
    </Stack.Navigator>
  );
};

export default AuthNavigator;


// File: app\navigation\MainRootStackNavigator.tsx
// RootStackNavigator.tsx
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import SetUserPreferencesScreen from '../features/main/screens/SetUserPreferencesScreen';
import MainTabNavigator from './MainTabNavigator';
import ChatScreen from '../features/main/screens/ChatScreen';
import AddPlantScreen from '../features/main/screens/AddPlantScreen';
import OtherProfileScreen from '../features/main/screens/OtherProfileScreen';
import MakeTradeProposalScreen from '../features/main/screens/MakeTradeProposalScreen';
import BrowseMatchesScreen from '../features/main/screens/BrowseMatchesScreen';
import TradeProposalsScreen from '../features/main/screens/TradeProposalsScreen';

const RootStack = createNativeStackNavigator();

const MainRootStackNavigator = () => (
  <RootStack.Navigator screenOptions={{ headerShown: false }}>
    {/* Main Tabs of the app */}
    <RootStack.Screen name="MainTabs" component={MainTabNavigator} />
    {/* Modal screen presented over tabs */}
    <RootStack.Screen 
      name="SetUserPreferences" 
      component={SetUserPreferencesScreen}
      options={{ presentation: 'modal' }} 
    />
    <RootStack.Screen
        name="Chat"
        component={ChatScreen}
        options={{ presentation: 'modal' }}
    />
    <RootStack.Screen
        name="AddPlant"
        component={AddPlantScreen}
        options={{ presentation: 'modal' }}
    />
    <RootStack.Screen
      name="OtherProfile"
      component={OtherProfileScreen}
      options={{ presentation: 'modal' }}
    />
    <RootStack.Screen
      name="MakeTradeProposal"
      component={MakeTradeProposalScreen}
      options={{ presentation: 'transparentModal' }}
    />
    <RootStack.Screen
      name="BrowseMatches"
      component={BrowseMatchesScreen}
      options={{ presentation: 'modal' }}
    />
    <RootStack.Screen
      name="TradeProposals"
      component={TradeProposalsScreen}
      options={{ presentation: 'modal' }}
    />
  </RootStack.Navigator>

);

export default MainRootStackNavigator;


// File: app\navigation\MainTabNavigator.tsx
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import SettingsScreen from '../features/main/screens/SettingsScreen';
import SwipeScreen from '../features/main/screens/SwipeScreen';
import { Image, StyleSheet } from 'react-native';
import ProfileStackNavigator from './ProfileStackNavigator';
import SwipeStackNavigator from './SwipeStackNavigator';
import ConnectionsScreen from '../features/main/screens/ConnectionsScreen';
import ConnectionStackNavigator from './ConnectionStackNavigator';
import MyProfileScreen from '../features/main/screens/MyProfileScreen';

const Tab = createBottomTabNavigator();

const icons: Record<string, number> = {
  Swipe: require('../../assets/images/swiping.png'),
  Profile: require('../../assets/images/profile.png'),
  Settings: require('../../assets/images/settings.png'),
  Connections: require('../../assets/images/connections.png'),
};

const MainTabNavigator = () => {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        headerShown: false,
        tabBarIcon: ({ focused, color, size }) => {
          const iconSource = icons[route.name];
          return (
            <Image
              source={iconSource}
              style={[
                styles.icon,
                { tintColor: focused ? '#673ab7' : '#222' },
                { width: size, height: size },
              ]}
            />
          );
        },
        tabBarActiveTintColor: '#673ab7',
        tabBarInactiveTintColor: 'gray',
      })}
    >
      <Tab.Screen name="Swipe" component={SwipeScreen}/>
      <Tab.Screen name="Profile" component={MyProfileScreen}/>
      <Tab.Screen name="Connections" component={ConnectionsScreen}/>
      <Tab.Screen name="Settings" component={SettingsScreen}/>
    </Tab.Navigator>
  );
};

export default MainTabNavigator;

const styles = StyleSheet.create({
  icon: {
    width: 24,
    height: 24,
  },
});

// File: app\navigation\OnboardingNavigator.tsx
// File: app/navigation/OnboardingNavigator.tsx
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import OnboardingWelcomeScreen from '../features/onboarding/screens/OnboardingWelcomeScreen';
import OnboardingLocationScreen from '../features/onboarding/screens/OnboardingLocationScreen';
import OnboardingBioScreen from '../features/onboarding/screens/OnboardingBioScreen';

const Stack = createNativeStackNavigator();

const OnboardingNavigator = () => {
  return (
    <Stack.Navigator screenOptions={{ headerShown: false }}>
      {/* 1. A welcome/info screen (optional). */}
      <Stack.Screen name="OnboardingWelcome" component={OnboardingWelcomeScreen} />
      <Stack.Screen name="OnboardingBio" component={OnboardingBioScreen} />
      {/* 2. A screen to set the user's location. */}
      <Stack.Screen name="OnboardingLocation" component={OnboardingLocationScreen} />
    </Stack.Navigator>
  );
};

export default OnboardingNavigator;


// File: app\store\hooks.ts
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './index'; // path to your store

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;


// File: app\store\index.ts
import { configureStore } from '@reduxjs/toolkit';
import { authSlice } from '../features/auth/store/authSlice';
import { globalErrorSlice } from './slices/globalErrorSlice';
import { loggingMiddleware } from './middlewares/loggingMiddleware';

export const store = configureStore({
  reducer: {
    auth: authSlice.reducer,
    globalError: globalErrorSlice.reducer,
  },
  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(loggingMiddleware),
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;


// File: app\store\middlewares\loggingMiddleware.ts
// File: app/store/middlewares/loggingMiddleware.ts
import { log } from '../../utils/logger';
import { Middleware } from '@reduxjs/toolkit';

export const loggingMiddleware: Middleware = (storeAPI) => (next) => (action: any) => {
  if (__DEV__) {
    log.debug("Redux Action Dispatched", { type: action.type, payload: action.payload });
  }
  const result = next(action);
  return result;
};


// File: app\store\slices\globalErrorSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface GlobalErrorState {
  message: string | null;
}

const initialState: GlobalErrorState = {
  message: null,
};

export const globalErrorSlice = createSlice({
  name: 'globalError',
  initialState,
  reducers: {
    setGlobalError(state, action: PayloadAction<string>) {
      state.message = action.payload;
    },
    clearGlobalError(state) {
      state.message = null;
    },
  },
});

export const { setGlobalError, clearGlobalError } = globalErrorSlice.actions;


// File: app\theme\colors.ts
export const COLORS2 = {
    primary: '#1EAE98',
    secondary:'#5EE2C6',
    accent: '#FF6B6B', // '#FF6F61',
    background: '#F2F2F2',
    textDark: '#2F4F4F',
    textLight: '#FFFFFF',
    cardBg: '#FFFFFF',
    border: '#ddd',
    bubbleLeft: '#fff',
    bubbleRight: '#DCF8C6',
  };

export const COLORS3 = {
    primary: '#95d0bd',
    secondary:'#6ab6a3',
    accentGreen: '#417b6b',
    accentRed: '#FF6B6B',
    accentLightRed: '#FF9F9F',
    background: '#F2F2F2',
    textDark: '#2F4F4F',
    textLight: '#FFFFFF',
    cardBg: '#FFFFFF',
    border: '#ddd',
    bubbleLeft: '#fff',
    bubbleRight: '#DCF8C6',
  };

  export const COLORS = {
    primary: '#b0ccac',
    secondary:'#6ab6a3',
    accentGreen: '#417b6b',
    accentRed: '#FF6B6B',
    accentLightRed: '#FF9F9F',
    background: '#F2F2F2',
    textDark: '#2F4F4F',
    textLight: '#FFFFFF',
    cardBg1: '#FFFFFF',
    cardBg2: '#e1e1e1',
    border: '#ddd',
    bubbleLeft: '#fff',
    bubbleRight: '#DCF8C6',
    accentOrange: '#F39C12'
  };

// File: app\theme\index.ts


// File: app\theme\spacing.ts


// File: app\theme\typography.ts


// File: app\types\apiTypes.ts
import { PlantStage, PlantCategory, WateringNeed, LightRequirement, Size, IndoorOutdoor, PropagationEase, PetFriendly, Extras, TradeProposalStatus } from './enums';

export interface RefreshTokenRequest {
    refreshToken: string;
}

export interface MessageRequest {
    messageText: string;
}

export interface PlantCreateRequest {
    plantDetails: PlantRequest;
    image: File;
}

export interface PlantRequest {
    speciesName: string;
    description: string | null;
    plantStage: PlantStage;
    plantCategory: PlantCategory | null;
    wateringNeed: WateringNeed | null;
    lightRequirement: LightRequirement | null;
    size: Size | null;
    indoorOutdoor: IndoorOutdoor | null;
    propagationEase: PropagationEase | null;
    petFriendly: PetFriendly | null;
    extras: Extras[];
}

export interface PlantUpdateRequest {
    speciesName: string;
    careRequirements: string;
    description: string;
    category: string;
}

export interface ReportRequest {
    reportedUserId: number;
    reason: string;
    comments: string;
}

export interface SwipeRequest {
    swiperPlantId: number;
    swipedPlantId: number;
    isLike: boolean;
}

export interface UpdateLocationRequest {
    latitude: number;
    longitude: number;
}

export interface UserLoginRequest {
    email: string;
    password: string;
}

export interface UserPreferencesRequest {
    searchRadius: number;
    preferedPlantStage: PlantStage[];
    preferedPlantCategory: PlantCategory[];
    preferedWateringNeed: WateringNeed[];
    preferedLightRequirement: LightRequirement[];
    preferedSize: Size[];
    preferedIndoorOutdoor: IndoorOutdoor[];
    preferedPropagationEase: PropagationEase[];
    preferedPetFriendly: PetFriendly[];
    preferedExtras: Extras[];
}

export interface UserProfileImageUpdateRequest {
    image: File;
}

export interface UserRegistrationRequest {
    email: string;
    password: string;
    name: string;
}

export interface TradeProposalRequest{
    userPlantIds: number[];
    otherPlantIds: number[];
}

export interface UpdateTradeProposalStatusRequest{
    newStatus: TradeProposalStatus;
}

export interface UserUpdateRequest {
    name: string;
    bio: string;
}

export interface AuthTokenResponse {
    accessToken: string;
    refreshToken: string;
    tokenType: string;
    expiresIn: number;
}

export interface MatchResponse {
    matchId: number;
    connectionId: number;
    plant1: PlantResponse;
    plant2: PlantResponse;
    isClosed: boolean;    
}

export interface MessageResponse {
    messageId: number;
    connectionId: number;
    senderUserId: number;
    messageText: string;
    sentAt: Date;
    isRead: boolean;
}

export interface PlantResponse {
    plantId: number;
    userId: number;
    speciesName: string;
    description: string;
    plantStage: PlantStage;
    plantCategory: PlantCategory;
    wateringNeed: WateringNeed;
    lightRequirement: LightRequirement;
    size?: Size;
    indoorOutdoor?: IndoorOutdoor;
    propagationEase?: PropagationEase;
    petFriendly?: PetFriendly;
    extras?: Extras[];
    imageUrl: string;
}

export interface ReportResponse {
    reportId: number;
    reporterUserId: number;
    reportedUserId: number;
    reason: string;
    comments: string;
    createdAt: Date;
    isResolved: boolean;
}

export interface SwipeResponse {
    isMatch: boolean;
    connection: ConnectionResponse;
    match: MatchResponse;
}

export interface UserLoginResponse {
    userId: number;
    email: string;
    tokens: AuthTokenResponse;
}

export interface UserPreferencesResponse {
    userId: number;
    searchRadius: number;
    preferedPlantStage: PlantStage[];
    preferedPlantCategory: PlantCategory[];
    preferedWateringNeed: WateringNeed[];
    preferedLightRequirement: LightRequirement[];
    preferedSize: Size[];
    preferedIndoorOutdoor: IndoorOutdoor[];
    preferedPropagationEase: PropagationEase[];
    preferedPetFriendly: PetFriendly[];
    preferedExtras: Extras[];
}

export interface UserResponse {
    userId: number;
    email: string;
    name: string;
    profilePictureUrl: string;
    bio: string;
    locationLatitude?: number;
    locationLongitude?: number;
}

export interface ConnectionResponse {
    connectionId: number;
    user1: UserResponse;
    user2: UserResponse;
    numberOfMatches: number;
}

export interface TradeProposalResponse{
    tradeProposalId: number;
    connectionId: number;
    plantsProposedByUser1: PlantResponse[];
    plantsProposedByUser2: PlantResponse[];
    tradeProposalStatus: TradeProposalStatus;
    createdAt: Date;
    acceptedAt: Date;
    declinedAt: Date;
    completedAt: Date;
    connection: ConnectionResponse;
    proposalOwnerUserId: number;
    ownerCompletionConfirmed: boolean;
    responderCompletionConfirmed: boolean;
}




// File: app\types\enums.ts
export enum PlantStage {
	Seedling = "Seedling",
	Cutting = "Cutting",
	Mature = "Mature",
  }
  
  export enum PlantCategory {
	Succulent = "Succulent",
	Cactus = "Cactus",
	Fern = "Fern",
	Orchid = "Orchid",
	Herb = "Herb",
	Palm = "Palm",
	LeafyHouseplant = "LeafyHouseplant",
	AquaticPlant = "AquaticPlant",
	ClimbingPlant = "ClimbingPlant",
	Tree = "Tree",
	Other = "Other"
  }
  
  export enum WateringNeed {
	VeryLowWater = "VeryLowWater",
	LowWater = "LowWater",
	ModerateWater = "ModerateWater",
	HighWater = "HighWater",
	VeryHighWater = "VeryHighWater"
  }
  
  export enum LightRequirement {
	FullSun = "FullSun",
	PartialSun = "PartialSun",
	BrightIndirectLight = "BrightIndirectLight",
	LowLight = "LowLight",
  }
  
  export enum Size {
	SmallSize = "SmallSize",
	MediumSize = "MediumSize",
	LargeSize = "LargeSize"
  }
  
  export enum IndoorOutdoor {
	Indoor = "Indoor",
	Outdoor = "Outdoor",
	IndoorAndOutdoor = "IndoorAndOutdoor"
  }
  
  export enum PropagationEase {
	EasyPropagation = "EasyPropagation",
	ModeratePropagation = "ModeratePropagation",
	DifficultPropagation = "DifficultPropagation"
  }
  
  export enum PetFriendly {
	PetFriendly = "PetFriendly",
	NotPetFriendly = "NotPetFriendly",
  }
  
  export enum Extras {
	Fragrant = "Fragrant",
	Edible = "Edible",
	Medicinal = "Medicinal",
	AirPurifying = "AirPurifying",
	Decorative = "Decorative",
	Flowering = "Flowering",
	TropicalVibe = "TropicalVibe",
	FoliageHeavy = "FoliageHeavy",
	DroughtTolerant = "DroughtTolerant",
	HumidityLoving = "HumidityLoving",
	LowMaintenance = "LowMaintenance",
	WinterHardy = "WinterHardy",
	BeginnerFriendly = "BeginnerFriendly",
	Fruiting = "Fruiting",
	PollinatorFriendly = "PollinatorFriendly",
	FastGrowing = "FastGrowing",
	VariegatedFoliage = "VariegatedFoliage",
	Climbing = "Climbing",
	GroundCover = "GroundCover",
	Rare = "Rare"
  }

  export enum TradeProposalStatus {
	Pending = "Pending",
	Accepted = "Accepted",
	Rejected = "Rejected",
	Completed = "Completed"
  }
  

// File: app\types\global.ts


// File: app\utils\formatting.ts


// File: app\utils\index.ts


// File: app\utils\logger.ts
// File: app/utils/logger.ts
import createLogger from 'react-native-logs';
import { logger } from 'react-native-logs';

const defaultConfig = {
  severity: __DEV__ ? 'debug' : 'warn',  
//   transportOptions: {
//     // You can configure a custom transport here, e.g., sending logs to your backend or Sentry
//   },
//   // You can override formatting, date/time formatting, etc.
};

export const log = logger.createLogger(defaultConfig);


// File: app\utils\storage.ts
import * as SecureStore from "expo-secure-store";

const ACCESS_TOKEN_KEY = "ACCESS_TOKEN_KEY";
const REFRESH_TOKEN_KEY = "REFRESH_TOKEN_KEY";
const LANGUAGE_KEY = "LANGUAGE_KEY";

export const storage = {
  saveTokens: async (accessToken: string, refreshToken: string) => {
    await SecureStore.setItemAsync(ACCESS_TOKEN_KEY, accessToken);
    await SecureStore.setItemAsync(REFRESH_TOKEN_KEY, refreshToken);
  },
  getAccessToken: async () => SecureStore.getItemAsync(ACCESS_TOKEN_KEY),
  getRefreshToken: async () => SecureStore.getItemAsync(REFRESH_TOKEN_KEY),
  clearTokens: async () => {
    await SecureStore.deleteItemAsync(ACCESS_TOKEN_KEY);
    await SecureStore.deleteItemAsync(REFRESH_TOKEN_KEY);
  },
  // Language Handling
  saveLanguage: async (language: string) => {
    await SecureStore.setItemAsync(LANGUAGE_KEY, language);
  },
  getLanguage: async () => SecureStore.getItemAsync(LANGUAGE_KEY),
};


// File: app\utils\validation.ts


// File: scripts\reset-project.js
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const newDir = "app-example";
const newAppDir = "app";
const newDirPath = path.join(root, newDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const moveDirectories = async () => {
  try {
    // Create the app-example directory
    await fs.promises.mkdir(newDirPath, { recursive: true });
    console.log(`📁 /${newDir} directory created.`);

    // Move old directories to new app-example directory
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      const newDirPath = path.join(root, newDir, dir);
      if (fs.existsSync(oldDirPath)) {
        await fs.promises.rename(oldDirPath, newDirPath);
        console.log(`➡️ /${dir} moved to /${newDir}/${dir}.`);
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      "1. Run `npx expo start` to start a development server.\n2. Edit app/index.tsx to edit the main screen.\n3. Delete the /app-example directory when you're done referencing it."
    );
  } catch (error) {
    console.error(`Error during script execution: ${error}`);
  }
};

moveDirectories();

